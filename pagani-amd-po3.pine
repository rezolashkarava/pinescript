//@version=6
indicator("Pagani AMD / PO3", overlay=true, max_boxes_count=20, max_labels_count=50)

groupPreset = "Presets"
presetMode = input.string("Institutional (Strict)", "Preset", options=["Institutional (Strict)", "Balanced", "Aggressive", "Manual"], group=groupPreset,
     tooltip="Institutional: fewer, higher-quality phase shifts.\nBalanced: defaults.\nAggressive: more signals.\nManual: use all inputs as-is.")

tradingStyleInput = input.string("Auto", "Trading Style", options=["Auto", "Scalp", "Day", "Swing", "Manual"], group=groupPreset,
     tooltip="Auto uses chart timeframe to pick Scalp/Day/Swing defaults.\nManual uses raw inputs without timeframe scaling.")

groupSess = "Sessions (Optional Filter)"
tzInput = input.string("America/New_York", "Timezone", group=groupSess)
useSessionFilterInput = input.bool(true, "Use Session Filter", group=groupSess,
     tooltip="If enabled, Manipulation/Distribution triggers are only allowed inside the configured session windows.\nFor crypto, this is a liquidity filter (not a requirement).")
accSessionInput = input.session("2000-0000", "Accumulation Window", group=groupSess)
manSessionInput = input.session("0000-0300", "Manipulation Window", group=groupSess)
distSessionInput = input.session("0300-0800", "Distribution Window", group=groupSess)

groupDet = "Detection"
signalTimingInput = input.string("Confirmed (bar close)", "Signal Timing", options=["Confirmed (bar close)", "Realtime (intrabar)"], group=groupDet)

atrLenInput = input.int(14, "ATR Length", minval=1, group=groupDet)
regimeLenInput = input.int(100, "Regime Length", minval=10, group=groupDet)
lowVolMultInput = input.float(0.75, "Low Vol Threshold (x ATR MA)", minval=0.1, maxval=2.0, step=0.05, group=groupDet)
volRegimeModeInput = input.string("ATR/MA", "Volatility Regime Mode", options=["ATR/MA", "ATR %Rank"], group=groupDet,
     tooltip="ATR/MA: low volatility when ATR < ATR moving average * threshold.\nATR %Rank: low volatility when ATR is in the lowest percentile of its own history (more robust across assets).")
atrPctLookbackInput = input.int(200, "ATR %Rank Lookback", minval=20, maxval=5000, group=groupDet)
lowVolPctThresholdInput = input.float(25.0, "Low Vol %Rank Threshold", minval=1.0, maxval=50.0, step=1.0, group=groupDet,
     tooltip="Only used when Volatility Regime Mode = ATR %Rank.\nExample: 25 means ATR is in the lowest 25% of the last N bars.")

rangeLenInput = input.int(30, "Range Lookback (bars)", minval=10, group=groupDet)
rangeAtrMultInput = input.float(4.0, "Max Range (x ATR)", minval=0.5, maxval=20.0, step=0.1, group=groupDet,
     tooltip="Defines how tight the consolidation must be.\nRule: rolling range width <= (ATR reference * this multiplier).\nFor most markets, values below ~2 are extremely strict.")
minRangePctInput = input.float(0.03, "Min Range (% of price)", minval=0.0, maxval=2.0, step=0.01, group=groupDet,
     tooltip="Multi-asset guardrail: prevents the range threshold from becoming too small on low-ATR markets.")

minAccBarsInput = input.int(12, "Min Accumulation Bars", minval=5, maxval=200, group=groupDet)

requireCloseBackInput = input.bool(true, "Sweep Requires Close Back Inside", group=groupDet)
sweepMinExcAtrInput = input.float(0.25, "Min Sweep Excursion (x ATR)", minval=0.0, maxval=5.0, step=0.05, group=groupDet,
     tooltip="Minimum distance price must run beyond the range boundary to count as a sweep.\nSet > 0 to avoid micro-wick noise on low timeframes.")
maxBarsToSweepInput = input.int(120, "Max Bars To Sweep After Acc", minval=10, maxval=2000, group=groupDet)

dispAtrMultInput = input.float(1.2, "Displacement (Body x ATR)", minval=0.1, maxval=10.0, step=0.1, group=groupDet)
minBodyPctTrInput = input.float(0.55, "Displacement (Body / TR)", minval=0.1, maxval=1.0, step=0.05, group=groupDet)
dispBarsInput = input.int(1, "Displacement Bars", minval=1, maxval=3, group=groupDet,
     tooltip="Number of consecutive displacement candles required to start Distribution.\nHigher values reduce noise but will miss grindy moves.")
requireFvgInput = input.bool(true, "Require FVG Confirmation", group=groupDet)
fvgMinAtrInput = input.float(0.15, "Min FVG (x ATR)", minval=0.0, maxval=5.0, step=0.05, group=groupDet)
maxBarsToDistributeInput = input.int(240, "Max Bars To Distribute After Sweep", minval=10, maxval=5000, group=groupDet)

groupVis = "Visuals"
showAccBoxInput = input.bool(true, "Show Accumulation Box", group=groupVis)
showRangeLinesInput = input.bool(true, "Show Range High/Low", group=groupVis)
showMarkersInput = input.bool(true, "Show M/D Markers", group=groupVis)
showDistTintInput = input.bool(true, "Tint Distribution", group=groupVis)

groupAlerts = "Alerts"
alertRangeLockedInput = input.bool(true, "Alert: Range Locked", group=groupAlerts)
alertSweepInput = input.bool(true, "Alert: Manipulation Sweep", group=groupAlerts)
alertDistInput = input.bool(true, "Alert: Distribution Started", group=groupAlerts)

float bgLuma = 0.299 * color.r(chart.bg_color) + 0.587 * color.g(chart.bg_color) + 0.114 * color.b(chart.bg_color)
bool chartIsDark = bgLuma < 128

int tfSec = timeframe.in_seconds(timeframe.period)
string autoStyle = tfSec <= 300 ? "Scalp" : tfSec <= 1800 ? "Day" : "Swing"
string tradingStyle = tradingStyleInput == "Auto" ? autoStyle : tradingStyleInput

bool useSessionFilter = presetMode == "Institutional (Strict)" ? true : tradingStyle == "Swing" ? false : useSessionFilterInput
string signalTiming = presetMode == "Institutional (Strict)" ? "Confirmed (bar close)" : signalTimingInput

int atrLen = presetMode == "Aggressive" ? math.max(atrLenInput, 10) : atrLenInput
int regimeLen0 = presetMode == "Institutional (Strict)" ? math.max(regimeLenInput, 150) : presetMode == "Aggressive" ? math.max(regimeLenInput, 60) : regimeLenInput
int regimeLen = tradingStyle == "Manual" ? regimeLen0 : tradingStyle == "Scalp" ? math.min(regimeLen0, 80) : tradingStyle == "Swing" ? math.max(regimeLen0, 200) : regimeLen0
float lowVolMult = presetMode == "Institutional (Strict)" ? math.min(lowVolMultInput, 0.65) : presetMode == "Aggressive" ? math.max(lowVolMultInput, 0.85) : lowVolMultInput
string volRegimeMode = volRegimeModeInput
int atrPctLookback = presetMode == "Institutional (Strict)" ? math.max(atrPctLookbackInput, 300) : presetMode == "Aggressive" ? math.max(atrPctLookbackInput, 120) : atrPctLookbackInput
float lowVolPctThreshold = presetMode == "Institutional (Strict)" ? math.min(lowVolPctThresholdInput, 20.0) : presetMode == "Aggressive" ? math.max(lowVolPctThresholdInput, 35.0) : lowVolPctThresholdInput

int rangeLen0 = presetMode == "Institutional (Strict)" ? math.max(rangeLenInput, 40) : presetMode == "Aggressive" ? math.max(rangeLenInput, 20) : rangeLenInput
int rangeLen = tradingStyle == "Manual" ? rangeLen0 : tradingStyle == "Scalp" ? math.min(rangeLen0, 25) : tradingStyle == "Swing" ? math.max(rangeLen0, 60) : rangeLen0
float rangeAtrMult = presetMode == "Institutional (Strict)" ? math.min(rangeAtrMultInput, 3.0) : presetMode == "Aggressive" ? math.max(rangeAtrMultInput, 5.5) : rangeAtrMultInput
float minRangePct = presetMode == "Institutional (Strict)" ? math.min(minRangePctInput, 0.02) : presetMode == "Aggressive" ? math.max(minRangePctInput, 0.06) : minRangePctInput
int minAccBars0 = presetMode == "Institutional (Strict)" ? math.max(minAccBarsInput, 16) : presetMode == "Aggressive" ? math.max(minAccBarsInput, 8) : minAccBarsInput
int minAccBars = tradingStyle == "Manual" ? minAccBars0 : tradingStyle == "Scalp" ? math.min(minAccBars0, 10) : tradingStyle == "Swing" ? math.max(minAccBars0, 20) : minAccBars0

bool requireCloseBack = presetMode == "Institutional (Strict)" ? true : requireCloseBackInput
float sweepMinExcAtr = presetMode == "Institutional (Strict)" ? math.max(sweepMinExcAtrInput, 0.50) : presetMode == "Aggressive" ? math.max(sweepMinExcAtrInput, 0.15) : sweepMinExcAtrInput
int maxBarsToSweep0 = presetMode == "Institutional (Strict)" ? math.min(maxBarsToSweepInput, 90) : presetMode == "Aggressive" ? math.max(maxBarsToSweepInput, 240) : maxBarsToSweepInput
int maxBarsToSweep = tradingStyle == "Manual" ? maxBarsToSweep0 : tradingStyle == "Scalp" ? math.min(maxBarsToSweep0, 60) : tradingStyle == "Swing" ? math.max(maxBarsToSweep0, 400) : maxBarsToSweep0

float dispAtrMult = presetMode == "Institutional (Strict)" ? math.max(dispAtrMultInput, 1.6) : presetMode == "Aggressive" ? math.max(dispAtrMultInput, 1.0) : dispAtrMultInput
float minBodyPctTr = presetMode == "Institutional (Strict)" ? math.max(minBodyPctTrInput, 0.65) : presetMode == "Aggressive" ? math.max(minBodyPctTrInput, 0.45) : minBodyPctTrInput
int dispBars = presetMode == "Institutional (Strict)" ? math.max(dispBarsInput, 2) : presetMode == "Aggressive" ? 1 : dispBarsInput
bool requireFvg = presetMode == "Institutional (Strict)" ? true : requireFvgInput
float fvgMinAtr = presetMode == "Institutional (Strict)" ? math.max(fvgMinAtrInput, 0.20) : presetMode == "Aggressive" ? math.max(fvgMinAtrInput, 0.05) : fvgMinAtrInput
int maxBarsToDistribute0 = presetMode == "Institutional (Strict)" ? math.min(maxBarsToDistributeInput, 180) : presetMode == "Aggressive" ? math.max(maxBarsToDistributeInput, 360) : maxBarsToDistributeInput
int maxBarsToDistribute = tradingStyle == "Manual" ? maxBarsToDistribute0 : tradingStyle == "Scalp" ? math.min(maxBarsToDistribute0, 120) : tradingStyle == "Swing" ? math.max(maxBarsToDistribute0, 800) : maxBarsToDistribute0

bool showAccBox = showAccBoxInput
bool showRangeLines = showRangeLinesInput
bool showMarkers = showMarkersInput
bool showDistTint = showDistTintInput

bool alertRangeLocked = presetMode == "Institutional (Strict)" ? true : alertRangeLockedInput
bool alertSweep = presetMode == "Institutional (Strict)" ? true : alertSweepInput
bool alertDist = presetMode == "Institutional (Strict)" ? true : alertDistInput

bool shouldUpdate = signalTiming == "Realtime (intrabar)" or barstate.isconfirmed

string days = "1234567"
string accStr = accSessionInput + ":" + days
string manStr = manSessionInput + ":" + days
string distStr = distSessionInput + ":" + days

bool inAcc = not na(time(timeframe.period, accStr, tzInput))
bool inMan = not na(time(timeframe.period, manStr, tzInput))
bool inDist = not na(time(timeframe.period, distStr, tzInput))

float atr = ta.atr(atrLen)
float atrMa = ta.sma(atr, regimeLen)
float tr = ta.tr(true)

float atrPctRank = ta.percentrank(atr, atrPctLookback)

float rangeHighRoll = ta.highest(high, rangeLen)
float rangeLowRoll = ta.lowest(low, rangeLen)
float rangeWidthRoll = rangeHighRoll - rangeLowRoll
float rangeMinFloor = close * (minRangePct / 100.0)
float atrRef = na(atrMa) ? atr : atrMa
float rangeMax = math.max(atrRef * rangeAtrMult, rangeMinFloor)
bool lowVolAtrMa = not na(atrMa) and atr < atrMa * lowVolMult
bool lowVolPct = not na(atrPctRank) and atrPctRank <= lowVolPctThreshold
bool lowVol = volRegimeMode == "ATR %Rank" ? lowVolPct : lowVolAtrMa
bool tightRange = rangeWidthRoll <= rangeMax

bool accCond = lowVol and tightRange

// === Phase state ===
// 0: idle, 1: accumulation (building), 2: range locked (waiting sweep), 3: sweep confirmed (waiting distribution), 4: distribution
var int phase = 0
var int accStartBar = na
var int lockBar = na
var int sweepBar = na
var int distBar = na
var float rangeHigh = na
var float rangeLow = na
var int sweepDir = 0

var box accBox = na
var line rangeHighLine = na
var line rangeLowLine = na

var int accStreak = 0

bool allowManNow = not useSessionFilter or inMan
bool allowDistNow = not useSessionFilter or inDist

// Events (one-bar pulses)
bool evRangeLocked = false
bool evSweepUp = false
bool evSweepDown = false
bool evDistUp = false
bool evDistDown = false

evRangeLocked := false
evSweepUp := false
evSweepDown := false
evDistUp := false
evDistDown := false

f_deleteObjects(box _accBox, line _rangeHighLine, line _rangeLowLine) =>
    if not na(_accBox)
        box.delete(_accBox)
    if not na(_rangeHighLine)
        line.delete(_rangeHighLine)
    if not na(_rangeLowLine)
        line.delete(_rangeLowLine)

if shouldUpdate
    // Track consecutive bars meeting accumulation regime.
    accStreak := accCond ? accStreak + 1 : 0

    // Reset if we somehow lose required series early on.
    if na(atr) or na(rangeHighRoll) or na(rangeLowRoll)
        f_deleteObjects(accBox, rangeHighLine, rangeLowLine)
        phase := 0
        accStartBar := na
        lockBar := na
        sweepBar := na
        distBar := na
        rangeHigh := na
        rangeLow := na
        sweepDir := 0
        accStreak := 0
        accBox := na
        rangeHighLine := na
        rangeLowLine := na
    else
        // Start accumulation once regime holds long enough.
        if phase == 0 and accStreak >= minAccBars
            phase := 1
            accStartBar := bar_index - minAccBars + 1
            rangeHigh := ta.highest(high, minAccBars)
            rangeLow := ta.lowest(low, minAccBars)
            lockBar := na
            sweepBar := na
            distBar := na
            sweepDir := 0
            if not na(accBox)
                box.delete(accBox)
            accBox := na
            if showAccBox
                accBox := box.new(accStartBar, rangeHigh, bar_index, rangeLow, xloc=xloc.bar_index, bgcolor=color.new(color.gray, 90), border_color=color.new(color.gray, 40), border_width=1)

        // While accumulating, keep expanding the range.
        if phase == 1
            rangeHigh := math.max(rangeHigh, high)
            rangeLow := math.min(rangeLow, low)
            if showAccBox and not na(accBox)
                box.set_lefttop(accBox, accStartBar, rangeHigh)
                box.set_rightbottom(accBox, bar_index, rangeLow)

            // Lock the range when the low-vol regime breaks.
            if not accCond
                phase := 2
                lockBar := bar_index
                evRangeLocked := true

                if showRangeLines
                    if not na(rangeHighLine)
                        line.delete(rangeHighLine)
                    if not na(rangeLowLine)
                        line.delete(rangeLowLine)
                    // Draw the locked range across the accumulation window.
                    // Avoid extending to the last bar so drawings behave predictably when panning/zooming.
                    rangeHighLine := line.new(x1=accStartBar, y1=rangeHigh, x2=lockBar, y2=rangeHigh, xloc=xloc.bar_index, extend=extend.none, color=color.new(color.gray, 30), width=1)
                    rangeLowLine := line.new(x1=accStartBar, y1=rangeLow, x2=lockBar, y2=rangeLow, xloc=xloc.bar_index, extend=extend.none, color=color.new(color.gray, 30), width=1)

        // Waiting for sweep.
        if phase == 2
            bool timeOk = not na(lockBar) and bar_index - lockBar <= maxBarsToSweep
            if not timeOk
                f_deleteObjects(accBox, rangeHighLine, rangeLowLine)
                phase := 0
                accStartBar := na
                lockBar := na
                sweepBar := na
                distBar := na
                rangeHigh := na
                rangeLow := na
                sweepDir := 0
                accStreak := 0
                accBox := na
                rangeHighLine := na
                rangeLowLine := na
            else if allowManNow
                bool sweptUp = high > rangeHigh
                bool sweptDown = low < rangeLow
                bool excUpOk = sweepMinExcAtr <= 0 ? true : (high - rangeHigh) >= sweepMinExcAtr * atrRef
                bool excDownOk = sweepMinExcAtr <= 0 ? true : (rangeLow - low) >= sweepMinExcAtr * atrRef
                bool closeBackUp = not requireCloseBack or close < rangeHigh
                bool closeBackDown = not requireCloseBack or close > rangeLow
                bool manUp = sweptUp and excUpOk and closeBackUp
                bool manDown = sweptDown and excDownOk and closeBackDown

                if manUp or manDown
                    phase := 3
                    sweepBar := bar_index
                    sweepDir := manUp ? 1 : -1
                    evSweepUp := manUp
                    evSweepDown := manDown

        // Waiting for distribution confirmation.
        if phase == 3
            bool timeOk = not na(sweepBar) and bar_index - sweepBar <= maxBarsToDistribute
            if not timeOk
                f_deleteObjects(accBox, rangeHighLine, rangeLowLine)
                phase := 0
                accStartBar := na
                lockBar := na
                sweepBar := na
                distBar := na
                rangeHigh := na
                rangeLow := na
                sweepDir := 0
                accStreak := 0
                accBox := na
                rangeHighLine := na
                rangeLowLine := na
            else if allowDistNow
                int expectedDir = -sweepDir
                float body = math.abs(close - open)

                bool dirOk = expectedDir == 1 ? close > open : close < open
                bool dispBar = body >= dispAtrMult * atr and (tr > 0 ? (body / tr) : 0) >= minBodyPctTr and dirOk
                bool dispSeqOk = dispBars == 1 ? dispBar : dispBars == 2 ? (dispBar and dispBar[1]) : (dispBar and dispBar[1] and dispBar[2])

                bool bullFvgNow = not na(high[2]) and low > high[2] and (low - high[2]) >= fvgMinAtr * atr
                bool bearFvgNow = not na(low[2]) and high < low[2] and (low[2] - high) >= fvgMinAtr * atr
                bool bullFvgSeq = dispBars == 1 ? bullFvgNow : dispBars == 2 ? (bullFvgNow or bullFvgNow[1]) : (bullFvgNow or bullFvgNow[1] or bullFvgNow[2])
                bool bearFvgSeq = dispBars == 1 ? bearFvgNow : dispBars == 2 ? (bearFvgNow or bearFvgNow[1]) : (bearFvgNow or bearFvgNow[1] or bearFvgNow[2])
                bool fvgOk = not requireFvg or (expectedDir == 1 ? bullFvgSeq : bearFvgSeq)

                if dispSeqOk and fvgOk
                    phase := 4
                    distBar := bar_index
                    evDistUp := expectedDir == 1
                    evDistDown := expectedDir == -1

        // Distribution phase: ends when a new accumulation regime starts.
        if phase == 4 and accStreak >= minAccBars
            f_deleteObjects(accBox, rangeHighLine, rangeLowLine)
            phase := 0
            accStartBar := na
            lockBar := na
            sweepBar := na
            distBar := na
            rangeHigh := na
            rangeLow := na
            sweepDir := 0
            accStreak := 0
            accBox := na
            rangeHighLine := na
            rangeLowLine := na

    // No continuous line updates: keep drawings anchored to their creation bars.

// === Visuals ===
plotshape(showMarkers and evSweepUp, title="M Sweep Up", style=shape.triangledown, location=location.abovebar, size=size.tiny, color=color.new(#ff3366, 0), text="M", textcolor=color.white)
plotshape(showMarkers and evSweepDown, title="M Sweep Down", style=shape.triangleup, location=location.belowbar, size=size.tiny, color=color.new(#00ff88, 0), text="M", textcolor=chartIsDark ? color.white : color.black)
plotshape(showMarkers and evDistUp, title="D Up", style=shape.triangleup, location=location.belowbar, size=size.tiny, color=color.new(#00ff88, 0), text="D", textcolor=chartIsDark ? color.white : color.black)
plotshape(showMarkers and evDistDown, title="D Down", style=shape.triangledown, location=location.abovebar, size=size.tiny, color=color.new(#ff3366, 0), text="D", textcolor=color.white)

bool inDistState = phase == 4
bgcolor(showDistTint and inDistState ? color.new(sweepDir == -1 ? #00ff88 : #ff3366, 92) : na)

// === Alerts ===
alertcondition(alertRangeLocked and evRangeLocked, title="AMD: Range Locked", message="AMD range locked on {{ticker}} {{interval}}")
alertcondition(alertSweep and evSweepUp, title="AMD: Manipulation Sweep Up", message="AMD manipulation sweep UP on {{ticker}} {{interval}}")
alertcondition(alertSweep and evSweepDown, title="AMD: Manipulation Sweep Down", message="AMD manipulation sweep DOWN on {{ticker}} {{interval}}")
alertcondition(alertDist and evDistUp, title="AMD: Distribution Started Up", message="AMD distribution started UP on {{ticker}} {{interval}}")
alertcondition(alertDist and evDistDown, title="AMD: Distribution Started Down", message="AMD distribution started DOWN on {{ticker}} {{interval}}")
