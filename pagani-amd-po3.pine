//@version=6
indicator("Pagani AMD / PO3", overlay=true, max_boxes_count=20, max_labels_count=50)

groupPreset = "Presets"
presetMode = input.string("Balanced", "Preset", options=["Institutional (Strict)", "Balanced", "Aggressive", "Manual"], group=groupPreset,
     tooltip="Institutional: fewer, higher-quality phase shifts.\nBalanced: defaults.\nAggressive: more signals.\nManual: use all inputs as-is.")

tradingStyleInput = input.string("Auto", "Trading Style", options=["Auto", "Scalp", "Day", "Swing", "Manual"], group=groupPreset,
     tooltip="Auto uses chart timeframe to pick Scalp/Day/Swing defaults.\nManual uses raw inputs without timeframe scaling.")

groupDet = "Detection"
signalTimingInput = input.string("Confirmed (bar close)", "Signal Timing", options=["Confirmed (bar close)", "Realtime (intrabar)"], group=groupDet)

atrLenInput = input.int(14, "ATR Length", minval=1, group=groupDet)
regimeLenInput = input.int(120, "Regime Length", minval=10, group=groupDet)
lowVolMultInput = input.float(0.95, "Low Vol Threshold (x ATR MA)", minval=0.1, maxval=2.0, step=0.05, group=groupDet)
volRegimeModeInput = input.string("ATR %Rank", "Volatility Regime Mode", options=["ATR/MA", "ATR %Rank"], group=groupDet,
     tooltip="ATR/MA: low volatility when ATR < ATR moving average * threshold.\nATR %Rank: low volatility when ATR is in the lowest percentile of its own history (more robust across assets).")
atrPctLookbackInput = input.int(250, "ATR %Rank Lookback", minval=20, maxval=5000, group=groupDet)
lowVolPctThresholdInput = input.float(35.0, "Low Vol %Rank Threshold", minval=1.0, maxval=50.0, step=1.0, group=groupDet,
     tooltip="Only used when Volatility Regime Mode = ATR %Rank.\nExample: 25 means ATR is in the lowest 25% of the last N bars.")

rangeLenInput = input.int(25, "Range Lookback (bars)", minval=10, group=groupDet)
rangeAtrMultInput = input.float(4.0, "Max Range (x ATR)", minval=0.5, maxval=20.0, step=0.1, group=groupDet,
     tooltip="Defines how tight the consolidation must be.\nRule: rolling range width <= (ATR reference * this multiplier).\nFor most markets, values below ~2 are extremely strict.")
minRangePctInput = input.float(0.04, "Min Range (% of price)", minval=0.0, maxval=2.0, step=0.01, group=groupDet,
     tooltip="Multi-asset guardrail: prevents the range threshold from becoming too small on low-ATR markets.")

minAccBarsInput = input.int(10, "Min Accumulation Bars", minval=5, maxval=200, group=groupDet)

requireCloseBackInput = input.bool(true, "Sweep Requires Close Back Inside", group=groupDet)
sweepMinExcAtrInput = input.float(0.20, "Min Sweep Excursion (x ATR)", minval=0.0, maxval=5.0, step=0.05, group=groupDet,
     tooltip="Minimum distance price must run beyond the range boundary to count as a sweep.\nSet > 0 to avoid micro-wick noise on low timeframes.")
maxBarsToSweepInput = input.int(150, "Max Bars To Sweep After Acc", minval=10, maxval=2000, group=groupDet)

dispAtrMultInput = input.float(1.1, "Displacement (Body x ATR)", minval=0.1, maxval=10.0, step=0.1, group=groupDet)
minBodyPctTrInput = input.float(0.55, "Displacement (Body / TR)", minval=0.1, maxval=1.0, step=0.05, group=groupDet)
minBarsAfterSweepInput = input.int(1, "Min Bars After Sweep", minval=1, maxval=50, group=groupDet,
     tooltip="Prevents M and D triggering on the same bar.\nExample: 1 = earliest D on the next candle.")
dispBarsInput = input.int(1, "Displacement Bars", minval=1, maxval=3, group=groupDet,
     tooltip="Number of consecutive displacement candles required to start Distribution.\nHigher values reduce noise but will miss grindy moves.")
requireFvgInput = input.bool(false, "Require FVG Confirmation", group=groupDet)
fvgMinAtrInput = input.float(0.10, "Min FVG (x ATR)", minval=0.0, maxval=5.0, step=0.05, group=groupDet)
maxBarsToDistributeInput = input.int(300, "Max Bars To Distribute After Sweep", minval=10, maxval=5000, group=groupDet)

groupVis = "Visuals"
showAccBoxInput = input.bool(true, "Show Accumulation Box", group=groupVis)
showRangeLinesInput = input.bool(true, "Show Range High/Low", group=groupVis)
showMarkersInput = input.bool(true, "Show M/D Markers", group=groupVis)
showDistTintInput = input.bool(true, "Tint Distribution", group=groupVis)

groupAlerts = "Alerts"
alertRangeLockedInput = input.bool(true, "Alert: Range Locked", group=groupAlerts)
alertSweepInput = input.bool(true, "Alert: Manipulation Sweep", group=groupAlerts)
alertDistInput = input.bool(true, "Alert: Distribution Started", group=groupAlerts)

float bgLuma = 0.299 * color.r(chart.bg_color) + 0.587 * color.g(chart.bg_color) + 0.114 * color.b(chart.bg_color)
bool chartIsDark = bgLuma < 128
color markerTextCol = chartIsDark ? color.white : color.black

int tfSec = timeframe.in_seconds(timeframe.period)
string autoStyle = tfSec <= 300 ? "Scalp" : tfSec <= 1800 ? "Day" : "Swing"
string tradingStyle = tradingStyleInput == "Auto" ? autoStyle : tradingStyleInput

string signalTiming = presetMode == "Institutional (Strict)" ? "Confirmed (bar close)" : signalTimingInput

int atrLen = presetMode == "Aggressive" ? math.max(atrLenInput, 10) : atrLenInput
int regimeLen0 = presetMode == "Institutional (Strict)" ? math.max(regimeLenInput, 150) : presetMode == "Aggressive" ? math.max(regimeLenInput, 60) : regimeLenInput
int regimeLen = tradingStyle == "Manual" ? regimeLen0 : tradingStyle == "Scalp" ? math.min(regimeLen0, 80) : tradingStyle == "Swing" ? math.max(regimeLen0, 200) : regimeLen0
float lowVolMult = presetMode == "Institutional (Strict)" ? math.min(lowVolMultInput, 0.65) : presetMode == "Aggressive" ? math.max(lowVolMultInput, 0.85) : lowVolMultInput
string volRegimeMode = volRegimeModeInput
int atrPctLookback = presetMode == "Institutional (Strict)" ? math.max(atrPctLookbackInput, 300) : presetMode == "Aggressive" ? math.max(atrPctLookbackInput, 120) : atrPctLookbackInput
float lowVolPctThreshold = presetMode == "Institutional (Strict)" ? math.min(lowVolPctThresholdInput, 20.0) : presetMode == "Aggressive" ? math.max(lowVolPctThresholdInput, 35.0) : lowVolPctThresholdInput

int rangeLen0 = presetMode == "Institutional (Strict)" ? math.max(rangeLenInput, 40) : presetMode == "Aggressive" ? math.max(rangeLenInput, 20) : rangeLenInput
int rangeLen = tradingStyle == "Manual" ? rangeLen0 : tradingStyle == "Scalp" ? math.min(rangeLen0, 25) : tradingStyle == "Swing" ? math.max(rangeLen0, 60) : rangeLen0
float rangeAtrMult = presetMode == "Institutional (Strict)" ? math.min(rangeAtrMultInput, 3.0) : presetMode == "Aggressive" ? math.max(rangeAtrMultInput, 5.5) : rangeAtrMultInput
float minRangePct = presetMode == "Institutional (Strict)" ? math.min(minRangePctInput, 0.02) : presetMode == "Aggressive" ? math.max(minRangePctInput, 0.06) : minRangePctInput
int minAccBars0 = presetMode == "Institutional (Strict)" ? math.max(minAccBarsInput, 16) : presetMode == "Aggressive" ? math.max(minAccBarsInput, 8) : minAccBarsInput
int minAccBars = tradingStyle == "Manual" ? minAccBars0 : tradingStyle == "Scalp" ? math.min(minAccBars0, 10) : tradingStyle == "Swing" ? math.max(minAccBars0, 20) : minAccBars0

bool requireCloseBack = presetMode == "Institutional (Strict)" ? true : requireCloseBackInput
float sweepMinExcAtr = presetMode == "Institutional (Strict)" ? math.max(sweepMinExcAtrInput, 0.50) : presetMode == "Aggressive" ? math.max(sweepMinExcAtrInput, 0.15) : sweepMinExcAtrInput
int maxBarsToSweep0 = presetMode == "Institutional (Strict)" ? math.min(maxBarsToSweepInput, 90) : presetMode == "Aggressive" ? math.max(maxBarsToSweepInput, 240) : maxBarsToSweepInput
int maxBarsToSweep = tradingStyle == "Manual" ? maxBarsToSweep0 : tradingStyle == "Scalp" ? math.min(maxBarsToSweep0, 60) : tradingStyle == "Swing" ? math.max(maxBarsToSweep0, 400) : maxBarsToSweep0

float dispAtrMult = presetMode == "Institutional (Strict)" ? math.max(dispAtrMultInput, 1.6) : presetMode == "Aggressive" ? math.max(dispAtrMultInput, 1.0) : dispAtrMultInput
float minBodyPctTr = presetMode == "Institutional (Strict)" ? math.max(minBodyPctTrInput, 0.65) : presetMode == "Aggressive" ? math.max(minBodyPctTrInput, 0.45) : minBodyPctTrInput
int minBarsAfterSweep = presetMode == "Institutional (Strict)" ? math.max(minBarsAfterSweepInput, 2) : minBarsAfterSweepInput
int dispBars = presetMode == "Institutional (Strict)" ? math.max(dispBarsInput, 2) : presetMode == "Aggressive" ? 1 : dispBarsInput
bool requireFvg = presetMode == "Institutional (Strict)" ? true : requireFvgInput
float fvgMinAtr = presetMode == "Institutional (Strict)" ? math.max(fvgMinAtrInput, 0.20) : presetMode == "Aggressive" ? math.max(fvgMinAtrInput, 0.05) : fvgMinAtrInput
int maxBarsToDistribute0 = presetMode == "Institutional (Strict)" ? math.min(maxBarsToDistributeInput, 180) : presetMode == "Aggressive" ? math.max(maxBarsToDistributeInput, 360) : maxBarsToDistributeInput
int maxBarsToDistribute = tradingStyle == "Manual" ? maxBarsToDistribute0 : tradingStyle == "Scalp" ? math.min(maxBarsToDistribute0, 120) : tradingStyle == "Swing" ? math.max(maxBarsToDistribute0, 800) : maxBarsToDistribute0

bool showAccBox = showAccBoxInput
bool showRangeLines = showRangeLinesInput
bool showMarkers = showMarkersInput
bool showDistTint = showDistTintInput

bool alertRangeLocked = presetMode == "Institutional (Strict)" ? true : alertRangeLockedInput
bool alertSweep = presetMode == "Institutional (Strict)" ? true : alertSweepInput
bool alertDist = presetMode == "Institutional (Strict)" ? true : alertDistInput

bool shouldUpdate = signalTiming == "Realtime (intrabar)" or barstate.isconfirmed

float atr = ta.atr(atrLen)
float atrMa = ta.sma(atr, regimeLen)
float tr = ta.tr(true)

float atrPctRank = ta.percentrank(atr, atrPctLookback)

float rangeHighRoll = ta.highest(high, rangeLen)
float rangeLowRoll = ta.lowest(low, rangeLen)
float rangeWidthRoll = rangeHighRoll - rangeLowRoll
float rangeMinFloor = close * (minRangePct / 100.0)
float atrRef = na(atrMa) ? atr : atrMa
float rangeMax = math.max(atrRef * rangeAtrMult, rangeMinFloor)
bool lowVolAtrMa = not na(atrMa) and atr < atrMa * lowVolMult
bool lowVolPct = not na(atrPctRank) and atrPctRank <= lowVolPctThreshold
bool lowVol = volRegimeMode == "ATR %Rank" ? lowVolPct : lowVolAtrMa
bool tightRange = rangeWidthRoll <= rangeMax

bool accCond = lowVol and tightRange

bool allowManNow = true
bool allowDistNow = true

type AmdState
    int phase
    int accStartBar
    int lockBar
    int sweepBar
    int distBar
    float rangeHigh
    float rangeLow
    int sweepDir
    int accStreak
    box accBox
    line rangeHighLine
    line rangeLowLine

f_state_new() =>
    AmdState.new(0, na, na, na, na, na, na, 0, 0, na, na, na)

f_state_reset(AmdState s) =>
    if not na(s.accBox)
        box.delete(s.accBox)
    if not na(s.rangeHighLine)
        line.delete(s.rangeHighLine)
    if not na(s.rangeLowLine)
        line.delete(s.rangeLowLine)
    f_state_new()

var AmdState st = f_state_new()

// Events (one-bar pulses)
bool evAccStart = false
bool evRangeLocked = false
bool evSweepUp = false
bool evSweepDown = false
bool evDistUp = false
bool evDistDown = false

evAccStart := false
evRangeLocked := false
evSweepUp := false
evSweepDown := false
evDistUp := false
evDistDown := false

if shouldUpdate
    // Track consecutive bars meeting accumulation regime.
    st.accStreak := accCond ? st.accStreak + 1 : 0

    // Reset if we somehow lose required series early on.
    if na(atr) or na(rangeHighRoll) or na(rangeLowRoll)
        st := f_state_reset(st)
    else
        // Start accumulation once regime holds long enough.
        if st.phase == 0 and st.accStreak >= minAccBars
            st.phase := 1
            evAccStart := true
            st.accStartBar := bar_index - minAccBars + 1
            st.rangeHigh := ta.highest(high, minAccBars)
            st.rangeLow := ta.lowest(low, minAccBars)
            st.lockBar := na
            st.sweepBar := na
            st.distBar := na
            st.sweepDir := 0
            if not na(st.accBox)
                box.delete(st.accBox)
            st.accBox := na
            if showAccBox
                st.accBox := box.new(st.accStartBar, st.rangeHigh, bar_index, st.rangeLow, xloc=xloc.bar_index, bgcolor=color.new(color.gray, 90), border_color=color.new(color.gray, 40), border_width=1)

        // While accumulating, keep expanding the range.
        if st.phase == 1
            st.rangeHigh := math.max(st.rangeHigh, high)
            st.rangeLow := math.min(st.rangeLow, low)
            if showAccBox and not na(st.accBox)
                box.set_lefttop(st.accBox, st.accStartBar, st.rangeHigh)
                box.set_rightbottom(st.accBox, bar_index, st.rangeLow)

            // Lock the range when the low-vol regime breaks.
            if not accCond
                st.phase := 2
                st.lockBar := bar_index
                evRangeLocked := true

                if showRangeLines
                    if not na(st.rangeHighLine)
                        line.delete(st.rangeHighLine)
                    if not na(st.rangeLowLine)
                        line.delete(st.rangeLowLine)
                    // Draw the locked range across the accumulation window.
                    // Avoid extending to the last bar so drawings behave predictably when panning/zooming.
                    st.rangeHighLine := line.new(x1=st.accStartBar, y1=st.rangeHigh, x2=st.lockBar, y2=st.rangeHigh, xloc=xloc.bar_index, extend=extend.none, color=color.new(color.gray, 30), width=1)
                    st.rangeLowLine := line.new(x1=st.accStartBar, y1=st.rangeLow, x2=st.lockBar, y2=st.rangeLow, xloc=xloc.bar_index, extend=extend.none, color=color.new(color.gray, 30), width=1)

        // Waiting for sweep.
        if st.phase == 2
            bool timeOk = not na(st.lockBar) and bar_index - st.lockBar <= maxBarsToSweep
            if not timeOk
                st := f_state_reset(st)
            else if allowManNow
                bool sweptUp = high > st.rangeHigh
                bool sweptDown = low < st.rangeLow
                bool excUpOk = sweepMinExcAtr <= 0 ? true : (high - st.rangeHigh) >= sweepMinExcAtr * atrRef
                bool excDownOk = sweepMinExcAtr <= 0 ? true : (st.rangeLow - low) >= sweepMinExcAtr * atrRef
                bool closeBackUp = not requireCloseBack or close < st.rangeHigh
                bool closeBackDown = not requireCloseBack or close > st.rangeLow
                bool manUp = sweptUp and excUpOk and closeBackUp
                bool manDown = sweptDown and excDownOk and closeBackDown

                if manUp or manDown
                    st.phase := 3
                    st.sweepBar := bar_index
                    st.sweepDir := manUp ? 1 : -1
                    evSweepUp := manUp
                    evSweepDown := manDown

        // Waiting for distribution confirmation.
        if st.phase == 3
            bool timeOk = not na(st.sweepBar) and bar_index - st.sweepBar <= maxBarsToDistribute
            if not timeOk
                st := f_state_reset(st)
            else if allowDistNow
                bool afterSweepOk = not na(st.sweepBar) and (bar_index - st.sweepBar) >= minBarsAfterSweep
                int expectedDir = -st.sweepDir
                float body = math.abs(close - open)

                bool dirOk = expectedDir == 1 ? close > open : close < open
                bool dispBar = body >= dispAtrMult * atr and (tr > 0 ? (body / tr) : 0) >= minBodyPctTr and dirOk
                bool dispSeqOk = dispBars == 1 ? dispBar : dispBars == 2 ? (dispBar and dispBar[1]) : (dispBar and dispBar[1] and dispBar[2])

                bool bullFvgNow = not na(high[2]) and low > high[2] and (low - high[2]) >= fvgMinAtr * atr
                bool bearFvgNow = not na(low[2]) and high < low[2] and (low[2] - high) >= fvgMinAtr * atr
                bool bullFvgSeq = dispBars == 1 ? bullFvgNow : dispBars == 2 ? (bullFvgNow or bullFvgNow[1]) : (bullFvgNow or bullFvgNow[1] or bullFvgNow[2])
                bool bearFvgSeq = dispBars == 1 ? bearFvgNow : dispBars == 2 ? (bearFvgNow or bearFvgNow[1]) : (bearFvgNow or bearFvgNow[1] or bearFvgNow[2])
                bool fvgOk = not requireFvg or (expectedDir == 1 ? bullFvgSeq : bearFvgSeq)

                if afterSweepOk and dispSeqOk and fvgOk
                    st.phase := 4
                    st.distBar := bar_index
                    evDistUp := expectedDir == 1
                    evDistDown := expectedDir == -1

        // Distribution phase: ends when a new accumulation regime starts.
        if st.phase == 4 and st.accStreak >= minAccBars
            st := f_state_reset(st)

    // No continuous line updates: keep drawings anchored to their creation bars.

// === Visuals ===
bool inDistState = st.phase == 4
bgcolor(showDistTint and inDistState ? color.new(st.sweepDir == -1 ? #00ff88 : #ff3366, 92) : na)

// Markers: triangles + letter (clean overlay, candle-anchored)
plotshape(showMarkers and evAccStart, title="Accumulation Start", style=shape.triangleup, location=location.belowbar, size=size.tiny,
     color=color.new(color.gray, 0), text="A", textcolor=markerTextCol)
plotshape(showMarkers and evSweepUp, title="Manipulation (Up Sweep)", style=shape.triangledown, location=location.abovebar, size=size.tiny,
     color=color.new(#ff3366, 0), text="M", textcolor=markerTextCol)
plotshape(showMarkers and evSweepDown, title="Manipulation (Down Sweep)", style=shape.triangleup, location=location.belowbar, size=size.tiny,
     color=color.new(#00ff88, 0), text="M", textcolor=markerTextCol)
plotshape(showMarkers and evDistUp, title="Distribution (Up)", style=shape.triangleup, location=location.belowbar, size=size.tiny,
     color=color.new(#00ff88, 0), text="D", textcolor=markerTextCol)
plotshape(showMarkers and evDistDown, title="Distribution (Down)", style=shape.triangledown, location=location.abovebar, size=size.tiny,
     color=color.new(#ff3366, 0), text="D", textcolor=markerTextCol)

// === Alerts ===
alertcondition(alertRangeLocked and evRangeLocked, title="AMD: Range Locked", message="AMD range locked on {{ticker}} {{interval}}")
alertcondition(alertSweep and evSweepUp, title="AMD: Manipulation Sweep Up", message="AMD manipulation sweep UP on {{ticker}} {{interval}}")
alertcondition(alertSweep and evSweepDown, title="AMD: Manipulation Sweep Down", message="AMD manipulation sweep DOWN on {{ticker}} {{interval}}")
alertcondition(alertDist and evDistUp, title="AMD: Distribution Started Up", message="AMD distribution started UP on {{ticker}} {{interval}}")
alertcondition(alertDist and evDistDown, title="AMD: Distribution Started Down", message="AMD distribution started DOWN on {{ticker}} {{interval}}")
