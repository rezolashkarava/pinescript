//@version=6
indicator("Pagani Breakout Quality Engine Ultra [BQE]", overlay=true, max_labels_count=200, max_lines_count=100, max_boxes_count=50)

// ============================================================================
// BREAKOUT QUALITY ENGINE ULTRA V2.2 - SIMPLIFIED & INTUITIVE
// Complementary indicator to ICT Order Block Pro [Paganie]
//
// V2.2 Changes:
// - SIMPLIFIED: Reduced settings from 40+ to 15 essential inputs
// - REMOVED: Confusing ATR multiplier inputs (now auto-optimized by preset)
// - REMOVED: Individual session hour inputs (uses standard ICT killzones)
// - REMOVED: Touch validation settings (always fast mode for performance)
// - REMOVED: Compression detection (rarely used, added confusion)
// - REMOVED: Psychological levels (low accuracy, cluttered interface)
// - IMPROVED: Clear tooltips explaining each setting
// - IMPROVED: Grouped settings into logical categories
// - KEPT: Trading Style presets auto-tune all internal parameters
//
// V2.1 Changes:
// - FIXED: OTE zone calculation (correct ICT 62-79% retracement)
// - FIXED: Session wraparound for overnight sessions
// - FIXED: Retest validation logic
// - OPTIMIZED: Touch counting, level arrays, consolidated HTF requests
// ============================================================================

// === PERFORMANCE CONSTANTS ===
int MAX_TOUCH_LOOKBACK = 100  // Reduced from 200 for performance
int CACHE_REFRESH_BARS = 5   // Refresh touch cache every N bars

// === TIMEFRAME DETECTION ===
float tf_in_minutes = timeframe.in_seconds() / 60.0
bool is_scalping = tf_in_minutes <= 15
bool is_intraday = tf_in_minutes > 15 and tf_in_minutes <= 60
bool is_swing = tf_in_minutes > 60 and tf_in_minutes <= 240
bool is_position = tf_in_minutes > 240

// === HELPER FUNCTIONS ===
round2(float x) => na(x) ? na : math.round(x * 100) / 100

strengthSymbol(string s) =>
    s == "Elite" ? "â˜…" : s == "Strong" ? "â—†" : s == "Mid" ? "â—‡" : "â—‹"

// Session time helper (handles overnight wraparound)
inSession(int startHour, int endHour, int currentHour) =>
    if startHour <= endHour
        currentHour >= startHour and currentHour < endHour
    else  // Overnight session (e.g., 22:00 - 02:00)
        currentHour >= startHour or currentHour < endHour

// Safe division
safeDivide(float num, float denom) =>
    na(num) or na(denom) or denom == 0 ? na : num / denom

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// INPUTS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

// === MAIN SETTINGS ===
string GRP_MAIN = "âš™ï¸ Main Settings"
presetMode = input.string("Balanced", "Trading Style", options=["Institutional (Strict)", "Balanced", "Aggressive"], group=GRP_MAIN,
     tooltip="INSTITUTIONAL: Fewer but higher quality signals. Requires retest confirmation.\nBALANCED: Good mix of quality and frequency.\nAGGRESSIVE: More signals, faster entries.")
signalTiming = input.string("Confirmed (bar close)", "Signal Timing", options=["Confirmed (bar close)", "Realtime (intrabar)"], group=GRP_MAIN,
     tooltip="CONFIRMED: Signals trigger on bar close (recommended).\nREALTIME: Signals can trigger during bar formation.")
entryModeInput = input.string("Both", "Entry Type", options=["Acceptance", "Retest", "Both"], group=GRP_MAIN,
     tooltip="ACCEPTANCE: Signal on breakout confirmation.\nRETEST: Signal when price retests broken level.\nBOTH: Show both signal types.")

// === KEY LEVELS ===
string GRP_LEVELS = "ğŸ“Š Key Levels"
usePdhPdl = input.bool(true, "Previous Day High/Low", group=GRP_LEVELS, tooltip="Track yesterday's high and low as key levels.")
usePwhPwl = input.bool(true, "Previous Week High/Low", group=GRP_LEVELS, tooltip="Track last week's high and low as key levels.")
usePmhPml = input.bool(false, "Previous Month High/Low", group=GRP_LEVELS, tooltip="Track last month's high and low as key levels.")
useOpeningRange = input.bool(false, "Opening Range (NY)", group=GRP_LEVELS, tooltip="Track NY session opening range (9:30-10:00 ET).")
useH1Pivots = input.bool(false, "Hourly Pivots", group=GRP_LEVELS, tooltip="Track swing highs/lows from 1-hour timeframe.")
showVwap = input.bool(false, "Daily VWAP", group=GRP_LEVELS, tooltip="Display daily Volume Weighted Average Price.")

// === FILTERS ===
string GRP_FILTERS = "ğŸ¯ Filters"
useSessionFilter = input.bool(true, "Killzone Filter", group=GRP_FILTERS,
     tooltip="Boost signals during London (2-5 UTC), NY (8-11 UTC), and Asia (23-2 UTC) sessions.")
useZoneFilter = input.bool(true, "Premium/Discount Filter", group=GRP_FILTERS,
     tooltip="Favor longs in discount zones (below equilibrium) and shorts in premium zones (above equilibrium).")
useHtfBias = input.bool(true, "HTF Trend Filter", group=GRP_FILTERS,
     tooltip="Align signals with higher timeframe trend direction.")
htfTimeframe = input.timeframe("240", "HTF Timeframe", group=GRP_FILTERS, tooltip="Higher timeframe for trend bias (default: 4H).")
useRegimeFilter = input.bool(true, "Active Market Filter", group=GRP_FILTERS,
     tooltip="Only signal when market shows sufficient volatility and volume activity.")

// === VISUALS ===
string GRP_VIS = "ğŸ¨ Visuals"
visualMode = input.string("Minimal", "Visual Mode", options=["Minimal", "Standard", "Full"], group=GRP_VIS,
     tooltip="MINIMAL: Only active levels.\nSTANDARD: Show key level lines.\nFULL: All levels, zones, and OTE.")
showLabels = input.bool(true, "Show Signal Labels", group=GRP_VIS)
showScoreInLabel = input.bool(true, "Show Quality Score", group=GRP_VIS, tooltip="Display numeric quality score (0-100) in signal labels.")
showDashboard = input.bool(true, "Show Dashboard", group=GRP_VIS)
dashboardLocation = input.string("Top Right", "Dashboard Position", options=["Top Right", "Top Left", "Bottom Right", "Bottom Left"], group=GRP_VIS)
dashboardSize = input.string("Small", "Dashboard Size", options=["Tiny", "Small", "Normal"], group=GRP_VIS, tooltip="Size of dashboard text and cells.")
dashboardTransparency = input.int(90, "Dashboard Transparency", minval=0, maxval=90, step=5, group=GRP_VIS, tooltip="Background transparency (0=solid, 90=nearly invisible).")
showZoneLines = input.bool(false, "Show Zone Lines", group=GRP_VIS, tooltip="Draw equilibrium and zone boundary lines (requires Full visual mode).")
showOteZone = input.bool(false, "Show OTE Zone", group=GRP_VIS, tooltip="Highlight the Optimal Trade Entry zone (62-79% retracement).")

// === ALERTS ===
string GRP_ALERTS = "ğŸ”” Alerts"
alertSetup = input.bool(true, "Setup Armed", group=GRP_ALERTS, tooltip="Alert when price approaches a key level.")
alertAccepted = input.bool(true, "Breakout Accepted", group=GRP_ALERTS, tooltip="Alert when breakout is confirmed.")
alertRetest = input.bool(true, "Retest Held", group=GRP_ALERTS, tooltip="Alert when price successfully retests broken level.")
alertFailed = input.bool(true, "Failed/Sweep", group=GRP_ALERTS, tooltip="Alert when breakout fails or level is swept.")

// === ADVANCED SETTINGS (Exposed) ===
string GRP_ADV = "ğŸ› ï¸ Advanced Tuning"
touchLookback = input.int(100, "Touch Lookback", minval=10, group=GRP_ADV, tooltip="Bars to look back for level touches.")
touchTolAtr = input.float(0.15, "Touch Tolerance (ATR)", step=0.05, group=GRP_ADV, tooltip="Vertical distance to count as a 'touch'.")
minTouchesRequired = input.int(2, "Min Touches Required", minval=1, group=GRP_ADV, tooltip="Minimum touches to validate a Psych level.")
fastMode = input.bool(true, "Fast Estimation Mode", group=GRP_ADV, tooltip="Uses optimized logic for touches. Disable for pixel-perfect precision (slower).")

// Session Times (New York Time)
string GRP_TIME = "ğŸ•’ Session Times (NY)"
londonStart = input.int(2, "London Start (NY)", minval=0, maxval=23, group=GRP_TIME)
londonEnd = input.int(5, "London End (NY)", minval=0, maxval=23, group=GRP_TIME)
nyStart = input.int(7, "NY Start (NY)", minval=0, maxval=23, group=GRP_TIME)
nyEnd = input.int(10, "NY End (NY)", minval=0, maxval=23, group=GRP_TIME)
asiaStart = input.int(20, "Asia Start (NY)", minval=0, maxval=23, group=GRP_TIME)
asiaEnd = input.int(0, "Asia End (NY)", minval=0, maxval=23, group=GRP_TIME)
useMacroTimes = input.bool(true, "Boost Macro Times", group=GRP_TIME, tooltip="Boost score at :00, :30, :50 minute marks.")

// Internal thresholds (still optimized defaults, but exposed if needed)
nearLevelAtr = 1.5
closeBufferAtr = 0.05
minTrAtr = 1.25
minCloseLoc = 0.75

// Confirmation Settings
acceptBarsRequired = 2
acceptMaxBars = input.int(5, "Max Bars to Accept", group=GRP_ADV)
retestTolAtr = input.float(0.3, "Retest Tolerance (ATR)", group=GRP_ADV)
retestMaxBars = input.int(12, "Max Bars for Retest", group=GRP_ADV)
retestMaxWickAtr = input.float(0.5, "Max Wick Sweep (ATR)", group=GRP_ADV)

// Failure detection
sweepMinExcAtr = 0.25
failWindowBars = 3

// Regime filter
activeTrPct = 40.0
activeDvolPct = 40.0
activeLogicMode = "OR"

// HTF Bias & Zone Settings
htfEmaLen = input.int(21, "HTF EMA Length", group=GRP_ADV, tooltip="Length of EMA for Trend Filter.")
zoneLookback = input.int(50, "Zone Lookback", minval=10, group=GRP_ADV, tooltip="Lookback for Swing High/Low detection.")


// Legacy/Unused (kept for variable compatibility or manual override)
useCompression = false
bbwLen = 20
bbwStdev = 2.0
bbwLowPct = 25.0
atrLowPct = 35.0
touchSeparationBars = 3
biasMode = "Filter"
settingsMode = "Auto"
usePsychLevels = false // Can be re-enabled if desired
psychLevelInterval = 100.0
pivotLeftBars = 3

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// COLORS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
color C_BULL = #00ff88
color C_BEAR = #ff3366
color C_FAIL = #ff6600
color C_NEUTRAL = #888888
color C_LEVEL = color.new(#555555, 50)
color C_OTE = color.new(#ffd700, 70)
color C_VWAP = color.new(#2196f3, 50)
color C_DASH_BG = color.new(#000000, 15)

// Derived visual settings
bool showLevels = visualMode == "Standard" or visualMode == "Full"
bool showAllLevels = visualMode == "Full"

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// PRESET CONFIGURATION
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
bool isStrict = presetMode == "Institutional (Strict)"
bool isAggressive = presetMode == "Aggressive"

// Trading style presets (auto-optimized)
// Note: These override the "Advanced" tuning inputs ONLY for specific logic. 
// We will use the Advanced Inputs for the core lookbacks to give user control.
int cooldownBars = isStrict ? 30 : isAggressive ? 10 : 20
string entryMode = isStrict ? "Retest" : isAggressive ? "Acceptance" : entryModeInput
float effCloseBuffer = isStrict ? 0.08 : isAggressive ? 0.03 : 0.05
float effMinTr = isStrict ? 1.5 : isAggressive ? 1.0 : 1.25
float effMinCloseLoc = isStrict ? 0.80 : isAggressive ? 0.65 : 0.75
int effAcceptBars = isStrict ? 2 : isAggressive ? 1 : 2
int effAcceptMax = isStrict ? 4 : isAggressive ? 8 : 5
float effSweepExc = isStrict ? 0.35 : isAggressive ? 0.15 : 0.25
int effFailWindow = isStrict ? 2 : isAggressive ? 5 : 3

// Use user inputs for lookbacks (User Control > Auto-magic)
int effTouchLookback = touchLookback
int effZoneLookback = zoneLookback

bool wantAcceptSignal = entryMode == "Acceptance" or entryMode == "Both"
bool wantRetestSignal = entryMode == "Retest" or entryMode == "Both"
bool shouldUpdate = signalTiming == "Realtime (intrabar)" or barstate.isconfirmed

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// CORE CALCULATIONS (Cached)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
float atr = ta.atr(14)
float tr = ta.tr(true)
float rng = high - low
float closeLoc = rng > 0 ? (close - low) / rng : 0.5

// Validate ATR
bool atrValid = not na(atr) and atr > 0

// Bollinger Band Width (only compute if needed)
var float bbw = na
var float bbwPctRank = na
var float atrPctRank = na

if useCompression
    float bbBasis = ta.sma(close, bbwLen)
    float bbDev = bbwStdev * ta.stdev(close, bbwLen)
    bbw := bbBasis != 0 ? (2 * bbDev) / bbBasis : na
    bbwPctRank := ta.percentrank(bbw, 100)
    atrPctRank := ta.percentrank(atr, 100)

bool inSqueeze = useCompression and not na(bbwPctRank) and not na(atrPctRank) and bbwPctRank <= bbwLowPct and atrPctRank <= atrLowPct

// Active market regime (optimized lookback)
float trAtrRatio = atrValid ? tr / atr : na
float trPctRank = ta.percentrank(trAtrRatio, 100)
float dvol = volume * close
float dvolPctRank = ta.percentrank(dvol, 100)

bool trOk = not na(trPctRank) and trPctRank >= activeTrPct
bool volOk = not na(dvolPctRank) and dvolPctRank >= activeDvolPct
bool activeMarket = not useRegimeFilter or (activeLogicMode == "AND" ? (trOk and volOk) : (trOk or volOk))

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// SESSION DETECTION (New York Time)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
int hourNy = hour(time, "America/New_York")
int minuteNy = minute(time, "America/New_York")

bool inLondonKZ = inSession(londonStart, londonEnd, hourNy)
bool inNyKZ = inSession(nyStart, nyEnd, hourNy)
bool inAsiaKZ = inSession(asiaStart, asiaEnd, hourNy)
bool inOverlapKZ = inLondonKZ and inNyKZ
bool inAnyKillzone = inLondonKZ or inNyKZ or inAsiaKZ

bool isMacroTime = useMacroTimes and (minuteNy == 0 or minuteNy == 30 or minuteNy == 50)

// Session score
int sessionScore = 0
if useSessionFilter
    sessionScore := inOverlapKZ ? 8 : inNyKZ ? 6 : inLondonKZ ? 5 : inAsiaKZ ? 3 : 1
    if isMacroTime
        sessionScore := math.min(sessionScore + 2, 10)

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// KEY LEVELS (Midnight NY Alignment - True Day)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
int yUtc = year(time, "America/New_York")
int mUtc = month(time, "America/New_York")
int dUtc = dayofmonth(time, "America/New_York")
int wUtc = weekofyear(time, "America/New_York")

int dayId = yUtc * 10000 + mUtc * 100 + dUtc
int weekId = yUtc * 100 + wUtc
int monthId = yUtc * 100 + mUtc

var int lastDayId = na
var int lastWeekId = na
var int lastMonthId = na

// Level storage
var float dayHigh = na, var float dayLow = na
var float pdh = na, var float pdl = na
var float weekHigh = na, var float weekLow = na
var float pwh = na, var float pwl = na
var float monthHigh = na, var float monthLow = na
var float pmh = na, var float pml = na

bool newDay = not na(lastDayId) and dayId != lastDayId
bool newWeek = not na(lastWeekId) and weekId != lastWeekId
bool newMonth = not na(lastMonthId) and monthId != lastMonthId

// Update daily
if na(lastDayId)
    lastDayId := dayId
    dayHigh := high
    dayLow := low
else if newDay
    pdh := dayHigh
    pdl := dayLow
    dayHigh := high
    dayLow := low
    lastDayId := dayId
else
    dayHigh := math.max(dayHigh, high)
    dayLow := math.min(dayLow, low)

// Update weekly
if na(lastWeekId)
    lastWeekId := weekId
    weekHigh := high
    weekLow := low
else if newWeek
    pwh := weekHigh
    pwl := weekLow
    weekHigh := high
    weekLow := low
    lastWeekId := weekId
else
    weekHigh := math.max(weekHigh, high)
    weekLow := math.min(weekLow, low)

// Update monthly
if na(lastMonthId)
    lastMonthId := monthId
    monthHigh := high
    monthLow := low
else if newMonth
    pmh := monthHigh
    pml := monthLow
    monthHigh := high
    monthLow := low
    lastMonthId := monthId
else
    monthHigh := math.max(monthHigh, high)
    monthLow := math.min(monthLow, low)

// VWAP
var float vwapPv = na, var float vwapV = na
if showVwap
    if na(vwapPv) or newDay
        vwapPv := hlc3 * volume
        vwapV := volume
    else
        vwapPv += hlc3 * volume
        vwapV += volume
float vwapDaily = showVwap and not na(vwapV) and vwapV > 0 ? vwapPv / vwapV : na

// Opening Range (09:30 - 10:00 NY)
var float orHigh = na, var float orLow = na, var bool orComplete = false
if useOpeningRange
    if newDay
        orHigh := na
        orLow := na
        orComplete := false
    
    // 09:30 to 10:00 NY Time
    bool inOrWindow = (hourNy == 9 and minuteNy >= 30)
    
    if inOrWindow and not orComplete
        orHigh := na(orHigh) ? high : math.max(orHigh, high)
        orLow := na(orLow) ? low : math.min(orLow, low)
    else if not inOrWindow and not na(orHigh) and (hourNy > 9 or (hourNy == 9 and minuteNy >= 30))
        orComplete := true

// H1 Pivots (single request)
float ph1h = na, float pl1h = na
if useH1Pivots
    ph1h := request.security(syminfo.tickerid, "60", ta.pivothigh(high, pivotLeftBars, pivotLeftBars), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
    pl1h := request.security(syminfo.tickerid, "60", ta.pivotlow(low, pivotLeftBars, pivotLeftBars), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

var float lastPh1h = na, var float lastPl1h = na
if not na(ph1h)
    lastPh1h := ph1h
if not na(pl1h)
    lastPl1h := pl1h

// Psychological levels
float nearestPsychAbove = usePsychLevels ? math.ceil(close / psychLevelInterval) * psychLevelInterval : na
float nearestPsychBelow = usePsychLevels ? math.floor(close / psychLevelInterval) * psychLevelInterval : na

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// PREMIUM/DISCOUNT ZONES (FIXED OTE CALCULATION)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
float swingHigh = ta.highest(high, effZoneLookback)
float swingLow = ta.lowest(low, effZoneLookback)
float swingRange = swingHigh - swingLow

float equilibrium = swingLow + swingRange * 0.5

// CORRECT ICT OTE CALCULATION:
// OTE is 62-79% Fibonacci RETRACEMENT
// For LONGS: We want price in DISCOUNT (retraced 62-79% from swing HIGH)
//   = swingHigh - (swingRange * 0.62) to swingHigh - (swingRange * 0.79)
//   = 38% to 21% of range from bottom
// For SHORTS: We want price in PREMIUM (retraced 62-79% from swing LOW)
//   = swingLow + (swingRange * 0.62) to swingLow + (swingRange * 0.79)
//   = 62% to 79% of range from bottom

float oteLongTop = swingLow + swingRange * 0.38    // 38% from low (62% retracement from high)
float oteLongBot = swingLow + swingRange * 0.21    // 21% from low (79% retracement from high)
float oteShortBot = swingLow + swingRange * 0.62   // 62% from low (62% retracement from low)
float oteShortTop = swingLow + swingRange * 0.79   // 79% from low (79% retracement from low)

bool inDiscount = close < equilibrium
bool inPremium = close > equilibrium
bool inOteLong = close >= oteLongBot and close <= oteLongTop
bool inOteShort = close >= oteShortBot and close <= oteShortTop

// Zone scoring
int zoneScoreLong = 0
int zoneScoreShort = 0
if useZoneFilter and swingRange > 0
    float pricePos = (close - swingLow) / swingRange
    // Long scoring (want discount)
    zoneScoreLong := pricePos < 0.3 ? 12 : pricePos < 0.5 ? 8 : pricePos < 0.6 ? 4 : 0
    // Short scoring (want premium)
    zoneScoreShort := pricePos > 0.7 ? 12 : pricePos > 0.5 ? 8 : pricePos > 0.4 ? 4 : 0
    // OTE bonus
    if inOteLong
        zoneScoreLong := math.min(zoneScoreLong + 3, 12)
    if inOteShort
        zoneScoreShort := math.min(zoneScoreShort + 3, 12)

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// HTF BIAS (Single consolidated request)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
[htfClose, htfEma] = request.security(syminfo.tickerid, htfTimeframe, [close, ta.ema(close, htfEmaLen)], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

bool htfBullish = useHtfBias and not na(htfEma) and htfClose > htfEma
bool htfBearish = useHtfBias and not na(htfEma) and htfClose < htfEma

int htfScoreLong = 0
int htfScoreShort = 0
if useHtfBias and biasMode != "Off"
    if htfBullish
        htfScoreLong := 10
        htfScoreShort := biasMode == "Filter" ? 0 : 3
    else if htfBearish
        htfScoreShort := 10
        htfScoreLong := biasMode == "Filter" ? 0 : 3
    else
        htfScoreLong := 5
        htfScoreShort := 5

bool longBiasOk = not useHtfBias or biasMode != "Filter" or htfBullish or (not htfBullish and not htfBearish)
bool shortBiasOk = not useHtfBias or biasMode != "Filter" or htfBearish or (not htfBullish and not htfBearish)

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// LEVEL SELECTION (Optimized - no arrays, direct selection)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

// Optimized touch counting (only called when needed)
countTouches(float lvl, bool checkHigh, int lookback) =>
    int touches = 0
    int lastTouchBar = -9999
    float tol = atrValid ? touchTolAtr * atr : na
    if not na(lvl) and not na(tol) and not fastMode
        int maxI = math.min(lookback - 1, bar_index)
        for i = 0 to maxI
            float p = checkHigh ? high[i] : low[i]
            if math.abs(p - lvl) <= tol and (i - lastTouchBar) >= touchSeparationBars
                touches += 1
                lastTouchBar := i
                if touches >= 5  // Early termination
                    break
    touches

// Find best level above (for longs)
var float bestLongLvl = na
var string bestLongName = ""
var int bestLongTier = 0

// Find best level below (for shorts)
var float bestShortLvl = na
var string bestShortName = ""
var int bestShortTier = 0

// Rebuild level selection (efficient direct comparison)
bestLongLvl := na
bestLongName := ""
bestLongTier := 0
bestShortLvl := na
bestShortName := ""
bestShortTier := 0

float bestLongDist = na
float bestShortDist = na

// Check levels above (for longs) - ordered by tier priority
// Tier 5: PMH
if usePmhPml and not na(pmh) and pmh > close
    float d = pmh - close
    if na(bestLongDist) or d < bestLongDist
        bestLongDist := d
        bestLongLvl := pmh
        bestLongName := "PMH"
        bestLongTier := 5

// Tier 4: PWH
if usePwhPwl and not na(pwh) and pwh > close
    float d = pwh - close
    if na(bestLongDist) or d < bestLongDist
        bestLongDist := d
        bestLongLvl := pwh
        bestLongName := "PWH"
        bestLongTier := 4

// Tier 3: PDH
if usePdhPdl and not na(pdh) and pdh > close
    float d = pdh - close
    if na(bestLongDist) or d < bestLongDist
        bestLongDist := d
        bestLongLvl := pdh
        bestLongName := "PDH"
        bestLongTier := 3

// Tier 2: OR High
if useOpeningRange and orComplete and not na(orHigh) and orHigh > close
    float d = orHigh - close
    if na(bestLongDist) or d < bestLongDist
        bestLongDist := d
        bestLongLvl := orHigh
        bestLongName := "OR-H"
        bestLongTier := 2

// Tier 2: H1 Pivot
if useH1Pivots and not na(lastPh1h) and lastPh1h > close
    float d = lastPh1h - close
    if na(bestLongDist) or d < bestLongDist
        bestLongDist := d
        bestLongLvl := lastPh1h
        bestLongName := "H1-P"
        bestLongTier := 2

// Tier 1: Psych
if usePsychLevels and not na(nearestPsychAbove) and nearestPsychAbove > close
    float d = nearestPsychAbove - close
    if (na(bestLongDist) or d < bestLongDist) and (fastMode or countTouches(nearestPsychAbove, true, effTouchLookback) >= minTouchesRequired)
        bestLongDist := d
        bestLongLvl := nearestPsychAbove
        bestLongName := "PSYCH"
        bestLongTier := 1

// Check levels below (for shorts) - ordered by tier priority
// Tier 5: PML
if usePmhPml and not na(pml) and pml < close
    float d = close - pml
    if na(bestShortDist) or d < bestShortDist
        bestShortDist := d
        bestShortLvl := pml
        bestShortName := "PML"
        bestShortTier := 5

// Tier 4: PWL
if usePwhPwl and not na(pwl) and pwl < close
    float d = close - pwl
    if na(bestShortDist) or d < bestShortDist
        bestShortDist := d
        bestShortLvl := pwl
        bestShortName := "PWL"
        bestShortTier := 4

// Tier 3: PDL
if usePdhPdl and not na(pdl) and pdl < close
    float d = close - pdl
    if na(bestShortDist) or d < bestShortDist
        bestShortDist := d
        bestShortLvl := pdl
        bestShortName := "PDL"
        bestShortTier := 3

// Tier 2: OR Low
if useOpeningRange and orComplete and not na(orLow) and orLow < close
    float d = close - orLow
    if na(bestShortDist) or d < bestShortDist
        bestShortDist := d
        bestShortLvl := orLow
        bestShortName := "OR-L"
        bestShortTier := 2

// Tier 2: H1 Pivot
if useH1Pivots and not na(lastPl1h) and lastPl1h < close
    float d = close - lastPl1h
    if na(bestShortDist) or d < bestShortDist
        bestShortDist := d
        bestShortLvl := lastPl1h
        bestShortName := "H1-P"
        bestShortTier := 2

// Tier 1: Psych
if usePsychLevels and not na(nearestPsychBelow) and nearestPsychBelow < close
    float d = close - nearestPsychBelow
    if (na(bestShortDist) or d < bestShortDist) and (fastMode or countTouches(nearestPsychBelow, false, effTouchLookback) >= minTouchesRequired)
        bestShortDist := d
        bestShortLvl := nearestPsychBelow
        bestShortName := "PSYCH"
        bestShortTier := 1

// Check if near level
float nearDist = atrValid ? nearLevelAtr * atr : na
bool nearLong = not na(bestLongLvl) and not na(nearDist) and (bestLongLvl - close) <= nearDist
bool nearShort = not na(bestShortLvl) and not na(nearDist) and (close - bestShortLvl) <= nearDist

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// SCORING SYSTEM
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
scoreLevelComponent(int tier) =>
    tier >= 5 ? 10 : tier >= 4 ? 8 : tier >= 3 ? 6 : tier >= 2 ? 4 : 2

scoreCompressionComponent() =>
    not useCompression ? 8 : inSqueeze ? 15 : (not na(bbwPctRank) and bbwPctRank <= bbwLowPct * 2) ? 7 : 0

scoreDisplacementComponent(bool isLong) =>
    int trScore = atrValid and tr >= effMinTr * atr ? 10 : (atrValid and tr >= effMinTr * 0.85 * atr) ? 5 : 0
    float loc = isLong ? closeLoc : (1.0 - closeLoc)
    int locScore = loc >= effMinCloseLoc ? 5 : loc >= (effMinCloseLoc - 0.10) ? 2 : 0
    math.min(trScore + locScore, 15)

scoreContextComponent(bool isLong) =>
    int zScore = isLong ? zoneScoreLong : zoneScoreShort
    int hScore = isLong ? htfScoreLong : htfScoreShort
    math.min(zScore + hScore + sessionScore, 30)

scoreVolumeComponent() =>
    not na(dvolPctRank) ? (dvolPctRank >= 80 ? 10 : dvolPctRank >= 60 ? 7 : dvolPctRank >= 40 ? 4 : 0) : 0

calcTotalScore(bool isLong, int tier, bool accepted, bool retestHeld) =>
    int levelScore = scoreLevelComponent(tier)
    int compScore = scoreCompressionComponent()
    int dispScore = scoreDisplacementComponent(isLong)
    int contextScore = scoreContextComponent(isLong)
    int volScore = scoreVolumeComponent()
    int confirmBonus = retestHeld ? 15 : (accepted ? 10 : 0)
    math.min(levelScore + compScore + dispScore + contextScore + volScore + confirmBonus, 100)

scoreToStrength(int score) =>
    score >= 80 ? "Elite" : score >= 60 ? "Strong" : score >= 40 ? "Mid" : "Weak"

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// STATE MACHINE (Optimized)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// States: 0=idle, 1=armed, 2=attempt, 3=accepted, 4=retest_watch, 5=retest_held, 6=failed, 7=cooldown

var int longState = 0, var int shortState = 0
var int longStateBar = 0, var int shortStateBar = 0
var float longLvlRef = na, var float shortLvlRef = na
var string longLvlName = "", var string shortLvlName = ""
var int longLvlTier = 0, var int shortLvlTier = 0
var int longAcceptStreak = 0, var int shortAcceptStreak = 0
var int longCooldown = 0, var int shortCooldown = 0
var int longSweepBar = 0, var int shortSweepBar = 0

// Displacement conditions
bool dispOkLong = atrValid and tr >= effMinTr * atr and closeLoc >= effMinCloseLoc
bool dispOkShort = atrValid and tr >= effMinTr * atr and closeLoc <= (1.0 - effMinCloseLoc)

// Setup conditions
bool compressionOk = not useCompression or inSqueeze
bool setupLong = shouldUpdate and activeMarket and compressionOk and nearLong and longBiasOk
bool setupShort = shouldUpdate and activeMarket and compressionOk and nearShort and shortBiasOk

// Attempt conditions
attemptLong(float lvl) => shouldUpdate and activeMarket and atrValid and not na(lvl) and close > lvl + effCloseBuffer * atr and dispOkLong
attemptShort(float lvl) => shouldUpdate and activeMarket and atrValid and not na(lvl) and close < lvl - effCloseBuffer * atr and dispOkShort

// Event flags
bool evSetupLong = false, bool evSetupShort = false
bool evAcceptedLong = false, bool evAcceptedShort = false
bool evRetestLong = false, bool evRetestShort = false
bool evFailedLong = false, bool evFailedShort = false
bool evSweepLong = false, bool evSweepShort = false

// === LONG STATE MACHINE ===
if longCooldown > 0
    longCooldown -= 1
    if longCooldown == 0
        longState := 0

if longCooldown == 0
    if longState == 0  // IDLE
        if setupLong and not na(bestLongLvl)
            longState := 1
            longStateBar := bar_index
            longLvlRef := bestLongLvl
            longLvlName := bestLongName
            longLvlTier := bestLongTier
            longAcceptStreak := 0
            longSweepBar := 0
            evSetupLong := true

    else if longState == 1  // ARMED
        bool stale = (useCompression and not inSqueeze) or na(longLvlRef) or not atrValid or (longLvlRef - close) > (nearLevelAtr * atr * 2.0)
        if stale
            longState := 0
        else
            // Sweep detection
            if longSweepBar == 0 and high >= longLvlRef + effSweepExc * atr
                longSweepBar := bar_index
            bool sweepNow = longSweepBar > 0 and close < longLvlRef and (bar_index - longSweepBar) <= effFailWindow
            if sweepNow
                longState := 6
                evSweepLong := true
                longSweepBar := 0
            else if attemptLong(longLvlRef)
                longState := 2
                longStateBar := bar_index
                longAcceptStreak := 1
                longSweepBar := 0

    else if longState == 2  // ATTEMPT
        bool acceptClose = atrValid and close > longLvlRef + effCloseBuffer * atr
        longAcceptStreak := acceptClose ? longAcceptStreak + 1 : math.max(longAcceptStreak - 1, 0)
        bool timeout = (bar_index - longStateBar) >= effAcceptMax
        bool reclaimed = close < longLvlRef

        if longSweepBar == 0 and atrValid and high >= longLvlRef + effSweepExc * atr
            longSweepBar := bar_index
        bool sweepNow = reclaimed and longSweepBar > 0 and (bar_index - longSweepBar) <= effFailWindow

        if sweepNow
            longState := 6
            evSweepLong := true
        else if reclaimed
            longState := 6
            evFailedLong := true
        else if longAcceptStreak >= effAcceptBars
            longState := 3
            longStateBar := bar_index
            evAcceptedLong := true
        else if timeout
            longState := 6
            evFailedLong := true

    else if longState == 3  // ACCEPTED
        if wantRetestSignal
            longState := 4
            longStateBar := bar_index
        else
            longState := 7
            longCooldown := cooldownBars

    else if longState == 4  // RETEST WATCH (FIXED LOGIC)
        bool timeout = (bar_index - longStateBar) > retestMaxBars
        float tol = atrValid ? retestTolAtr * atr : 0
        float maxWick = atrValid ? retestMaxWickAtr * atr : 0

        bool touched = low <= longLvlRef + tol
        bool wickExceeded = low < longLvlRef - maxWick
        bool held = touched and not wickExceeded and close >= longLvlRef

        if wickExceeded  // Wick too deep = failed
            longState := 6
            evFailedLong := true
        else if held
            longState := 5
            evRetestLong := true
        else if timeout
            longState := 7
            longCooldown := cooldownBars

    else if longState == 5 or longState == 6  // RETEST HELD or FAILED
        longState := 7
        longCooldown := cooldownBars

// === SHORT STATE MACHINE ===
if shortCooldown > 0
    shortCooldown -= 1
    if shortCooldown == 0
        shortState := 0

if shortCooldown == 0
    if shortState == 0  // IDLE
        if setupShort and not na(bestShortLvl)
            shortState := 1
            shortStateBar := bar_index
            shortLvlRef := bestShortLvl
            shortLvlName := bestShortName
            shortLvlTier := bestShortTier
            shortAcceptStreak := 0
            shortSweepBar := 0
            evSetupShort := true

    else if shortState == 1  // ARMED
        bool stale = (useCompression and not inSqueeze) or na(shortLvlRef) or not atrValid or (close - shortLvlRef) > (nearLevelAtr * atr * 2.0)
        if stale
            shortState := 0
        else
            if shortSweepBar == 0 and low <= shortLvlRef - effSweepExc * atr
                shortSweepBar := bar_index
            bool sweepNow = shortSweepBar > 0 and close > shortLvlRef and (bar_index - shortSweepBar) <= effFailWindow
            if sweepNow
                shortState := 6
                evSweepShort := true
                shortSweepBar := 0
            else if attemptShort(shortLvlRef)
                shortState := 2
                shortStateBar := bar_index
                shortAcceptStreak := 1
                shortSweepBar := 0

    else if shortState == 2  // ATTEMPT
        bool acceptClose = atrValid and close < shortLvlRef - effCloseBuffer * atr
        shortAcceptStreak := acceptClose ? shortAcceptStreak + 1 : math.max(shortAcceptStreak - 1, 0)
        bool timeout = (bar_index - shortStateBar) >= effAcceptMax
        bool reclaimed = close > shortLvlRef

        if shortSweepBar == 0 and atrValid and low <= shortLvlRef - effSweepExc * atr
            shortSweepBar := bar_index
        bool sweepNow = reclaimed and shortSweepBar > 0 and (bar_index - shortSweepBar) <= effFailWindow

        if sweepNow
            shortState := 6
            evSweepShort := true
        else if reclaimed
            shortState := 6
            evFailedShort := true
        else if shortAcceptStreak >= effAcceptBars
            shortState := 3
            shortStateBar := bar_index
            evAcceptedShort := true
        else if timeout
            shortState := 6
            evFailedShort := true

    else if shortState == 3  // ACCEPTED
        if wantRetestSignal
            shortState := 4
            shortStateBar := bar_index
        else
            shortState := 7
            shortCooldown := cooldownBars

    else if shortState == 4  // RETEST WATCH (FIXED LOGIC)
        bool timeout = (bar_index - shortStateBar) > retestMaxBars
        float tol = atrValid ? retestTolAtr * atr : 0
        float maxWick = atrValid ? retestMaxWickAtr * atr : 0

        bool touched = high >= shortLvlRef - tol
        bool wickExceeded = high > shortLvlRef + maxWick
        bool held = touched and not wickExceeded and close <= shortLvlRef

        if wickExceeded
            shortState := 6
            evFailedShort := true
        else if held
            shortState := 5
            evRetestShort := true
        else if timeout
            shortState := 7
            shortCooldown := cooldownBars

    else if shortState == 5 or shortState == 6
        shortState := 7
        shortCooldown := cooldownBars

// === CALCULATE SCORES ===
bool acceptedLong = longState >= 3 and longState <= 5
bool acceptedShort = shortState >= 3 and shortState <= 5
bool retestLong = longState == 5
bool retestShort = shortState == 5

int scoreLong = calcTotalScore(true, longLvlTier, acceptedLong, retestLong)
int scoreShort = calcTotalScore(false, shortLvlTier, acceptedShort, retestShort)
string strengthLong = scoreToStrength(scoreLong)
string strengthShort = scoreToStrength(scoreShort)

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// PLOTS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

// Key levels (Standard + Full)
plot(showLevels and usePdhPdl ? pdh : na, "PDH", color=C_LEVEL, style=plot.style_linebr, linewidth=1)
plot(showLevels and usePdhPdl ? pdl : na, "PDL", color=C_LEVEL, style=plot.style_linebr, linewidth=1)
plot(showLevels and usePwhPwl ? pwh : na, "PWH", color=color.new(C_LEVEL, 30), style=plot.style_linebr, linewidth=1)
plot(showLevels and usePwhPwl ? pwl : na, "PWL", color=color.new(C_LEVEL, 30), style=plot.style_linebr, linewidth=1)

// Extended levels (Full only)
plot(showAllLevels and usePmhPml ? pmh : na, "PMH", color=color.new(#ffd700, 60), style=plot.style_linebr, linewidth=2)
plot(showAllLevels and usePmhPml ? pml : na, "PML", color=color.new(#ffd700, 60), style=plot.style_linebr, linewidth=2)
plot(showAllLevels and useOpeningRange and orComplete ? orHigh : na, "OR-H", color=color.new(#9c27b0, 50), style=plot.style_linebr, linewidth=1)
plot(showAllLevels and useOpeningRange and orComplete ? orLow : na, "OR-L", color=color.new(#9c27b0, 50), style=plot.style_linebr, linewidth=1)
plot(showAllLevels and showVwap ? vwapDaily : na, "VWAP", color=C_VWAP, style=plot.style_line, linewidth=1)

// Zones (Full only)
plot(showAllLevels and showZoneLines ? equilibrium : na, "EQ", color=C_NEUTRAL, style=plot.style_line, linewidth=1)
plot(showAllLevels and showOteZone ? oteLongBot : na, "OTE-L Bot", color=C_OTE, style=plot.style_linebr, linewidth=1)
plot(showAllLevels and showOteZone ? oteLongTop : na, "OTE-L Top", color=C_OTE, style=plot.style_linebr, linewidth=1)

// Active levels (Always)
plot(longState > 0 and longState < 6 ? longLvlRef : na, "Active Long", color=C_BULL, style=plot.style_linebr, linewidth=2)
plot(shortState > 0 and shortState < 6 ? shortLvlRef : na, "Active Short", color=C_BEAR, style=plot.style_linebr, linewidth=2)

// Score plots (hidden)
plot(scoreLong, "Score Long", display=display.none)
plot(scoreShort, "Score Short", display=display.none)

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// LABELS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
fmtScore(int s) => showScoreInLabel ? " [" + str.tostring(s) + "]" : ""

if showLabels and evSetupLong
    label.new(bar_index, low, "â—† " + longLvlName, style=label.style_label_up, color=C_DASH_BG, textcolor=C_BULL, size=size.tiny)
if showLabels and evSetupShort
    label.new(bar_index, high, "â—† " + shortLvlName, style=label.style_label_down, color=C_DASH_BG, textcolor=C_BEAR, size=size.tiny)

if showLabels and wantAcceptSignal and evAcceptedLong
    label.new(bar_index, low, strengthSymbol(strengthLong) + " ACCEPT" + fmtScore(scoreLong), style=label.style_label_up, color=C_DASH_BG, textcolor=C_BULL, size=size.small)
if showLabels and wantAcceptSignal and evAcceptedShort
    label.new(bar_index, high, strengthSymbol(strengthShort) + " ACCEPT" + fmtScore(scoreShort), style=label.style_label_down, color=C_DASH_BG, textcolor=C_BEAR, size=size.small)

if showLabels and wantRetestSignal and evRetestLong
    label.new(bar_index, low, strengthSymbol(strengthLong) + " RETEST" + fmtScore(scoreLong), style=label.style_label_up, color=C_DASH_BG, textcolor=C_BULL, size=size.small)
if showLabels and wantRetestSignal and evRetestShort
    label.new(bar_index, high, strengthSymbol(strengthShort) + " RETEST" + fmtScore(scoreShort), style=label.style_label_down, color=C_DASH_BG, textcolor=C_BEAR, size=size.small)

if showLabels and (evSweepLong or evFailedLong)
    label.new(bar_index, high, evSweepLong ? "âœ• SWEEP" : "âœ• FAIL", style=label.style_label_down, color=C_DASH_BG, textcolor=C_FAIL, size=size.tiny)
if showLabels and (evSweepShort or evFailedShort)
    label.new(bar_index, low, evSweepShort ? "âœ• SWEEP" : "âœ• FAIL", style=label.style_label_up, color=C_DASH_BG, textcolor=C_FAIL, size=size.tiny)

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// DASHBOARD (Compact)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
getDashPos(string loc) =>
    loc == "Top Left" ? position.top_left : loc == "Bottom Right" ? position.bottom_right : loc == "Bottom Left" ? position.bottom_left : position.top_right

getDashSize(string sz) =>
    sz == "Tiny" ? size.tiny : sz == "Normal" ? size.normal : size.small

getDashHeaderSize(string sz) =>
    sz == "Tiny" ? size.tiny : sz == "Normal" ? size.small : size.small

var table dash = na
color dashBgColor = color.new(color.black, dashboardTransparency)
string dashTextSize = getDashSize(dashboardSize)
string dashHeaderSize = getDashHeaderSize(dashboardSize)

if showDashboard and barstate.islast
    if na(dash)
        dash := table.new(getDashPos(dashboardLocation), 4, 10, bgcolor=dashBgColor, border_color=color.new(color.white, 80), border_width=1)

    table.clear(dash, 0, 0, 3, 9)

    // Header
    table.merge_cells(dash, 0, 0, 3, 0)
    table.cell(dash, 0, 0, "BQE ULTRA", text_color=color.white, text_size=dashHeaderSize)

    // Context
    string sess = inOverlapKZ ? "LDN/NY" : inNyKZ ? "NY" : inLondonKZ ? "LDN" : inAsiaKZ ? "ASIA" : "OFF"
    color sessCol = inAnyKillzone ? C_BULL : color.gray
    table.cell(dash, 0, 1, "Session", text_color=color.gray, text_size=dashTextSize)
    table.cell(dash, 1, 1, sess, text_color=sessCol, text_size=dashTextSize)
    table.cell(dash, 2, 1, isMacroTime ? "MACRO" : "", text_color=color.yellow, text_size=dashTextSize)

    string zone = inDiscount ? "DISC" : inPremium ? "PREM" : "EQ"
    color zoneCol = inDiscount ? C_BULL : inPremium ? C_BEAR : color.gray
    table.cell(dash, 0, 2, "Zone", text_color=color.gray, text_size=dashTextSize)
    table.cell(dash, 1, 2, zone, text_color=zoneCol, text_size=dashTextSize)
    table.cell(dash, 2, 2, inOteLong ? "OTEâ–²" : inOteShort ? "OTEâ–¼" : "", text_color=C_OTE, text_size=dashTextSize)

    string bias = htfBullish ? "BULL" : htfBearish ? "BEAR" : "â€”"
    color biasCol = htfBullish ? C_BULL : htfBearish ? C_BEAR : color.gray
    table.cell(dash, 0, 3, "HTF", text_color=color.gray, text_size=dashTextSize)
    table.cell(dash, 1, 3, bias, text_color=biasCol, text_size=dashTextSize)

    // Setups
    table.merge_cells(dash, 0, 4, 3, 4)
    table.cell(dash, 0, 4, "â”€â”€ SETUPS â”€â”€", text_color=color.gray, text_size=dashTextSize)

    string lState = longState == 0 ? "IDLE" : longState == 1 ? "ARM" : longState == 2 ? "ATT" : longState == 3 ? "ACC" : longState == 4 ? "RET" : longState == 5 ? "HELD" : "CD"
    color lCol = longState >= 3 and longState <= 5 ? C_BULL : longState == 6 ? C_FAIL : longState > 0 ? color.yellow : color.gray
    table.cell(dash, 0, 5, "LONG", text_color=C_BULL, text_size=dashTextSize)
    table.cell(dash, 1, 5, lState, text_color=lCol, text_size=dashTextSize)
    table.cell(dash, 2, 5, longState > 0 ? longLvlName : "", text_color=color.white, text_size=dashTextSize)
    table.cell(dash, 3, 5, longState > 0 ? str.tostring(scoreLong) : "", text_color=C_BULL, text_size=dashTextSize)

    string sState = shortState == 0 ? "IDLE" : shortState == 1 ? "ARM" : shortState == 2 ? "ATT" : shortState == 3 ? "ACC" : shortState == 4 ? "RET" : shortState == 5 ? "HELD" : "CD"
    color sCol = shortState >= 3 and shortState <= 5 ? C_BEAR : shortState == 6 ? C_FAIL : shortState > 0 ? color.yellow : color.gray
    table.cell(dash, 0, 6, "SHORT", text_color=C_BEAR, text_size=dashTextSize)
    table.cell(dash, 1, 6, sState, text_color=sCol, text_size=dashTextSize)
    table.cell(dash, 2, 6, shortState > 0 ? shortLvlName : "", text_color=color.white, text_size=dashTextSize)
    table.cell(dash, 3, 6, shortState > 0 ? str.tostring(scoreShort) : "", text_color=C_BEAR, text_size=dashTextSize)

    // Levels
    table.merge_cells(dash, 0, 7, 3, 7)
    table.cell(dash, 0, 7, "â”€â”€ LEVELS â”€â”€", text_color=color.gray, text_size=dashTextSize)

    if not na(bestLongLvl)
        float d = round2((bestLongLvl - close) / close * 100)
        table.cell(dash, 0, 8, "Above", text_color=color.gray, text_size=dashTextSize)
        table.cell(dash, 1, 8, bestLongName, text_color=C_BULL, text_size=dashTextSize)
        table.cell(dash, 2, 8, str.tostring(d) + "%", text_color=color.white, text_size=dashTextSize)

    if not na(bestShortLvl)
        float d = round2((close - bestShortLvl) / close * 100)
        table.cell(dash, 0, 9, "Below", text_color=color.gray, text_size=dashTextSize)
        table.cell(dash, 1, 9, bestShortName, text_color=C_BEAR, text_size=dashTextSize)
        table.cell(dash, 2, 9, str.tostring(d) + "%", text_color=color.white, text_size=dashTextSize)

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ALERTS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
alertcondition(alertSetup and evSetupLong, "Setup Long", "BQE: Armed LONG - {{ticker}} @ {{interval}}")
alertcondition(alertSetup and evSetupShort, "Setup Short", "BQE: Armed SHORT - {{ticker}} @ {{interval}}")
alertcondition(alertAccepted and wantAcceptSignal and evAcceptedLong, "Accepted Long", "BQE: ACCEPTED LONG - {{ticker}} @ {{interval}}")
alertcondition(alertAccepted and wantAcceptSignal and evAcceptedShort, "Accepted Short", "BQE: ACCEPTED SHORT - {{ticker}} @ {{interval}}")
alertcondition(alertRetest and wantRetestSignal and evRetestLong, "Retest Long", "BQE: RETEST LONG - {{ticker}} @ {{interval}}")
alertcondition(alertRetest and wantRetestSignal and evRetestShort, "Retest Short", "BQE: RETEST SHORT - {{ticker}} @ {{interval}}")
alertcondition(alertFailed and (evSweepLong or evFailedLong), "Failed Long", "BQE: FAILED LONG - {{ticker}} @ {{interval}}")
alertcondition(alertFailed and (evSweepShort or evFailedShort), "Failed Short", "BQE: FAILED SHORT - {{ticker}} @ {{interval}}")
