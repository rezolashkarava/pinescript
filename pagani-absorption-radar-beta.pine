//@version=6
indicator("Pagani Absorption Radar [Beta]", overlay=true, max_boxes_count=200, max_labels_count=50)

signalTiming = input.string("Confirmed (bar close)", "Signal Timing", options=["Realtime (intrabar)", "Confirmed (bar close)"])

groupAbs = "Absorption Zones"
proxyNote = input.string("Absorption is an OHLCV-based proxy (not true L2/tape iceberg confirmation).", "Concept Note", group=groupAbs,
     tooltip="This tool infers absorption-like behavior from price + volume. It cannot access order book (L2) or trade prints, so it cannot confirm true iceberg orders.")
lenVol = input.int(50, "Volume Baseline Length", minval=10, group=groupAbs)
zThresh = input.float(2.5, "Volume Z Threshold", minval=0.5, step=0.1, group=groupAbs)
hitsNeeded = input.int(3, "Hits To Confirm Zone", minval=2, maxval=6, group=groupAbs)
hitWindow = input.int(20, "Hit Window (bars)", minval=5, maxval=200, group=groupAbs)
timeoutBars = input.int(60, "Zone Timeout (bars)", minval=20, maxval=500, group=groupAbs)
thicknessAtrMult = input.float(0.25, "Zone Thickness (ATR mult)", minval=0.05, maxval=2.0, step=0.05, group=groupAbs)
clusterSlackMult = input.float(3.0, "Clustering Slack (x thickness)", minval=1.0, maxval=10.0, step=0.5, group=groupAbs,
     tooltip="How far apart two hits can be (in multiples of zone thickness) and still be treated as the same absorption level.\nIncrease this on low-volatility coins/timeframes.")
maxZonesPerSide = input.int(6, "Max Zones Per Side", minval=1, maxval=20, group=groupAbs)
showZones = input.bool(true, "Draw Zones", group=groupAbs)
showHitMarkers = input.bool(true, "Mark Absorption Hits", group=groupAbs)

groupSweep = "Liquidity Sweeps (Optional)"
showSweeps = input.bool(true, "Mark Sweeps", group=groupSweep)
sweepLookback = input.int(20, "Sweep Lookback", minval=5, maxval=200, group=groupSweep)
requireVolForSweep = input.bool(true, "Sweep Requires Volume Spike", group=groupSweep)
sweepVolMult = input.float(1.5, "Sweep Volume Mult", minval=1.0, maxval=5.0, step=0.1, group=groupSweep)

groupAlerts = "Alerts"
alertNewZone = input.bool(true, "Alert: Zone Confirmed", group=groupAlerts)
alertZoneBroken = input.bool(true, "Alert: Zone Broken", group=groupAlerts)
alertSweeps = input.bool(true, "Alert: Sweeps", group=groupAlerts)

color bullCol = #00ff88
color bearCol = #ff3366

bool shouldUpdate = signalTiming == "Realtime (intrabar)" or barstate.isconfirmed

float atr = ta.atr(14)
float atrSafe = na(atr) ? 0.0 : atr
float avgVol = ta.sma(volume, lenVol)
float stdevVol = ta.stdev(volume, lenVol)
float volZ = (not na(stdevVol) and stdevVol > 0) ? (volume - avgVol) / stdevVol : 0.0

float body = math.abs(close - open)
float rng = high - low
float bodyToRange = rng > 0 ? body / rng : 0.0
float lowerWick = math.min(open, close) - low
float upperWick = high - math.max(open, close)
float lowerWickRatio = rng > 0 ? lowerWick / rng : 0.0
float upperWickRatio = rng > 0 ? upperWick / rng : 0.0

bool bullAbsorptionRaw = volZ >= zThresh and bodyToRange <= 0.35 and lowerWickRatio >= 0.50 and close > open
bool bearAbsorptionRaw = volZ >= zThresh and bodyToRange <= 0.35 and upperWickRatio >= 0.50 and close < open

bool bullAbsorption = bullAbsorptionRaw and shouldUpdate
bool bearAbsorption = bearAbsorptionRaw and shouldUpdate

float hitPrice = na
if bullAbsorption
    hitPrice := low
else if bearAbsorption
    hitPrice := high

type AbsZone
    box bx
    float top
    float bot
    float center
    int hits
    int firstBar
    int lastHitBar
    int dir
    bool confirmed

deleteZone(AbsZone z) =>
    if not na(z.bx)
        box.delete(z.bx)

float thickness = math.max(atrSafe * thicknessAtrMult, syminfo.mintick * 2)
float halfThick = thickness / 2.0

findMatchingZone(array<AbsZone> zones, float price, int dir, float maxDist) =>
    int idx = -1
    int n = array.size(zones)
    if n > 0
        for i = 0 to n - 1
            AbsZone z = array.get(zones, i)
            bool sameSide = z.dir == dir
            bool nearBand = price <= z.top + maxDist and price >= z.bot - maxDist
            if sameSide and nearBand
                idx := i
                break
    idx

updateZoneBox(AbsZone z) =>
    if not na(z.bx)
        box.set_lefttop(z.bx, z.firstBar, z.top)
        box.set_rightbottom(z.bx, bar_index, z.bot)

newZoneColor(int dir) =>
    dir == 1 ? bullCol : bearCol

ensureZoneBox(AbsZone z) =>
    if showZones and z.confirmed and na(z.bx)
        color c = newZoneColor(z.dir)
        z.bx := box.new(z.firstBar, z.top, bar_index, z.bot, xloc=xloc.bar_index, bgcolor=color.new(c, 85), border_color=color.new(c, 10), border_width=1)
        updateZoneBox(z)
    z

var zones = array.new<AbsZone>()

var bool newBullZone = false
var bool newBearZone = false
var bool bullZoneBroken = false
var bool bearZoneBroken = false
newBullZone := false
newBearZone := false
bullZoneBroken := false
bearZoneBroken := false

var bool lastShowZones = showZones

if shouldUpdate
    // If user toggles drawing ON, render already-confirmed zones.
    if showZones and not lastShowZones
        int nn0 = array.size(zones)
        if nn0 > 0
            for i = 0 to nn0 - 1
                AbsZone z0 = array.get(zones, i)
                z0 := ensureZoneBox(z0)
                array.set(zones, i, z0)
    lastShowZones := showZones

    // === Register absorption hits into zones ===
    if (bullAbsorption or bearAbsorption) and not na(hitPrice)
        int dir = bullAbsorption ? 1 : -1
        float top = hitPrice + halfThick
        float bot = hitPrice - halfThick

        int matchIdx = findMatchingZone(zones, hitPrice, dir, thickness * clusterSlackMult)
        if matchIdx >= 0
            AbsZone z = array.get(zones, matchIdx)
            // If we didn't reach confirmation within the hit window, restart counting.
            if bar_index - z.firstBar > hitWindow and z.hits < hitsNeeded
                z.hits := 0
                z.firstBar := bar_index
                z.top := top
                z.bot := bot
                z.center := hitPrice
                z.confirmed := false
                if not na(z.bx)
                    box.delete(z.bx)
                    z.bx := na

            int prevHits = z.hits
            z.hits += 1
            z.lastHitBar := bar_index
            z.top := math.max(z.top, top)
            z.bot := math.min(z.bot, bot)
            z.center := (z.center * prevHits + hitPrice) / z.hits

            if not z.confirmed and prevHits < hitsNeeded and z.hits >= hitsNeeded
                z.confirmed := true
                if dir == 1
                    newBullZone := true
                else
                    newBearZone := true

            z := ensureZoneBox(z)

            updateZoneBox(z)
            array.set(zones, matchIdx, z)
        else
            AbsZone z = AbsZone.new(na, top, bot, hitPrice, 1, bar_index, bar_index, dir, false)
            array.push(zones, z)

    // === Update, expire, and invalidate zones ===
    int n = array.size(zones)
    if n > 0
        for i = n - 1 to 0
            AbsZone z = array.get(zones, i)
            bool expired = bar_index - z.lastHitBar > timeoutBars
            bool broken = z.dir == 1 ? close < z.bot : close > z.top
            if expired or broken
                if broken and z.confirmed
                    if z.dir == 1
                        bullZoneBroken := true
                    else
                        bearZoneBroken := true
                deleteZone(z)
                array.remove(zones, i)
            else
                // Extend confirmed zone to current bar.
                updateZoneBox(z)
                array.set(zones, i, z)

    // === Trim oldest zones to stay lightweight ===
    int bullCount = 0
    int bearCount = 0
    int nn = array.size(zones)
    if nn > 0
        for i = 0 to nn - 1
            AbsZone z = array.get(zones, i)
            if z.dir == 1
                bullCount += 1
            else
                bearCount += 1
    while bullCount > maxZonesPerSide or bearCount > maxZonesPerSide
        // Remove the oldest zone (smallest firstBar).
        int oldestIdx = -1
        int oldestBar = 2147483647
        int nn2 = array.size(zones)
        for i = 0 to nn2 - 1
            AbsZone z = array.get(zones, i)
            if z.firstBar < oldestBar
                oldestBar := z.firstBar
                oldestIdx := i
        if oldestIdx >= 0
            AbsZone z = array.get(zones, oldestIdx)
            if z.dir == 1
                bullCount -= 1
            else
                bearCount -= 1
            deleteZone(z)
            array.remove(zones, oldestIdx)
        else
            break

// === Optional sweep markers (lightweight proxy) ===
float priorHigh = ta.highest(high, sweepLookback)[1]
float priorLow = ta.lowest(low, sweepLookback)[1]
bool sweepVolOk = not requireVolForSweep or volume > avgVol * sweepVolMult
bool bearSweep = showSweeps and shouldUpdate and not na(priorHigh) and high > priorHigh and close < priorHigh and sweepVolOk
bool bullSweep = showSweeps and shouldUpdate and not na(priorLow) and low < priorLow and close > priorLow and sweepVolOk

// === Plot markers (kept minimal; no dashboard) ===
plotshape(showHitMarkers and bullAbsorption, title="Bull Absorption Hit", style=shape.triangleup, location=location.belowbar, size=size.tiny, color=bullCol, text="A", textcolor=color.black)
plotshape(showHitMarkers and bearAbsorption, title="Bear Absorption Hit", style=shape.triangledown, location=location.abovebar, size=size.tiny, color=bearCol, text="A", textcolor=color.white)
plotshape(bullSweep, title="Bull Sweep", style=shape.triangleup, location=location.belowbar, size=size.tiny, color=color.new(bullCol, 0), text="S", textcolor=color.black)
plotshape(bearSweep, title="Bear Sweep", style=shape.triangledown, location=location.abovebar, size=size.tiny, color=color.new(bearCol, 0), text="S", textcolor=color.white)

// === Alerts ===
alertcondition(alertNewZone and newBullZone, title="Bullish Absorption Zone Confirmed", message="Bullish absorption zone confirmed on {{ticker}} {{interval}}")
alertcondition(alertNewZone and newBearZone, title="Bearish Absorption Zone Confirmed", message="Bearish absorption zone confirmed on {{ticker}} {{interval}}")
alertcondition(alertZoneBroken and bullZoneBroken, title="Bullish Absorption Zone Broken", message="Bullish absorption zone broken on {{ticker}} {{interval }}")
alertcondition(alertZoneBroken and bearZoneBroken, title="Bearish Absorption Zone Broken", message="Bearish absorption zone broken on {{ticker}} {{interval }}")
alertcondition(alertSweeps and bullSweep, title="Bullish Sweep", message="Bullish sweep (liquidity grab proxy) on {{ticker}} {{interval}}")
alertcondition(alertSweeps and bearSweep, title="Bearish Sweep", message="Bearish sweep (liquidity grab proxy) on {{ticker}} {{interval}}")
