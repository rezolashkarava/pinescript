//@version=6
indicator("ICT Order Block Pro [Paganie] v4.1.0", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// ============================================================================
// ICT ORDER BLOCK PRO V4.1.0 - INSTITUTIONAL SMART MONEY CONCEPTS
// Professional-grade order block detection with ICT/SMC methodology
//
// V4.1.0 - Optimized Out-of-Box Defaults:
// â€¢ Signal timing now defaults to "Confirmed (bar close)" for reliable signals
// â€¢ Show Only Strong/Elite OBs enabled by default (quality over quantity)
// â€¢ Sweep lookback reduced to 20 bars (standard ICT pivot detection)
// â€¢ Tighter proximity alerts (0.5% OB, 0.3% liquidity) for actionable signals
// â€¢ Improved Power Row stability: wider neutral band (15%), more smoothing (10)
// â€¢ Better equal H/L detection (0.15% threshold) for clustered liquidity
// â€¢ Reduced max liquidity levels to 6 for cleaner charts
// â€¢ Performance improvements: gradient segments reduced to 8, VP lookback to 100
//
// V4.0.0 - Production Release:
// â€¢ ICT-compliant volume confirmation: Elite status requires volume spike
// â€¢ Added "Elite Requires Volume" setting (default: true per ICT methodology)
// â€¢ Removed dead code: legacy updateBlock/updateBlocks functions
// â€¢ Added comprehensive tooltips to all Internal Tuning settings
// â€¢ Cleaned up code structure and comments for production quality
//
// Features:
// â€¢ Two detection methods: Institutional (stricter) & Scalper (faster)
// â€¢ Multi-TF Power Row with real-time BUY/SELL pressure
// â€¢ ICT Liquidity Sweep Detection: BSL/SSL levels, sweep/run detection
// â€¢ Volume Profile integration for Eliteâ˜… blocks
// â€¢ Quality ratings: â˜… Elite, â—† Strong, â—‡ Mid, â—‹ Weak
// â€¢ Proximity & rejection alerts with anti-spam protection
// â€¢ Crypto filters: BTC.D, Open Interest, weekend penalty
// â€¢ Auto-adapts settings based on timeframe
// ============================================================================

// === TIMEFRAME AUTO-DETECTION ===
tf_in_minutes = timeframe.in_seconds() / 60
is_scalping = tf_in_minutes <= 15  // 1m, 3m, 5m, 10m, 15m
is_swing = tf_in_minutes > 15 and tf_in_minutes <= 240  // 30m, 1H, 2H, 4H
is_position = tf_in_minutes > 240  // Daily, Weekly

// Prefer targeted history buffers over indicator(max_bars_back=...)
max_bars_back(open, 600)
max_bars_back(high, 600)
max_bars_back(low, 600)
max_bars_back(close, 600)
max_bars_back(volume, 600)
max_bars_back(time, 600)

// === HELPER FUNCTIONS ===
formatVolume(float vol) =>
    string s = ""
    if na(vol) or vol == 0
        s := ""
    else
        float k = vol / 1000.0
        float m = vol / 1000000.0
        // Promote to M if K value rounds to 1000 or more
        if m >= 1.0 or k >= 999.5
            s := str.tostring(math.round(m * 100) / 100) + "M"
        else if k >= 1.0
            s := str.tostring(math.round(k * 100) / 100) + "K"
        else
            s := str.tostring(math.round(vol))
    s

// Helper for rounding to 2 decimal places
round2(float x) =>
    math.round(x * 100) / 100

// Helper for rounding to 1 decimal place
round1(float x) =>
    math.round(x * 10) / 10

// Helper to convert strength to numeric score for comparison
strengthScore(string s) =>
    s == "Elite" ? 4 : s == "Strong" ? 3 : s == "Mid" ? 2 : 1

// Direction constants (avoid string comparisons)
int DIR_BULL = 1
int DIR_BEAR = -1

// === INPUTS ===
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// MODE
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string GRP_MODE = "âš™ï¸ Mode"
settingsMode = input.string("Auto", "Settings Mode", options=["Auto", "Manual"], group=GRP_MODE,
     tooltip="AUTO: Optimizes all settings based on timeframe.\nMANUAL: Full control over preset and advanced settings.")
useAdaptiveScan = input.bool(true, "Adaptive Scan Window", group=GRP_MODE, tooltip="Automatically extends scan window in low volatility to find OBs.")

manualPreset = input.string("Auto", "Preset Override", options=["Auto", "Scalping", "Swing", "Position"], group=GRP_MODE,
     tooltip="Override auto-detected preset (Manual mode only).\nAUTO: Use timeframe-based preset.\nSCALPING: More signals, faster.\nSWING: Balanced.\nPOSITION: Fewer, higher-quality signals.")
detectionMethod = input.string("Scalper", "Detection Method", options=["Institutional", "Scalper"], group=GRP_MODE,
     tooltip="INSTITUTIONAL: Pivot-based, stricter, fewer signals.\nSCALPER: Pattern-based, more signals, faster.")
signalTiming = input.string("Confirmed (bar close)", "Signal Timing", options=["Realtime (intrabar)", "Confirmed (bar close)"], group=GRP_MODE,
     tooltip="CONFIRMED: Updates on bar close only (recommended for reliable signals).\nREALTIME: Updates on every tick (more responsive but noisier).")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// MODULES
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string GRP_MOD = "ğŸ“Š Modules"
useVolumeProfile = input.bool(true, "Volume Profile Enhancement", group=GRP_MOD,
     tooltip="Boosts OBs that align with high-volume zones. Auto-scales lookback based on timeframe.")
enableLiquidity = input.bool(true, "Liquidity Sweeps", group=GRP_MOD,
     tooltip="Enable BSL/SSL level tracking and sweep detection.")
enableRejection = input.bool(true, "Track Rejections", group=GRP_MOD,
     tooltip="Detect bounces and retests off order blocks.")
showPowerRow = input.bool(true, "Power Row", group=GRP_MOD,
     tooltip="Display intrabar BUY/SELL pressure in dashboard.")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// VISUALS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string GRP_VIS = "ğŸ¨ Visuals"
showDashboard = input.bool(true, "Show Dashboard", group=GRP_VIS, tooltip="Display the status dashboard panel.")
dashboardLocation = input.string("Top Right", "Dashboard Position", options=["Top Right", "Top Left", "Bottom Right", "Bottom Left"], group=GRP_VIS, tooltip="Dashboard corner position.")
dashboardSize = input.string("Small", "Dashboard Size", options=["Tiny", "Small", "Normal"], group=GRP_VIS, tooltip="Dashboard text size.")
dashboardTransparency = input.int(90, "Dashboard Transparency", minval=0, maxval=90, step=5, group=GRP_VIS, tooltip="Dashboard background transparency.")
showOnlyStrongElite = input.bool(true, "Show Only Strong/Elite OBs", group=GRP_VIS,
     tooltip="Filter out Weak and Mid strength order blocks (recommended for cleaner charts).")
renderMode = input.string("Simple fill", "Render Mode", options=["Simple fill", "Gradient", "Borders only"], group=GRP_VIS,
     tooltip="Simple fill = uniform color (recommended). Gradient = layered effect. Borders only = minimal.")
showLabels = input.bool(true, "Show Labels", group=GRP_VIS, tooltip="Show strength and volume labels on OBs.")
showCornerAccents = input.bool(true, "Corner Accents", group=GRP_VIS, tooltip="Corner markers on Strong/Elite blocks.")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ALERTS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string GRP_ALERT = "ğŸ”” Alerts"
alertNewOB = input.bool(true, "New Order Block", group=GRP_ALERT, tooltip="Alert when new OB forms.")
alertTouch = input.bool(true, "Zone Touch", group=GRP_ALERT, tooltip="Alert when price enters OB zone.")
alertReject = input.bool(true, "Rejection", group=GRP_ALERT, tooltip="Alert when price rejects from OB.")
alertProximity = input.bool(true, "Approaching Zone", group=GRP_ALERT, tooltip="Alert when price approaches OB zones.")
alertLiquidity = input.bool(true, "Liquidity Events", group=GRP_ALERT, tooltip="Alert on sweeps and liquidity runs. Essential for crypto trading.")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// COLORS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string GRP_COL = "ğŸ¨ Colors"
bullBorder = input.color(color.new(#00ff88, 0), "Bullish", group=GRP_COL, tooltip="Bullish OB color.")
bearBorder = input.color(color.new(#ff3366, 0), "Bearish", group=GRP_COL, tooltip="Bearish OB color.")
bslColor = input.color(color.new(#00bfff, 30), "BSL Level", group=GRP_COL, tooltip="Buy-side liquidity level color.")
sslColor = input.color(color.new(#ff6600, 30), "SSL Level", group=GRP_COL, tooltip="Sell-side liquidity level color.")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// CRYPTO FILTERS (Optional Module)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string GRP_CRYPTO = "ğŸª™ Crypto Filters"
i_cryptoModule = input.bool(true, "Enable Crypto Filters", group=GRP_CRYPTO,
     tooltip="Enable crypto-specific scoring factors (BTC.D, OI, weekend penalty). Optimized for crypto trading.")
i_useBtcDom = input.bool(true, "BTC Dominance Filter", group=GRP_CRYPTO,
     tooltip="Boost demand zones during alt season, supply zones during BTC dominance.")
i_useBtcCorr = input.bool(true, "BTC Correlation", group=GRP_CRYPTO,
     tooltip="Boost zones aligned with BTC trend direction (for altcoins).")
i_useOI = input.bool(true, "Open Interest Filter", group=GRP_CRYPTO,
     tooltip="Boost zones confirmed by Open Interest buildup.")
i_useWeekend = input.bool(true, "Weekend Penalty", group=GRP_CRYPTO,
     tooltip="Reduce score for zones formed on weekends (low liquidity).")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// INTERNAL TUNING (Exposed for Power Users)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string GRP_INT = "ğŸ› ï¸ Internal Tuning"

// Detection
int scalperLookback = input.int(10, "Scalper Lookback", minval=1, group=GRP_INT, tooltip="Bars to scan for impulse candles in Scalper mode.")
int obScanWindow = input.int(3, "OB Scan Window", minval=1, group=GRP_INT, tooltip="Bars to scan back from impulse to find OB candle.")
int gridSegments = input.int(8, "Gradient Segments", minval=2, maxval=20, group=GRP_INT, tooltip="Layers for gradient render mode. Lower = faster.")
float dispAtrBodyMult = input.float(0.8, "Displacement Body (ATR)", step=0.1, group=GRP_INT, tooltip="Min body size relative to ATR for displacement.")
float dispBodyToRangeMin = input.float(0.6, "Displacement % of Range", step=0.05, group=GRP_INT, tooltip="Body must be this % of candle range.")
bool useDisplacement = input.bool(true, "Require Displacement", group=GRP_INT, tooltip="Require strong impulse candle after OB.")
bool useFVG = input.bool(true, "Require FVG", group=GRP_INT, tooltip="Require Fair Value Gap confirmation.")
bool useMSB = input.bool(true, "Require MSB", group=GRP_INT, tooltip="Require Market Structure Break confirmation.")
bool useVolume = input.bool(true, "Use Volume Filter", group=GRP_INT, tooltip="Include volume in strength scoring.")

// FVG Settings
string fvgMode = input.string("Classic 3-candle", "FVG Mode", options=["Classic 3-candle", "Strict (body gap)", "Loose (wick gap)", "Off"], group=GRP_INT, tooltip="FVG detection strictness.")
float fvgMinGapAtr = input.float(0.0, "Min FVG Gap (ATR)", step=0.1, group=GRP_INT, tooltip="Minimum gap size as multiple of ATR. 0=any gap.")

// MSB Settings
int msbLookback = input.int(10, "MSB Lookback", minval=1, group=GRP_INT, tooltip="Bars to check for structure break.")
bool msbUsePivotFallback = input.bool(true, "MSB Pivot Fallback", group=GRP_INT, tooltip="Use pivot high/low as minimum structure level.")

// Zones
float smartSizeAtrMult = input.float(1.2, "Smart Size (ATR)", step=0.1, group=GRP_INT, tooltip="Max zone height as ATR multiple for smart sizing.")
string smartAnchor = input.string("Wick", "Zone Anchor", options=["Wick", "Close"], group=GRP_INT, tooltip="Anchor zone from wick or close price.")
string mitigationMode = input.string("Auto", "Mitigation Mode", options=["Auto", "Wick", "Close", "Mean"], group=GRP_INT, tooltip="How to determine when OB is mitigated/invalidated.")
float minPenZonePct = input.float(0.10, "Min Penetration (% Zone)", step=0.05, group=GRP_INT, tooltip="Min penetration beyond zone for mitigation.")
float minPenAtrPct = input.float(0.05, "Min Penetration (% ATR)", step=0.01, group=GRP_INT, tooltip="Min penetration as ATR % for mitigation.")
float meanMitigationLevel = input.float(0.5, "Mean Mitigation Level", step=0.1, group=GRP_INT, tooltip="0.5 = 50% into zone for Mean mitigation.")

// Touch & Retest
string touchMode = input.string("Wick", "Touch Mode", options=["Wick", "Close"], group=GRP_INT, tooltip="Wick=any touch counts, Close=close must enter zone.")
string retestDebounce = input.string("Require exit before recount", "Retest Count Mode", options=["Require exit before recount", "Count each bar in zone"], group=GRP_INT, tooltip="How to count multiple touches/retests.")
string rejectionCloseLevel = input.string("Mid", "Rejection Target", options=["Mid", "Top/Bottom", "Percent into zone"], group=GRP_INT, tooltip="Where price must close for rejection signal.")
float rejectionPercent = input.float(0.5, "Rejection %", step=0.1, group=GRP_INT, tooltip="For 'Percent into zone' rejection mode.")
int fillAlpha = input.int(80, "Block Opacity", minval=0, maxval=100, group=GRP_INT, tooltip="Transparency for OB fill. 0=solid, 100=invisible.")
bool showRetests = input.bool(true, "Show Retest Labels", group=GRP_INT, tooltip="Show retest count on OB labels.")

// Strength Scoring
float volScoreMult = input.float(2.0, "Volume Score Mult", step=0.1, group=GRP_INT, tooltip="Volume must exceed avg * this for +1 score.")
float bodyScoreMult = input.float(1.5, "Body Score Mult", step=0.1, group=GRP_INT, tooltip="Body must exceed avg * this for +1 score.")
int vpScoreBoost = input.int(1, "VP Score Boost", minval=0, group=GRP_INT, tooltip="Points added when VP confirms the zone.")
int vpLookback = input.int(100, "VP Lookback", minval=10, group=GRP_INT, tooltip="Bars for Volume Profile analysis.")
float vpThreshold = input.float(1.5, "VP Concentration Threshold", step=0.1, group=GRP_INT, tooltip="VP ratio needed for confirmation.")
bool eliteRequiresVP = input.bool(true, "Elite Requires VP", group=GRP_INT, tooltip="Elite status requires Volume Profile confirmation.")
bool eliteRequiresVolume = input.bool(true, "Elite Requires Volume", group=GRP_INT,
     tooltip="ICT methodology: Volume spike is essential for valid institutional order blocks. When enabled, Elite status requires volume confirmation regardless of other factors.")
string maxBlocksUser = input.string("Auto", "Max Active Blocks", options=["Auto", "5", "8", "10", "15", "20"], group=GRP_INT)

// Liquidity Settings
bool showLiquidityLevels = input.bool(true, "Show LQ Levels", group=GRP_INT, tooltip="Display BSL/SSL horizontal lines.")
bool showSweepEvents = input.bool(true, "Show Sweep Events", group=GRP_INT, tooltip="Highlight boxes when liquidity is swept.")
bool showLiquidityRuns = input.bool(true, "Show LQ Runs (Continuation)", group=GRP_INT, tooltip="Track when price runs through liquidity.")
bool markEqualHL = input.bool(true, "Mark Equal H/L", group=GRP_INT, tooltip="Identify clustered equal highs/lows.")
int sweepLookback = input.int(20, "Sweep Lookback", minval=5, group=GRP_INT, tooltip="Bars to find swing highs/lows for liquidity (ICT standard: 20).")
float equalHLThreshold = input.float(0.15, "Equal H/L Threshold (%)", step=0.05, group=GRP_INT, tooltip="Max % diff to consider levels equal (clustered liquidity).")
float sweepWickMin = input.float(0.5, "Sweep Wick Min (ATR)", step=0.1, group=GRP_INT, tooltip="Min wick beyond level for valid sweep.")
bool requireVolumeSpike = input.bool(true, "Sweep Requires Volume", group=GRP_INT, tooltip="Require above-avg volume for sweep.")
int maxLiquidityLevelsInput = input.int(6, "Max LQ Levels", minval=1, maxval=20, group=GRP_INT, tooltip="Max BSL/SSL levels to track.")
color sweepBullColor = input.color(color.new(#00ff88, 20), "Sweep Bull Color", group=GRP_INT)
color sweepBearColor = input.color(color.new(#ff3366, 20), "Sweep Bear Color", group=GRP_INT)

// Alert Tuning
float proximityThreshold = input.float(0.5, "Alert Proximity (%)", step=0.1, group=GRP_INT, tooltip="Alert when price is within this % of OB (tighter = more actionable).")
float liquidityProximityPct = input.float(0.3, "LQ Alert Proximity (%)", step=0.1, group=GRP_INT, tooltip="Alert when price is within this % of BSL/SSL.")

// Power Row Tuning
string powerMode = input.string("Auto", "Power Mode", options=["Auto", "Custom"], group=GRP_INT, tooltip="Auto scales settings by timeframe.")
string powerLtf = input.string("1", "Power LTF", options=["1", "5", "15", "60", "240"], group=GRP_INT, tooltip="Lower timeframe for intrabar analysis (Custom mode).")
string powerVolumeMethod = input.string("Pressure", "Power Volume Method", options=["Pressure", "Polarity"], group=GRP_INT, tooltip="Pressure=proportional, Polarity=binary buy/sell.")
string powerTieBreak = input.string("Carry last direction", "Power Tie Break", options=["Carry last direction", "Use prev intrabar close", "Ignore dojis"], group=GRP_INT, tooltip="How to handle doji candles in Polarity mode.")
float powerNeutralBandPct = input.float(15.0, "Power Neutral Band", step=1.0, group=GRP_INT, tooltip="% dominance below this shows NEUTRAL (higher = more stable).")
int powerFlipConfirmBars = input.int(0, "Power Confirm Bars (0=Auto)", minval=0, group=GRP_INT, tooltip="Bars to confirm direction change. 0=auto.")
int powerSmoothingLen = input.int(10, "Power Smoothing", minval=1, group=GRP_INT, tooltip="Smoothing period for power percentage (higher = more stable).")
string powerSmoothingType = input.string("EMA", "Smoothing Type", options=["EMA", "SMA"], group=GRP_INT, tooltip="Smoothing algorithm.")
int powerMinIntrabars = input.int(4, "Min Intrabars", minval=1, group=GRP_INT, tooltip="Min intrabars for confident reading.")

// === DERIVED SETTINGS ===
// Simplified user interface maps to internal variables
bool showStrength = showLabels
bool showVolLabel = showLabels
bool proximityAlertEnabled = alertProximity
bool alertOnlyStrongBlocks = true
bool alertOnlyFreshBlocks = false
bool requireDirectionalApproach = true
bool alertLiquiditySweep = alertLiquidity
bool alertLiquidityRun = alertLiquidity
bool alertApproachingLiquidity = alertLiquidity
string smartSizingAppliesTo = "Scalping only"
string blockSizing = "Smart"

// === EFFECTIVE PRESET DETERMINATION ===
// Auto mode: derive preset from timeframe
// Manual mode: use manualPreset override (if not "Auto")
string tfBasedPreset = is_scalping ? "Scalping" : is_swing ? "Swing" : "Position"
string effectivePreset = (settingsMode == "Manual" and manualPreset != "Auto") ? manualPreset : tfBasedPreset
bool effectiveAutoMode = settingsMode == "Auto"

// === AUTO-CONFIGURATION BASED ON PRESET ===
int actualLookback = 5  // Default, overwritten by preset
float dispMagnitude = 1.3
int actualMsbPeriod = msbLookback  // Now uses user input as base
bool actualFVG = useFVG
bool actualMSB = useMSB
int maxBlocks = 10
int effectiveScanWindow = obScanWindow
string mitigationMethod = "Wick"

// Performance guardrails (Auto mode forces safe defaults)
int effectiveGridSegments = gridSegments
string effectiveRenderMode = renderMode

if effectivePreset == "Scalping"
    // Scalping: More signals, faster response
    actualLookback := 3
    dispMagnitude := 1.1
    actualMsbPeriod := 5
    actualFVG := settingsMode == "Auto" ? false : useFVG  // Auto forces off for scalping
    actualMSB := true
    maxBlocks := 8
    mitigationMethod := mitigationMode == "Auto" ? "Wick" : mitigationMode
    // PERFORMANCE GUARDRAILS for scalping (Auto mode) - cap segments
    if settingsMode == "Auto"
        effectiveGridSegments := math.min(gridSegments, 5)  // Cap at 5 for speed
else if effectivePreset == "Swing"
    // Swing: Balanced approach
    actualLookback := 5
    dispMagnitude := 1.3
    actualMsbPeriod := 10
    actualFVG := settingsMode == "Auto" ? true : useFVG
    actualMSB := true
    maxBlocks := 6
    mitigationMethod := mitigationMode == "Auto" ? "Close" : mitigationMode
    if settingsMode == "Auto"
        effectiveGridSegments := math.min(gridSegments, 8)  // Cap at 8 for balance
else
    // Position: Quality focus
    actualLookback := 7
    dispMagnitude := 1.5
    actualMsbPeriod := 15
    actualFVG := settingsMode == "Auto" ? true : useFVG
    actualMSB := true
    maxBlocks := 5
    mitigationMethod := mitigationMode == "Auto" ? "Mean" : mitigationMode
    if settingsMode == "Auto"
        effectiveGridSegments := math.min(gridSegments, 15)
        // Adaptive Scan: Allow deeper scan for Position trading
        if useAdaptiveScan
            effectiveScanWindow := 8

// User override for MSB lookback (only in Manual mode)
if settingsMode == "Manual"
    actualMsbPeriod := msbLookback

// === LIQUIDITY AUTO-SCALING ===
// Cap maxLiquidityLevels in Auto mode for scalping to reduce object load
int maxLiquidityLevels = maxLiquidityLevelsInput
if settingsMode == "Auto" and effectivePreset == "Scalping"
    maxLiquidityLevels := math.min(maxLiquidityLevelsInput, 4)  // Cap at 4 for scalping performance
else if settingsMode == "Auto" and effectivePreset == "Swing"
    maxLiquidityLevels := math.min(maxLiquidityLevelsInput, 5)  // Cap at 5 for swing

// === VOLUME PROFILE AUTO-SCALING ===
// Automatically reduce VP lookback on lower timeframes to improve performance
var int vpLookbackEff = vpLookback

if useVolumeProfile
    if effectiveAutoMode
        // Auto-scale based on timeframe (reduces CPU load on low TF)
        // Mapping: 1mâ†’60, 3mâ†’80, 5mâ†’100, 15mâ†’150, 1hâ†’200, 4h+â†’300
        if tf_in_minutes <= 1
            vpLookbackEff := math.min(60, vpLookback)
        else if tf_in_minutes <= 3
            vpLookbackEff := math.min(80, vpLookback)
        else if tf_in_minutes <= 5
            vpLookbackEff := math.min(100, vpLookback)
        else if tf_in_minutes <= 15
            vpLookbackEff := math.min(150, vpLookback)
        else if tf_in_minutes <= 60
            vpLookbackEff := math.min(200, vpLookback)
        else
            vpLookbackEff := math.min(300, vpLookback)
    else
        // Manual mode: use raw vpLookback input
        vpLookbackEff := vpLookback

// === POWER ROW: INTRABAR VOLUME ANALYSIS ===
// Auto-select lower timeframe based on chart TF with expanded mapping
// Never request a timeframe higher than the chart TF
getPowerLtf() =>
    string ltf = "1"
    int chartSeconds = timeframe.in_seconds()

    // Expanded mapping for all timeframes
    if tf_in_minutes <= 5
        ltf := "1"          // Chart â‰¤5m â†’ 1-min intrabars
    else if tf_in_minutes <= 15
        ltf := "1"          // Chart â‰¤15m â†’ 1-min intrabars
    else if tf_in_minutes <= 60
        ltf := "5"          // Chart â‰¤1h â†’ 5-min intrabars
    else if tf_in_minutes <= 240
        ltf := "15"         // Chart â‰¤4h â†’ 15-min intrabars
    else if tf_in_minutes <= 1440
        ltf := "60"         // Chart â‰¤1D â†’ 1h intrabars
    else
        ltf := "240"        // Weekly+ â†’ 4h intrabars

    // Safety check: never request higher TF than chart
    // Convert ltf to seconds for comparison
    int ltfSeconds = ltf == "1" ? 60 : ltf == "5" ? 300 : ltf == "15" ? 900 : ltf == "60" ? 3600 : 14400
    if ltfSeconds >= chartSeconds
        // Fallback: use smallest valid LTF (1 min) or chart TF itself
        ltf := chartSeconds <= 60 ? timeframe.period : "1"

    ltf

// Auto-scale smoothing length based on chart TF
getAutoSmoothingLen() =>
    int len = 8
    if tf_in_minutes <= 15
        len := 6           // Faster charts: lighter smoothing (5-8)
    else if tf_in_minutes <= 60
        len := 10          // 1h: moderate smoothing (10-14)
    else if tf_in_minutes <= 240
        len := 14          // 4h: heavier smoothing (14-18)
    else
        len := 18          // Daily+: strongest smoothing (14-21)
    len

// Auto-scale flip confirmation bars based on chart TF
getAutoFlipConfirm() =>
    int confirm = 2
    if tf_in_minutes <= 15
        confirm := 2       // Fast charts: 2-3 bars
    else if tf_in_minutes <= 60
        confirm := 3       // 1h: 3-4 bars
    else if tf_in_minutes <= 240
        confirm := 4       // 4h: 4-5 bars
    else
        confirm := 5       // Daily+: 5-8 bars
    confirm

// Determine effective Power settings based on settingsMode
// When settingsMode=Auto: force stability settings regardless of powerMode
// When settingsMode=Manual: respect powerMode (Auto/Manual within Power)
string effectivePowerLtf = na
int effectiveSmoothingLen = 0
int effectiveFlipConfirm = 0
string effectivePowerTieBreak = powerTieBreak
float effectiveNeutralBandPct = powerNeutralBandPct
int effectivePowerMinIntrabars = powerMinIntrabars

if settingsMode == "Auto"
    // Force all Power stability settings based on preset
    effectivePowerLtf := getPowerLtf()
    effectiveSmoothingLen := getAutoSmoothingLen()
    effectiveFlipConfirm := getAutoFlipConfirm()
    effectivePowerTieBreak := "Carry last direction"  // Most stable option
    // Neutral band by preset (higher = more stable)
    effectiveNeutralBandPct := effectivePreset == "Scalping" ? 12.0 : effectivePreset == "Swing" ? 15.0 : 18.0
    // Min intrabars by preset (lower = faster response on faster TF)
    effectivePowerMinIntrabars := effectivePreset == "Scalping" ? 4 : effectivePreset == "Swing" ? 3 : 2
else
    // Manual mode: respect powerMode input
    effectivePowerLtf := powerMode == "Auto" ? getPowerLtf() : powerLtf
    effectiveSmoothingLen := powerMode == "Auto" ? getAutoSmoothingLen() : powerSmoothingLen
    effectiveFlipConfirm := powerFlipConfirmBars == 0 ? getAutoFlipConfirm() : powerFlipConfirmBars
    // Keep user's settings
    effectivePowerTieBreak := powerTieBreak
    effectiveNeutralBandPct := powerNeutralBandPct
    effectivePowerMinIntrabars := powerMinIntrabars

// Request intrabar data - OPTIMIZED: Single tuple call instead of 5 separate calls
// These return arrays of values for each intrabar within the current chart bar
// Gated by showPowerRow to skip entirely when Power Row is disabled
int chartTfSec = timeframe.in_seconds()
int powerTfSec = timeframe.in_seconds(effectivePowerLtf)
string powerLtfSafe = powerTfSec <= chartTfSec ? effectivePowerLtf : timeframe.period

// PERFORMANCE: Consolidated into single request with tuple expression (5 calls â†’ 1 call)
// Note: Must use if/else since ternary cannot return tuples in Pine Script
var array<float> arrOpen = array.new<float>()
var array<float> arrHigh = array.new<float>()
var array<float> arrLow = array.new<float>()
var array<float> arrClose = array.new<float>()
var array<float> arrVol = array.new<float>()

if showPowerRow
    [o, h, l, c, v] = request.security_lower_tf(syminfo.tickerid, powerLtfSafe, [open, high, low, close, volume], ignore_invalid_timeframe=true, ignore_invalid_symbol=true)
    arrOpen := o
    arrHigh := h
    arrLow := l
    arrClose := c
    arrVol := v
else
    arrOpen := array.new<float>()
    arrHigh := array.new<float>()
    arrLow := array.new<float>()
    arrClose := array.new<float>()
    arrVol := array.new<float>()

// Calculate Power metrics from intrabar data
// Supports both Polarity (binary) and Pressure (proportional) methods
calcPower(string method, string tieBreakRule) =>
    float buyVol = 0.0
    float sellVol = 0.0
    // Validate all arrays have same size (edge case: symbol/timeframe errors)
    int sizeVol = array.size(arrVol)
    int sizeOpen = array.size(arrOpen)
    int sizeHigh = array.size(arrHigh)
    int sizeLow = array.size(arrLow)
    int sizeClose = array.size(arrClose)
    int intrabarCount = math.min(sizeVol, math.min(sizeOpen, math.min(sizeHigh, math.min(sizeLow, sizeClose))))
    int lastDir = 0  // 1 = bullish, -1 = bearish, 0 = unknown

    if intrabarCount > 0
        float prevClose = na
        for i = 0 to intrabarCount - 1
            float o = array.get(arrOpen, i)
            float h = array.get(arrHigh, i)
            float l = array.get(arrLow, i)
            float c = array.get(arrClose, i)
            float v = array.get(arrVol, i)

            if method == "Pressure"
                // === BUYING/SELLING PRESSURE METHOD ===
                // Proportionally assigns volume based on where price closed within the range
                // (close - low) = buying pressure, (high - close) = selling pressure
                float candleRange = h - l
                if candleRange > 0
                    float buyRatio = (c - l) / candleRange
                    float sellRatio = (h - c) / candleRange
                    buyVol += v * buyRatio
                    sellVol += v * sellRatio
                else
                    // No range (h == l), use direction from open to close
                    if c > o
                        buyVol += v
                    else if c < o
                        sellVol += v
                    else
                        // True doji - split evenly
                        buyVol += v * 0.5
                        sellVol += v * 0.5
            else
                // === POLARITY METHOD ===
                // Binary classification: all volume goes to buy or sell
                int dir = 0
                if c > o
                    dir := 1   // Bullish intrabar
                else if c < o
                    dir := -1  // Bearish intrabar
                else
                    // Doji (close == open) - apply tie-break rule (uses effective setting)
                    if tieBreakRule == "Carry last direction"
                        dir := lastDir
                    else if tieBreakRule == "Use prev intrabar close"
                        if not na(prevClose)
                            dir := c > prevClose ? 1 : (c < prevClose ? -1 : 0)
                    // else "Ignore dojis" - dir stays 0, volume not counted

                // Accumulate volume by direction
                if dir == 1
                    buyVol += v
                else if dir == -1
                    sellVol += v

                // Update state for next iteration
                if dir != 0
                    lastDir := dir
                prevClose := c

    [buyVol, sellVol, intrabarCount]

// PERFORMANCE: Gate all Power calculations by showPowerRow
// Note: Must use if/else since ternary cannot return tuples in Pine Script
float rawBuyVol = 0.0
float rawSellVol = 0.0
int intrabarCount = 0
if showPowerRow
    [b, s, c] = calcPower(powerVolumeMethod, effectivePowerTieBreak)
    rawBuyVol := b
    rawSellVol := s
    intrabarCount := c

// Compute delta and percentage (only when Power Row enabled)
float rawDelta = showPowerRow ? rawBuyVol - rawSellVol : 0.0
float rawTotal = showPowerRow ? rawBuyVol + rawSellVol : 0.0
float rawPowerPct = showPowerRow and rawTotal > 0 ? 100.0 * math.abs(rawDelta) / rawTotal : na

// Apply smoothing for display stability (uses effective length)
// PERFORMANCE: ta.ema/sma still need to run to maintain series consistency, but will use na input when disabled
float smoothedPowerPct = showPowerRow ? (powerSmoothingType == "EMA" ?
     ta.ema(rawPowerPct, effectiveSmoothingLen) :
     ta.sma(rawPowerPct, effectiveSmoothingLen)) : na

// Determine RAW side from delta (before stability filters)
int rawPowerSide = showPowerRow ? (rawDelta > 0 ? 1 : (rawDelta < 0 ? -1 : 0)) : 0  // 1=BUY, -1=SELL, 0=NEUTRAL

// === STABILITY FILTERS ===
// 1) Neutral band: if powerPct is in the neutral zone, force NEUTRAL
//    Neutral zone = [50 - band/2, 50 + band/2] mapped to powerPct scale
//    Since powerPct is 0-100 (dominance), neutral band applies when dominance is LOW
float neutralThreshold = effectiveNeutralBandPct  // Uses effective setting (Auto forces per preset)
bool inNeutralZone = na(smoothedPowerPct) or smoothedPowerPct < neutralThreshold

// 2) Flip confirmation: require N consecutive bars supporting new side before switching
var int confirmedPowerSide = 0  // Persisted displayed side
var int flipConfirmCount = 0    // Counter for confirmation

// Get the candidate side (after neutral zone filter)
int candidateSide = inNeutralZone ? 0 : rawPowerSide

// Signal timing: only update stateful counters when appropriate
// Realtime: update every tick | Confirmed: update only on bar close
bool shouldUpdatePowerState = signalTiming == "Realtime (intrabar)" or barstate.isconfirmed

// Apply flip confirmation logic (respects signal timing)
if shouldUpdatePowerState
    if candidateSide == confirmedPowerSide
        // Same side - reset confirmation counter
        flipConfirmCount := 0
    else if candidateSide == 0
        // Moving to NEUTRAL - confirm immediately (no delay for de-escalation)
        confirmedPowerSide := 0
        flipConfirmCount := 0
    else
        // Different non-neutral side - require confirmation
        flipConfirmCount += 1
        if flipConfirmCount >= effectiveFlipConfirm
            confirmedPowerSide := candidateSide
            flipConfirmCount := 0

// Final displayed side (uses confirmed side for stability)
int powerSide = confirmedPowerSide

// Low confidence check (uses effective min intrabars setting)
bool powerLowConf = intrabarCount < effectivePowerMinIntrabars or rawTotal == 0 or na(rawPowerPct)

// === LATCHED POWER VALUES FOR CONFIRMED MODE ===
// When signalTiming="Confirmed (bar close)", dashboard should show stable values
// that only update on bar close (no intrabar flicker)
var float latchedPowerPct = 0.0
var int latchedIntrabarCount = 0
var bool latchedPowerLowConf = true
var int latchedPowerSide = 0

// Determine if we should update latched values
// Realtime mode: always use live values (no latching needed, handled in dashboard)
// Confirmed mode: only update latched values on bar close
// NOTE: latchedPowerLowConf must also consider na(smoothedPowerPct) for proper "â€”" display
if signalTiming == "Confirmed (bar close)"
    if barstate.isconfirmed
        latchedPowerPct := na(smoothedPowerPct) ? 0.0 : smoothedPowerPct
        latchedIntrabarCount := intrabarCount
        latchedPowerLowConf := powerLowConf or na(smoothedPowerPct)  // Include na check for display
        latchedPowerSide := powerSide
else
    // Realtime mode: keep latched values in sync (for consistency)
    latchedPowerPct := na(smoothedPowerPct) ? 0.0 : smoothedPowerPct
    latchedIntrabarCount := intrabarCount
    latchedPowerLowConf := powerLowConf or na(smoothedPowerPct)  // Include na check for display
    latchedPowerSide := powerSide

// === DATA STRUCTURES ===
type OrderBlock
    box[] volumeBoxes
    line topLine
    line botLine
    linefill bgFill
    label volLabel
    box[] cornerBoxes  // Corner accent markers
    float top
    float bot
    int direction
    float totalVolume
    float relativeVol
    string strength
    bool touched
    int retestCount
    bool mitigated
    bool rejected
    // State tracking for conditional updates (performance optimization)
    int lastUpdateBar       // Track last bar_index updated
    int lastRetestCount     // For label rebuild check
    bool lastTouched
    bool lastRejected
    string formattedVol     // PERFORMANCE: Cached formatted volume string

type LiquiditySweep
    line levelLine           // Horizontal line at swing high/low
    box sweepBox             // Highlight box for sweep event
    label sweepLabel         // Info label
    float level              // Price level of swing high/low
    int levelBar             // Bar index where level formed
    int direction            // DIR_BULL (1) or DIR_BEAR (-1)
    bool isEqual             // Is this an "equal high/low" (clustered liquidity)
    bool swept               // Has been swept (reversal)
    bool ranThrough          // Has been run through (continuation)
    int sweepBar             // Bar when sweep/run occurred
    float sweepWick          // Wick extent beyond level
    float sweepClose         // Close price of sweep candle
    string quality           // "Strong", "Mid", "Weak" based on factors
    bool confirmed           // Sweep confirmed (reversal started)
    int retestCount          // Times level retested after sweep
    int lastUpdateBar        // State tracking

// Dashboard size helpers (must be before renderDashboardRow)
getDashTextSize() =>
    string result = size.small
    if dashboardSize == "Tiny"
        result := size.tiny
    else if dashboardSize == "Normal"
        result := size.normal
    result

getDashHeaderSize() =>
    string result = size.small
    if dashboardSize == "Tiny"
        result := size.tiny
    result

string dashTextSize = getDashTextSize()
string dashHeaderSize = getDashHeaderSize()

// Helper to render a dashboard row for an order block
// Returns the next row number (incremented if row was rendered)
renderDashboardRow(table tbl, int row, OrderBlock b, string dirLabel, color dirCol, float dist, string rejectedLabel) =>
    int nextRow = row
    // Render regardless of distance; negative means price is beyond the zone
    if row <= 7  // Leave rows 8-9 for Power
        table.cell(tbl, 0, row, dirLabel, text_color=dirCol, text_size=dashTextSize, width=0)
        table.cell(tbl, 1, row, b.formattedVol, text_color=dirCol, text_size=dashTextSize, width=0)  // PERFORMANCE: Use cached formatted volume
        table.cell(tbl, 2, row, str.tostring(round2(dist)) + "%", text_color=color.white, text_size=dashTextSize, width=0)

        color strengthCol = b.strength == "Elite" ? color.yellow : b.strength == "Strong" ? dirCol : b.strength == "Mid" ? color.orange : color.gray
        table.cell(tbl, 3, row, b.strength, text_color=strengthCol, text_size=dashTextSize, width=0)
        table.cell(tbl, 4, row, str.tostring(b.retestCount), text_color=color.white, text_size=dashTextSize, width=0)

        // Check if price is currently in zone
        bool currentlyInZone = low <= b.top and high >= b.bot
        string status = b.rejected ? rejectedLabel : (b.retestCount > 0 ? (currentlyInZone ? "ACTIVE" : "TESTED") : "FRESH")
        color statusCol = b.rejected ? dirCol : (currentlyInZone ? color.yellow : (b.retestCount > 0 ? color.orange : color.white))
        table.cell(tbl, 5, row, status, text_color=statusCol, text_size=dashTextSize, width=0)
        table.cell(tbl, 6, row, str.tostring(round1(b.relativeVol)) + "x", text_color=color.white, text_size=dashTextSize, width=0)
        nextRow := row + 1
    nextRow

renderDashboardBlocks(table tbl, int row, array<OrderBlock> blocks, bool isBull) =>
    int nextRow = row
    int blockCount = array.size(blocks)
    if blockCount > 0
        string dirLabel = isBull ? "BULL â–²" : "BEAR â–¼"
        color dirCol = isBull ? bullBorder : bearBorder
        string rejectedLabel = isBull ? "BOUNCE" : "REJECT"
        for i = blockCount - 1 to 0
            if nextRow > 7  // Leave rows 8-9 for Power
                break
            OrderBlock b = array.get(blocks, i)
            float dist = isBull ? (close - b.bot) / close * 100 : (b.top - close) / close * 100
            nextRow := renderDashboardRow(tbl, nextRow, b, dirLabel, dirCol, dist, rejectedLabel)
    nextRow

var bullBlocks = array.new<OrderBlock>()
var bearBlocks = array.new<OrderBlock>()
var bslLevels = array.new<LiquiditySweep>()  // Buy-side liquidity (above price)
var sslLevels = array.new<LiquiditySweep>()  // Sell-side liquidity (below price)
var table dashboard = na
var string lastDashboardLocation = na  // Track location for table recreation
var int lastDashboardTransparency = na  // Track transparency for table recreation
var string lastDashboardSize = na  // Track size for table recreation

// Market context (no var needed - recalculated each bar)
float atr = ta.atr(14)
float avgVol = ta.sma(volume, 20)
float avgBody = ta.sma(math.abs(close - open), 20)
float sma50 = ta.sma(close, 50)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRYPTO MARKET REGIME ENGINE (Optional Module) - OPTIMIZED
// All calculations gated by i_cryptoModule to skip when disabled
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// --- BTC Chart Detection (only computed when crypto module active) ---
bool is_btc_chart = i_cryptoModule ? str.contains(str.lower(syminfo.ticker), "btc") : false

// --- BTC Dominance Detection ---
float btc_dom = i_cryptoModule and i_useBtcDom ? request.security("BTC.D", timeframe.period, close, ignore_invalid_symbol=true) : na
float btc_dom_sma = i_cryptoModule and i_useBtcDom and not na(btc_dom) ? ta.sma(btc_dom, 30) : na

// BTC.D Regime: 1 = alt season (favorable for alts), -1 = BTC dominance (risk-off), 0 = neutral
int btc_regime = 0
if i_cryptoModule and i_useBtcDom and not na(btc_dom) and not na(btc_dom_sma)
    if btc_dom > 60 and btc_dom > btc_dom_sma
        btc_regime := -1  // BTC dominance rising - risk-off for alts
    else if btc_dom < 55 and btc_dom < btc_dom_sma
        btc_regime := 1   // Alt season - favorable for alts

// --- BTC Price Correlation ---
float btc_close = i_cryptoModule and i_useBtcCorr ? (is_btc_chart ? close : request.security("BTCUSDT", timeframe.period, close, ignore_invalid_symbol=true)) : na
float btc_sma = i_cryptoModule and i_useBtcCorr and not na(btc_close) ? ta.sma(btc_close, 50) : na
int btc_trend = i_cryptoModule and not na(btc_close) and not na(btc_sma) ? (btc_close > btc_sma ? 1 : -1) : 0

// --- Open Interest Data ---
string oi_ticker = syminfo.ticker + "_OI"
float oi_data = i_cryptoModule and i_useOI ? request.security(oi_ticker, timeframe.period, close, ignore_invalid_symbol=true) : na
float oi_change = i_cryptoModule and i_useOI and not na(oi_data) ? ta.change(oi_data) : na
bool oi_bullish = i_cryptoModule and not na(oi_change) and oi_change > 0 and close > close[1]
bool oi_bearish = i_cryptoModule and not na(oi_change) and oi_change > 0 and close < close[1]

// --- Weekend Detection (only when crypto module enabled) ---
bool is_weekend = i_cryptoModule and i_useWeekend ? (dayofweek == dayofweek.saturday or dayofweek == dayofweek.sunday) : false

// --- HTF Trend Data (for Dashboard) ---
// PERFORMANCE: Security calls MUST be at global scope, not inside conditionals
// Gate by showDashboard and timeframe to skip unnecessary calls
string _htfTf = tf_in_minutes < 60 ? "240" : tf_in_minutes < 240 ? "D" : ""
bool _needHtfData = showDashboard and tf_in_minutes < 240
float htfClose = _needHtfData ? request.security(syminfo.tickerid, _htfTf, close, ignore_invalid_symbol=true) : na
float htfSma50 = _needHtfData ? request.security(syminfo.tickerid, _htfTf, ta.sma(close, 50), ignore_invalid_symbol=true) : na

// Premium/Discount Zone Calculation (ICT concept)
// Auto-scale lookback based on timeframe for optimal zone responsiveness
int zoneLookback = is_scalping ? 30 : is_swing ? 50 : 80
float zoneSwingHigh = ta.highest(high, zoneLookback)
float zoneSwingLow = ta.lowest(low, zoneLookback)
float zoneRange = zoneSwingHigh - zoneSwingLow
float zoneEquilibrium = zoneSwingLow + zoneRange * 0.5
bool inDiscount = close < zoneEquilibrium
bool inPremium = close > zoneEquilibrium
// OTE zones (62-79% Fibonacci retracement)
float oteLongTop = zoneSwingLow + zoneRange * 0.38    // 62% retracement from high
float oteLongBot = zoneSwingLow + zoneRange * 0.21    // 79% retracement from high
float oteShortBot = zoneSwingLow + zoneRange * 0.62   // 62% retracement from low
float oteShortTop = zoneSwingLow + zoneRange * 0.79   // 79% retracement from low
bool inOteLong = close >= oteLongBot and close <= oteLongTop
bool inOteShort = close >= oteShortBot and close <= oteShortTop

max_bars_back(atr, 600)
max_bars_back(avgBody, 600)

// Displacement checks are inlined in checkScalperCondition to avoid Pine consistency warnings.

// Alert flags
var bool newBullOB = false
var bool newBearOB = false
var bool bullTouch = false
var bool bearTouch = false
var bool bullReject = false
// Anti-spam latch for OB Touch alerts - persist across bars (NOT reset each bar)
var bool wasInBullOB = false
var bool wasInBearOB = false
var bool bearReject = false

// Proximity alert flags
var bool nearBullOB = false
var bool nearBearOB = false
var bool wasNearBullOB = false  // State tracking to prevent spam
var bool wasNearBearOB = false

// Liquidity sweep alert flags
var bool bullSweepDetected = false
var bool bearSweepDetected = false
var bool bullRunDetected = false
var bool bearRunDetected = false
var bool nearBSL = false
var bool nearSSL = false
// Anti-spam latch for proximity alerts - persist across bars (NOT reset each bar)
var bool wasNearBSL = false
var bool wasNearSSL = false

bool showAnyLabel = showVolLabel or showStrength or showRetests

newBullOB := false
newBearOB := false
bullTouch := false
bearTouch := false
bullReject := false
bearReject := false
nearBullOB := false
nearBearOB := false
bullSweepDetected := false
bearSweepDetected := false
bullRunDetected := false
bearRunDetected := false
nearBSL := false
nearSSL := false

// === VALIDATION FUNCTIONS ===
checkDisplacement(int idx, float threshold) =>
    // Used by Institutional method - now respects user's body/range threshold
    if idx < 0 or idx > bar_index
        false
    else
        float body = math.abs(close[idx] - open[idx])
        float candle_range = high[idx] - low[idx]
        bool strongBody = body > avgBody[idx] * threshold
        bool fullBodied = candle_range > 0 ? body / candle_range > dispBodyToRangeMin : false
        strongBody and fullBodied

checkFVG(int idx, string dir) =>
    // FVG (Fair Value Gap) = 3-candle pattern showing strong momentum
    //
    // CANDLE MAPPING (in Pine offset terms, higher = older):
    //   idx-2 = Most recent (continuation after gap)
    //   idx-1 = Middle (displacement/impulse that created gap)
    //   idx   = Oldest (order block candle before displacement)
    //
    // Bullish FVG: Price gaps UP, leaving unfilled zone
    //   - Check: low[idx-2] > high[idx]
    //   - Meaning: Recent candle's LOW is above old candle's HIGH (gap between them)
    //   - The gap was created by the middle candle (idx-1) jumping up
    //
    // Bearish FVG: Price gaps DOWN, leaving unfilled zone
    //   - Check: high[idx-2] < low[idx]
    //   - Meaning: Recent candle's HIGH is below old candle's LOW (gap between them)
    //   - The gap was created by the middle candle (idx-1) jumping down
    //
    // NOTE: If FVGs appear "off by 2 bars", this mapping may need adjustment

    // Check mode
    if fvgMode == "Off"
        true  // Always pass if FVG is off
    else
        // Bounds check: need idx-2 to be valid (closer to current bar)
        if idx < 2 or idx > bar_index
            false
        else
            bool hasGap = false
            float gapSize = 0.0

            if dir == "Bull"
                if fvgMode == "Strict (body gap)"
                    // Strict: require body gap (close vs open)
                    float recentLow = math.min(close[idx - 2], open[idx - 2])
                    float oldHigh = math.max(close[idx], open[idx])
                    hasGap := recentLow > oldHigh
                    gapSize := hasGap ? recentLow - oldHigh : 0.0
                else if fvgMode == "Loose (wick gap)"
                    // Loose: allow partial gaps (any separation)
                    hasGap := low[idx - 2] >= high[idx]
                    gapSize := hasGap ? low[idx - 2] - high[idx] : 0.0
                else  // Classic 3-candle
                    // Classic: wick gap (standard)
                    hasGap := low[idx - 2] > high[idx]
                    gapSize := hasGap ? low[idx - 2] - high[idx] : 0.0
            else  // Bear
                if fvgMode == "Strict (body gap)"
                    // Strict: require body gap
                    float recentHigh = math.max(close[idx - 2], open[idx - 2])
                    float oldLow = math.min(close[idx], open[idx])
                    hasGap := recentHigh < oldLow
                    gapSize := hasGap ? oldLow - recentHigh : 0.0
                else if fvgMode == "Loose (wick gap)"
                    // Loose: allow partial gaps
                    hasGap := high[idx - 2] <= low[idx]
                    gapSize := hasGap ? low[idx] - high[idx - 2] : 0.0
                else  // Classic 3-candle
                    // Classic: wick gap
                    hasGap := high[idx - 2] < low[idx]
                    gapSize := hasGap ? low[idx] - high[idx - 2] : 0.0

            // Apply minimum gap filter
            bool meetsMinGap = true
            if fvgMinGapAtr > 0.0 and hasGap
                meetsMinGap := gapSize > atr[idx] * fvgMinGapAtr

            hasGap and meetsMinGap

checkMSB(int pivotIdx, int dispIdx, int lookback, string dir) =>
    // Market Structure Break: Check if displacement candle broke recent swing structure
    // Scan backwards FROM displacement (excluding dispIdx itself) to find recent structure
    bool confirmed = false
    int scanStart = dispIdx + 1
    int scanEnd = math.min(dispIdx + lookback, bar_index)

    // Need at least one bar to check structure
    // pivotIdx must be within valid historical range for array access
    if pivotIdx < 0 or pivotIdx > bar_index or dispIdx < 0 or dispIdx > bar_index or scanStart > bar_index
        confirmed := false
    else
        if dir == "Bull"
            // Find highest high in lookback period BEFORE displacement (excluding dispIdx)
            // Initialize from first bar in scan range (NOT from dispIdx)
            float recentHigh = high[scanStart]

            // Scan remaining bars in lookback period (if any)
            if scanStart < scanEnd
                for i = scanStart + 1 to scanEnd
                    if high[i] > recentHigh
                        recentHigh := high[i]

            // Also consider pivot as minimum structure level (fallback) - user configurable
            if msbUsePivotFallback and high[pivotIdx] > recentHigh
                recentHigh := high[pivotIdx]

            // MSB confirmed if displacement broke above the recent structure
            if high[dispIdx] > recentHigh
                confirmed := true
        else
            // Find lowest low in lookback period BEFORE displacement (excluding dispIdx)
            // Initialize from first bar in scan range (NOT from dispIdx)
            float recentLow = low[scanStart]

            // Scan remaining bars in lookback period (if any)
            if scanStart < scanEnd
                for i = scanStart + 1 to scanEnd
                    if low[i] < recentLow
                        recentLow := low[i]

            // Also consider pivot as minimum structure level (fallback) - user configurable
            if msbUsePivotFallback and low[pivotIdx] < recentLow
                recentLow := low[pivotIdx]

            // MSB confirmed if displacement broke below the recent structure
            if low[dispIdx] < recentLow
                confirmed := true
    confirmed

// === LIQUIDITY SWEEP DETECTION FUNCTIONS ===
// Detect swing highs (potential BSL)
findSwingHigh(int leftBars, int rightBars) =>
    bool isSwing = false
    float level = na

    // Need enough history to validate both sides.
    if bar_index >= leftBars + rightBars
        isSwing := true
        level := high[rightBars]
        // Left side (older bars)
        for i = 1 to leftBars
            if high[rightBars + i] >= level
                isSwing := false
                break
        // Right side (newer bars) - must include current bar at index 0
        for i = 0 to rightBars - 1
            if high[i] >= level
                isSwing := false
                break

    [isSwing, level]

// Detect swing lows (potential SSL)
findSwingLow(int leftBars, int rightBars) =>
    bool isSwing = false
    float level = na

    // Need enough history to validate both sides.
    if bar_index >= leftBars + rightBars
        isSwing := true
        level := low[rightBars]
        // Left side (older bars)
        for i = 1 to leftBars
            if low[rightBars + i] <= level
                isSwing := false
                break
        // Right side (newer bars) - must include current bar at index 0
        for i = 0 to rightBars - 1
            if low[i] <= level
                isSwing := false
                break

    [isSwing, level]

// Check if new swing is "equal" to existing level (clustered liquidity = stronger)
isEqualLevel(float newLevel, float existingLevel, float thresholdPct) =>
    float diff = existingLevel != 0 ? math.abs(newLevel - existingLevel) / existingLevel * 100 : na
    not na(diff) and diff <= thresholdPct

// Check for bullish sweep (price sweeps SSL then reverses up)
checkBullishSweep(float sslLevel, float minWickAtr) =>
    bool swept = false
    float wickExtent = 0.0
    // Wick went below level but close stayed above
    if low < sslLevel and close > sslLevel
        wickExtent := sslLevel - low
        bool wickOk = wickExtent >= atr * minWickAtr
        bool volumeOk = not requireVolumeSpike or volume > avgVol
        swept := wickOk and volumeOk
    [swept, wickExtent]

// Check for bearish sweep (price sweeps BSL then reverses down)
checkBearishSweep(float bslLevel, float minWickAtr) =>
    bool swept = false
    float wickExtent = 0.0
    // Wick went above level but close stayed below
    if high > bslLevel and close < bslLevel
        wickExtent := high - bslLevel
        bool wickOk = wickExtent >= atr * minWickAtr
        bool volumeOk = not requireVolumeSpike or volume > avgVol
        swept := wickOk and volumeOk
    [swept, wickExtent]

// Check for bullish run (price takes SSL and CONTINUES down)
checkBullishRun(float sslLevel) =>
    bool isRun = false
    // Price broke below level AND closed below (continuation, not reversal)
    if low < sslLevel and close < sslLevel
        isRun := true
    isRun

// Check for bearish run (price takes BSL and CONTINUES up)
checkBearishRun(float bslLevel) =>
    bool isRun = false
    // Price broke above level AND closed above (continuation, not reversal)
    if high > bslLevel and close > bslLevel
        isRun := true
    isRun

// Sweep quality scoring
getSweepQuality(float wickExtent, bool volumeSpike, bool atOrderBlock, bool equalLevel) =>
    int score = 0
    if wickExtent > atr * 1.0
        score += 1  // Strong wick
    if volumeSpike
        score += 1  // Volume confirmation
    if atOrderBlock
        score += 1  // Near order block (confluence)
    if equalLevel
        score += 1  // Equal highs/lows (stronger liquidity)
    score >= 3 ? "Strong" : score >= 2 ? "Mid" : "Weak"

// === VOLUME PROFILE ANALYSIS (Premium Feature) ===
analyzeVolumeProfile(float obTop, float obBot, int lookback) =>
    // Calculate volume distribution in the order block zone
    // Optimized with early exit when sufficient samples collected
    float totalVol = 0.0
    float zoneVol = 0.0
    int barsInZone = 0
    int barsProcessed = 0

    // Confidence thresholds for early exit
    int minBarsForConfidence = 5
    int minBarsToProcess = 20

    int maxBars = math.min(lookback - 1, bar_index)

    // Analyze volume over lookback period with early exit
    for i = 0 to maxBars
        float barHigh = high[i]
        float barLow = low[i]
        float barVol = volume[i]

        totalVol += barVol
        barsProcessed += 1

        // Check if this bar's price range overlaps with order block zone
        bool overlaps = barLow <= obTop and barHigh >= obBot
        if overlaps
            // Calculate overlap percentage
            float overlapHigh = math.min(barHigh, obTop)
            float overlapLow = math.max(barLow, obBot)
            float barRange = barHigh - barLow

            if barRange > 0
                float overlapRatio = (overlapHigh - overlapLow) / barRange
                zoneVol += barVol * overlapRatio
                barsInZone += 1

        // Early exit: enough samples collected for confident estimate
        if barsInZone >= minBarsForConfidence and barsProcessed >= minBarsToProcess
            break

    // Calculate volume metrics using actual bars processed
    float avgVolPerBar = barsProcessed > 0 ? totalVol / barsProcessed : 0.0
    float zoneVolPerBar = barsInZone > 0 ? zoneVol / barsInZone : 0.0
    float volumeConcentration = avgVolPerBar > 0 ? zoneVolPerBar / avgVolPerBar : 0.0

    volumeConcentration

// === CRYPTO SCORE BOOST HELPER ===
// Returns score adjustment based on crypto market conditions
getCryptoScoreBoost(bool isBullOB, int barOffset) =>
    int boost = 0
    if not i_cryptoModule
        boost
    else
        // BTC Correlation (+1 for alignment) - only for altcoins
        if i_useBtcCorr and not is_btc_chart and btc_trend != 0
            if (isBullOB and btc_trend == 1) or (not isBullOB and btc_trend == -1)
                boost += 1

        // BTC.D Regime (+1 for favorable regime)
        if i_useBtcDom and btc_regime != 0
            if (isBullOB and btc_regime >= 0) or (not isBullOB and btc_regime <= 0)
                boost += 1

        // OI Confirmation (+1)
        if i_useOI and not na(oi_data)
            if (isBullOB and oi_bullish[barOffset]) or (not isBullOB and oi_bearish[barOffset])
                boost += 1

        // Weekend Penalty (-1)
        if i_useWeekend and is_weekend[barOffset]
            boost -= 1

        boost

getStrength(float vol, float body, bool trendAlign, bool isBullOB, int barOffset) =>
    int score = 0
    if useVolume and vol > avgVol * volScoreMult
        score += 1
    if body > avgBody * bodyScoreMult
        score += 1
    if trendAlign
        score += 1

    // Add crypto boost
    score += getCryptoScoreBoost(isBullOB, barOffset)

    score >= 2 ? "Strong" : score == 1 ? "Mid" : "Weak"

getEnhancedStrength(float vol, float body, bool trendAlign, float vpConcentration, bool isBullOB, int barOffset) =>
    int score = 0

    // Volume confirmation check (ICT: volume spike essential for institutional OBs)
    bool hasVolumeConfirmation = useVolume and vol > avgVol * volScoreMult

    // Base scoring (user-configurable)
    if hasVolumeConfirmation
        score += 1
    if body > avgBody * bodyScoreMult
        score += 1
    if trendAlign
        score += 1

    // Crypto boost (optional module)
    score += getCryptoScoreBoost(isBullOB, barOffset)

    // Volume Profile boost (Premium feature - user-configurable)
    bool hasVPConfirmation = useVolumeProfile and vpConcentration >= vpThreshold
    if hasVPConfirmation
        score += vpScoreBoost

    // Enhanced rating with VP (user can configure if Elite requires VP and/or Volume)
    // ICT methodology: Elite status should require volume confirmation
    bool volumeOkForElite = not eliteRequiresVolume or hasVolumeConfirmation
    bool vpOkForElite = not eliteRequiresVP or hasVPConfirmation

    if useVolumeProfile
        // Elite requires: score >= 3 AND volume check (if enabled) AND VP check (if enabled)
        if score >= 3 and volumeOkForElite and vpOkForElite
            "Elite"
        else
            score >= 2 ? "Strong" : score == 1 ? "Mid" : "Weak"
    else
        // Without VP module, Elite still requires volume if eliteRequiresVolume is enabled
        if score >= 3 and volumeOkForElite
            "Elite"
        else
            score >= 2 ? "Strong" : score == 1 ? "Mid" : "Weak"

// === PROXIMITY ALERT HELPER ===
findNearestOB(array<OrderBlock> blocks, bool isBull) =>
    // Find nearest qualifying order block within proximity threshold
    float nearestDist = 999999.0
    bool isNear = false

    int blockCount = array.size(blocks)
    if blockCount > 0
        for i = 0 to blockCount - 1
            OrderBlock b = array.get(blocks, i)

            // Skip mitigated blocks
            if b.mitigated
                continue

            // Apply quality filters
            if alertOnlyStrongBlocks and (b.strength != "Strong" and b.strength != "Elite")
                continue
            if alertOnlyFreshBlocks and b.retestCount > 0
                continue

            // Calculate distance from current price to zone
            float dist = 0.0
            if isBull
                // Bull OB: distance from current close to zone bottom (approaching from above)
                dist := close > b.bot ? (close - b.bot) / close * 100 : -1.0
            else
                // Bear OB: distance from zone top to current close (approaching from below)
                dist := close < b.top ? (b.top - close) / close * 100 : -1.0

            // Check if within threshold and not yet inside zone
            if dist > 0 and dist <= proximityThreshold
                // Check directional approach for more actionable signals
                bool correctDirection = true
                if requireDirectionalApproach
                    // Bull OB: price falling = potential bounce | Bear OB: price rising = potential rejection
                    correctDirection := isBull ? (close < open) : (close > open)

                if correctDirection and dist < nearestDist
                    nearestDist := dist
                    isNear := true

    [isNear, nearestDist]

// === SCALPER DETECTION METHOD (ICT/SMC - Correct Formula) ===
// Based on Inner Circle Trader methodology
// Order Block = Nearest opposite candle within 1-3 bars before the impulse candle
// Prioritizes recency: takes the most recent qualifying impulse, not just strongest
checkScalperCondition(int tuning) =>

    // Max candles to scan back from impulse to find opposite candle (user-adjustable)

    // BULL ORDER BLOCK: BEARISH candle before UPWARD impulse
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    bool bullOB = false
    int bullOBIdx = 0
    float bullImpulseStrength = 0.0  // Normalized: body/atr

    // BEAR ORDER BLOCK: BULLISH candle before DOWNWARD impulse
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    bool bearOB = false
    int bearOBIdx = 0
    float bearImpulseStrength = 0.0  // Normalized: body/atr

    // 1. Find the most recent qualifying impulse candles (single pass)
    int bullImpulseIdx = -1
    int bearImpulseIdx = -1
    int maxIdx = math.min(tuning - 1, bar_index)

    for i = 0 to maxIdx
        float body = math.abs(close[i] - open[i])
        float range_c = high[i] - low[i]
        float atrAtIdx = atr[i]  // Use ATR at the historical candle (atr series already calculated)
        bool sizeOk = body > atrAtIdx * dispAtrBodyMult
        bool dominanceOk = range_c > 0 ? body / range_c > dispBodyToRangeMin : false
        if sizeOk and dominanceOk
            if bullImpulseIdx == -1 and close[i] > open[i]
                bullImpulseIdx := i
            if bearImpulseIdx == -1 and close[i] < open[i]
                bearImpulseIdx := i
            if bullImpulseIdx != -1 and bearImpulseIdx != -1
                break

    // Determine effective window (Base + Adaptive extension)
    int maxScan = useAdaptiveScan ? effectiveScanWindow * 2 : effectiveScanWindow

    // 2. Scan 1-3 candles back from impulse to find nearest opposite (bearish) candle
    if bullImpulseIdx >= 0
        float impulseBody = close[bullImpulseIdx] - open[bullImpulseIdx]
        float atrAtImpulse = atr[bullImpulseIdx]  // Use ATR at impulse candle (from global atr series)
        bullImpulseStrength := atrAtImpulse > 0 ? impulseBody / atrAtImpulse : 0.0  // Normalized strength

        for j = 1 to maxScan
            int candidateIdx = bullImpulseIdx + j
            if candidateIdx > bar_index
                break

            // ADAPTIVE SCAN: In low volatility, we allow scanning further back
            // If checking past normal window, require strictly low volatility to accept it
            bool isExtendedScan = j > obScanWindow
            bool lowVolCondition = true
            if isExtendedScan
                // Simple low vol check: current range < average range
                lowVolCondition := (high[candidateIdx] - low[candidateIdx]) < atr[candidateIdx]

            if isExtendedScan and (not useAdaptiveScan or not lowVolCondition)
                break

            // Stop if we hit another qualifying displacement candle (same full predicate)
            float body = math.abs(close[candidateIdx] - open[candidateIdx])
            float range_c = high[candidateIdx] - low[candidateIdx]
            float atrAtIdx = atr[candidateIdx]  // Use ATR at the historical candle (atr series already calculated)
            bool sizeOk = body > atrAtIdx * dispAtrBodyMult
            bool dominanceOk = range_c > 0 ? body / range_c > dispBodyToRangeMin : false
            bool dispBull = sizeOk and dominanceOk and close[candidateIdx] > open[candidateIdx]
            bool dispBear = sizeOk and dominanceOk and close[candidateIdx] < open[candidateIdx]
            if dispBull or dispBear
                break
            // Check if this candle is bearish (opposite to bullish impulse)
            if close[candidateIdx] < open[candidateIdx]
                bullOBIdx := candidateIdx
                bullOB := true
                break

    // 2. Scan 1-3 candles back from impulse to find nearest opposite (bullish) candle
    if bearImpulseIdx >= 0
        float bearImpBody = open[bearImpulseIdx] - close[bearImpulseIdx]
        float atrAtBearImpulse = atr[bearImpulseIdx]  // Use ATR at impulse candle (from global atr series)
        bearImpulseStrength := atrAtBearImpulse > 0 ? bearImpBody / atrAtBearImpulse : 0.0  // Normalized strength

        for j = 1 to maxScan
            int candidateIdx = bearImpulseIdx + j
            if candidateIdx > bar_index
                break

            // ADAPTIVE SCAN: In low volatility, we allow scanning further back
            bool isExtendedScan = j > obScanWindow
            bool lowVolCondition = true
            if isExtendedScan
                lowVolCondition := (high[candidateIdx] - low[candidateIdx]) < atr[candidateIdx]

            if isExtendedScan and (not useAdaptiveScan or not lowVolCondition)
                break

            // Stop if we hit another qualifying displacement candle
            float body = math.abs(close[candidateIdx] - open[candidateIdx])
            float range_c = high[candidateIdx] - low[candidateIdx]
            float atrAtIdx = atr[candidateIdx]  // Use ATR at the historical candle (atr series already calculated)
            bool sizeOk = body > atrAtIdx * dispAtrBodyMult
            bool dominanceOk = range_c > 0 ? body / range_c > dispBodyToRangeMin : false
            bool dispBull = sizeOk and dominanceOk and close[candidateIdx] > open[candidateIdx]
            bool dispBear = sizeOk and dominanceOk and close[candidateIdx] < open[candidateIdx]
            if dispBull or dispBear
                break
            // Check if this candle is bullish (opposite to bearish impulse)
            if close[candidateIdx] > open[candidateIdx]
                bearOBIdx := candidateIdx
                bearOB := true
                break

    [bearOB, bullOB, bearOBIdx, bullOBIdx, bearImpulseStrength, bullImpulseStrength]

// === VISUAL GENERATION ===
createVolumeGradient(OrderBlock block, int leftBar, int segments, string rMode) =>
    boxArray = array.new<box>()

    // Check render mode (uses effective settings)
    if rMode == "Gradient"
        // Create elegant gradient layers with edge-to-center fading
        float blockHeight = block.top - block.bot
        // Ensure segments is at least 2 to prevent division by zero
        int safeSegments = math.max(segments, 2)
        float segmentHeight = blockHeight / safeSegments  // Pre-compute loop invariant
        int lastSegment = safeSegments - 1                // Pre-compute loop invariant
        float invLastSegment = 1.0 / lastSegment          // Pre-compute for progress calculation (safe: lastSegment >= 1)
        bool isStrong = block.strength == "Strong" or block.strength == "Elite"

        // Base colors
        color baseCol = block.direction == DIR_BULL ? bullBorder : bearBorder

        // Use bar_index instead of time for boxes to avoid xloc issues
        int leftBarIdx = leftBar
        int rightBarIdx = bar_index + 1  // +1 to extend through forming candle

        // Create multiple gradient layers for smooth visual
        for i = 0 to lastSegment
            float topGrid = block.top - segmentHeight * i
            float botGrid = block.top - segmentHeight * (i + 1)

            // Edge-to-center gradient (strongest in middle)
            float progress = i * invLastSegment
            float centerWeight = 1.0 - math.abs(progress - 0.5) * 2.0  // Peak at center

            // Elegant transparency gradient
            // Strong/Elite: more visible (70-95), Weak/Mid: much lighter (88-95)
            int alpha = isStrong ?
                 int(70 + centerWeight * 25) :  // More visible for strong/elite
                 int(88 + centerWeight * 7)      // Much lighter for weak/mid

            color layerCol = color.new(baseCol, alpha)

            // Full-width boxes using bar_index (default xloc)
            box newBox = box.new(leftBarIdx, topGrid, rightBarIdx, botGrid,
                 border_width=0, bgcolor=layerCol)
            array.push(boxArray, newBox)

    else if rMode == "Simple fill"
        // Simple mode: single fill box (much fewer objects)
        color baseCol = block.direction == DIR_BULL ? bullBorder : bearBorder
        bool isStrong = block.strength == "Strong" or block.strength == "Elite"
        // Strong/Elite use fillAlpha, Weak/Mid are much lighter (90)
        int simpleAlpha = isStrong ? fillAlpha : 90
        color fillCol = color.new(baseCol, simpleAlpha)
        int leftBarIdx = leftBar
        int rightBarIdx = bar_index + 1  // +1 to extend through forming candle

        box fillBox = box.new(leftBarIdx, block.top, rightBarIdx, block.bot,
             border_width=0, bgcolor=fillCol)
        array.push(boxArray, fillBox)
    // else "Borders only" - no fill boxes created

    boxArray

createBorder(OrderBlock block, int leftBar, string rMode) =>
    color baseCol = block.direction == DIR_BULL ? bullBorder : bearBorder

    // Top line (full length, subtle) - use bar_index for real-time extension
    color mainLineCol = color.new(baseCol, 30)
    int rightBarIdx = bar_index + 1  // +1 to extend through forming candle
    line topLine = line.new(x1=leftBar, y1=block.top, x2=rightBarIdx, y2=block.top,
         xloc=xloc.bar_index, color=mainLineCol, width=1, style=line.style_dotted)

    // Bottom line (full length, subtle)
    line botLine = line.new(x1=leftBar, y1=block.bot, x2=rightBarIdx, y2=block.bot,
         xloc=xloc.bar_index, color=mainLineCol, width=1, style=line.style_dotted)

    // Glow effect for strong blocks (multiple transparent fills) - only if not "Borders only"
    linefill fill = na

    if rMode != "Borders only"
        if block.strength == "Strong" or block.strength == "Elite"
            // Add glow with gradient fill
            color glowCol = color.new(baseCol, 85)
            fill := linefill.new(topLine, botLine, glowCol)
        else
            // Much lighter fill for Weak/Mid blocks (alpha 90 for subtlety)
            color fillCol = color.new(baseCol, 90)
            fill := linefill.new(topLine, botLine, fillCol)

    [topLine, botLine, fill]

createCornerAccents(OrderBlock block, int leftBar, string rMode) =>
    // Create elegant corner markers
    corners = array.new<box>()

    // Only create corners if enabled, for Strong/Elite blocks, and not in Borders only mode
    if showCornerAccents and (block.strength == "Strong" or block.strength == "Elite") and rMode != "Borders only"
        color accentCol = block.direction == DIR_BULL ? bullBorder : bearBorder
        float blockHeight = block.top - block.bot
        float cornerHeight = blockHeight * 0.15  // 15% of block height
        int cornerWidth = 6  // 6 bars width

        // Use bar_index for corners
        int leftBarIdx = leftBar
        int rightBarIdx = leftBarIdx + cornerWidth

        // Top-left corner
        box tlCorner = box.new(leftBarIdx, block.top,
             rightBarIdx, block.top - cornerHeight,
             border_color=accentCol, border_width=2, bgcolor=color.new(accentCol, 70))
        array.push(corners, tlCorner)

        // Bottom-left corner
        box blCorner = box.new(leftBarIdx, block.bot + cornerHeight,
             rightBarIdx, block.bot,
             border_color=accentCol, border_width=2, bgcolor=color.new(accentCol, 70))
        array.push(corners, blCorner)

    corners

buildLabelText(OrderBlock block) =>
    string labelText = ""

    // Strength indicator (using elegant symbols)
    if showStrength
        if block.strength == "Elite"
            labelText += "â˜… "
        else if block.strength == "Strong"
            labelText += "â—† "
        else if block.strength == "Mid"
            labelText += "â—‡ "
        else
            labelText += "â—‹ "

    // Volume
    if showVolLabel
        labelText += formatVolume(block.totalVolume)

    // Retest count with elegant format
    if showRetests and block.retestCount > 0
        labelText += "\n" + str.tostring(block.retestCount) + "Ã— TEST"

    // Status indicator
    if block.rejected
        labelText += block.direction == DIR_BULL ? "\nâ†— BOUNCE" : "\nâ†˜ REJECT"
    else if block.touched
        labelText += "\nâ— ACTIVE"

    labelText

// === LIQUIDITY SWEEP VISUAL FUNCTIONS ===
// Create horizontal level line for liquidity pool
createLiquidityLevel(float level, int startBar, bool isBSL) =>
    color levelCol = isBSL ? bslColor : sslColor
    line levelLine = line.new(startBar, level, bar_index, level,
         xloc=xloc.bar_index, color=levelCol, width=1, style=line.style_dashed)
    levelLine

// Create sweep event highlight box
createSweepBox(float level, float wickExtent, int sweepBar, bool isBullish) =>
    color boxCol = isBullish ? sweepBullColor : sweepBearColor
    float top = isBullish ? level : level + wickExtent
    float bot = isBullish ? level - wickExtent : level
    box sweepBox = box.new(sweepBar - 1, top, sweepBar + 2, bot,
         border_color=boxCol, border_width=2, bgcolor=color.new(boxCol, 80))
    sweepBox

// Create sweep label
createSweepLabel(float level, float wickExtent, int sweepBar, bool isBullish, string quality) =>
    string txt = (isBullish ? "SWEEP â†—" : "SWEEP â†˜") + "\n" + quality
    color txtCol = isBullish ? sweepBullColor : sweepBearColor
    // Position label above (bearish) or below (bullish) the wick
    float labelPrice = isBullish ? level - wickExtent : level + wickExtent
    label lbl = label.new(sweepBar, labelPrice, txt, xloc=xloc.bar_index, yloc=yloc.price,
         color=color.new(#1a1a1a, 15), style=isBullish ? label.style_label_up : label.style_label_down, textcolor=txtCol, size=size.small)
    lbl

createVolumeLabel(OrderBlock block) =>
    // Create elegant side panel label
    float labelY = block.top - (block.top - block.bot) * 0.25  // Upper quarter position

    // Elegant label styling with dark background and colored accent
    color bgCol = color.new(#1a1a1a, 15)  // Dark semi-transparent background
    color textCol = block.direction == DIR_BULL ? bullBorder : bearBorder

    // Create elegant label with dark bg and vibrant text
    // Use bar_index + 1 so label extends through forming candle (matches box behavior)
    label lbl = label.new(bar_index + 1, labelY, buildLabelText(block), xloc.bar_index, yloc.price, bgCol, label.style_label_left, textCol, size.small)

    lbl

deleteBlock(OrderBlock block) =>
    if not na(block.topLine)
        line.delete(block.topLine)
    if not na(block.botLine)
        line.delete(block.botLine)
    if not na(block.bgFill)
        linefill.delete(block.bgFill)
    if not na(block.volLabel)
        label.delete(block.volLabel)

    int volBoxCount = array.size(block.volumeBoxes)
    if volBoxCount > 0
        for i = 0 to volBoxCount - 1
            box.delete(array.get(block.volumeBoxes, i))

    int cornerCount = array.size(block.cornerBoxes)
    if cornerCount > 0
        for i = 0 to cornerCount - 1
            box.delete(array.get(block.cornerBoxes, i))

// PERFORMANCE OPTIMIZED: Combined single-pass processing
// Merges processBlocks + updateBlocks + isInAnyBlock into ONE iteration
// Returns: [touched, rejected, isInAny]
processAndUpdateBlocks(array<OrderBlock> blocks, bool isBull, int segments, int currentTime) =>
    bool touched = false
    bool rejected = false
    bool isInAny = false

    int blockCount = array.size(blocks)
    if blockCount > 0
        // Pre-compute mode checks outside loop (avoid repeated string comparisons)
        bool useWickMode = touchMode == "Wick"
        bool isNewBar = barstate.isnew or barstate.isfirst
        int safeSegments = math.max(segments, 1)

        for i = blockCount - 1 to 0
            OrderBlock block = array.get(blocks, i)

            // --- VISUAL UPDATE (from updateBlock) ---
            // Extend boxes to bar_index + 1 so they cover the forming candle
            // This runs every tick to ensure real-time extension
            int extendToBar = bar_index + 1  // +1 to extend through forming candle

            // Extend all volume boxes to current bar + 1
            int volBoxCount = array.size(block.volumeBoxes)
            if volBoxCount > 0
                int maxIdx = math.min(safeSegments - 1, volBoxCount - 1)
                for j = 0 to maxIdx
                    box.set_right(array.get(block.volumeBoxes, j), extendToBar)

            // Update label position every tick (uses bar_index now, not time)
            if not na(block.volLabel)
                label.set_x(block.volLabel, extendToBar)

            // Update border lines every tick (uses bar_index now for uniform extension)
            if not na(block.topLine)
                line.set_x2(block.topLine, extendToBar)
            if not na(block.botLine)
                line.set_x2(block.botLine, extendToBar)

            if isNewBar
                block.lastUpdateBar := bar_index

            if not block.mitigated
                // --- MITIGATION CHECK ---
                bool mitigated = false
                float zoneHeight = block.top - block.bot
                float minPenetration = math.max(zoneHeight * minPenZonePct, atr * minPenAtrPct)

                if mitigationMethod == "Wick"
                    mitigated := isBull ? low < block.bot - minPenetration : high > block.top + minPenetration
                else if mitigationMethod == "Close"
                    mitigated := isBull ? close < block.bot : close > block.top
                else  // Mean
                    float mean = block.bot + (zoneHeight * meanMitigationLevel)
                    mitigated := isBull ? close < mean : close > mean

                if mitigated
                    block.mitigated := true
                    deleteBlock(block)
                    array.remove(blocks, i)
                    continue

                // --- TOUCH/ZONE CHECK (also computes isInAny) ---
                bool inZone = useWickMode ? (low <= block.top and high >= block.bot) : (close >= block.bot and close <= block.top)

                if inZone
                    isInAny := true  // For isInAnyBlock functionality
                    if retestDebounce == "Require exit before recount"
                        if not block.touched
                            block.touched := true
                            block.retestCount += 1
                            touched := true
                    else  // "Count each bar in zone"
                        block.retestCount += 1
                        touched := true
                        block.touched := true
                else
                    if block.touched
                        block.touched := false

                // --- REJECTION CHECK ---
                if enableRejection
                    float rejectionLevel = 0.0

                    if rejectionCloseLevel == "Mid"
                        rejectionLevel := (block.top + block.bot) / 2
                    else if rejectionCloseLevel == "Top/Bottom"
                        rejectionLevel := isBull ? block.top : block.bot
                    else  // "Percent into zone"
                        rejectionLevel := isBull ? (block.bot + (zoneHeight * rejectionPercent)) : (block.top - (zoneHeight * rejectionPercent))

                    if isBull
                        if low <= block.bot and close >= rejectionLevel
                            if not block.rejected
                                block.rejected := true
                                rejected := true
                    else
                        if high >= block.top and close <= rejectionLevel
                            if not block.rejected
                                block.rejected := true
                                rejected := true

                // --- LABEL UPDATE (only on state change) ---
                if showAnyLabel and not na(block.volLabel)
                    bool stateChanged = block.retestCount != block.lastRetestCount or
                                       block.touched != block.lastTouched or
                                       block.rejected != block.lastRejected
                    if stateChanged
                        float labelY = block.top - (block.top - block.bot) * 0.25
                        label.set_y(block.volLabel, labelY)
                        label.set_text(block.volLabel, buildLabelText(block))
                        block.lastRetestCount := block.retestCount
                        block.lastTouched := block.touched
                        block.lastRejected := block.rejected

    [touched, rejected, isInAny]

trimBlocks(array<OrderBlock> blocks, int maxCount) =>
    if array.size(blocks) > maxCount
        deleteBlock(array.shift(blocks))

createOrderBlock(int idx, bool isBull, array<OrderBlock> blocks, bool shouldCreate) =>
    bool created = false
    if shouldCreate and idx > 0 and idx <= bar_index
        float top = high[idx]
        float bot = low[idx]

        // Smart sizing - now configurable with ICT-aligned anchoring
        bool applySmartSizing = blockSizing == "Smart" and (smartSizingAppliesTo == "All timeframes" or is_scalping)
        if applySmartSizing
            float minZoneHeight = syminfo.mintick
            float safeAtr = na(atr) ? math.max(high[idx] - low[idx], minZoneHeight) : atr
            if isBull
                // BULLISH OB: Anchor from BOTTOM (demand zone)
                // Zone sits near low/open where institutions accumulated
                float anchorBot = smartAnchor == "Wick" ? low[idx] : math.min(open[idx], close[idx])
                bot := anchorBot
                float maxTop = math.min(high[idx], anchorBot + safeAtr * smartSizeAtrMult)
                top := math.max(maxTop, bot + minZoneHeight)
            else
                // BEARISH OB: Anchor from TOP (supply zone)
                // Zone sits near high/open where institutions distributed
                float anchorTop = smartAnchor == "Wick" ? high[idx] : math.max(open[idx], close[idx])
                top := anchorTop
                float minBot = math.max(low[idx], anchorTop - safeAtr * smartSizeAtrMult)
                bot := math.min(minBot, top - minZoneHeight)
        else if blockSizing == "Body Only"
            top := math.max(open[idx], close[idx])
            bot := math.min(open[idx], close[idx])

        float vol = volume[idx]
        bool aligned = isBull ? close[idx] > sma50[idx] : close[idx] < sma50[idx]
        float body = math.abs(close[idx] - open[idx])

        // Volume Profile analysis (Premium feature)
        float vpConcentration = useVolumeProfile ? analyzeVolumeProfile(top, bot, vpLookbackEff) : 0.0

        // Enhanced strength with VP and crypto boost
        string strength = useVolumeProfile ?
             getEnhancedStrength(vol, body, aligned, vpConcentration, isBull, idx) :
             getStrength(vol, body, aligned, isBull, idx)

        // Filter: Skip weak/mid blocks if only showing Strong/Elite
        bool skipNewBlock = showOnlyStrongElite and strength != "Strong" and strength != "Elite"

        // Handle overlapping blocks - keep higher quality
        // Single-pass with deferred batch deletion (O(N) instead of O(NÂ²))
        int newScore = strengthScore(strength)
        int[] indicesToRemove = array.new<int>()

        int blockCount = array.size(blocks)
        if blockCount > 0
            for i = 0 to blockCount - 1
                OrderBlock b = array.get(blocks, i)
                bool overlaps = math.max(b.bot, bot) <= math.min(b.top, top)
                if overlaps
                    if strengthScore(b.strength) >= newScore
                        skipNewBlock := true
                        break
                    else
                        array.push(indicesToRemove, i)

        // Batch removal in reverse order (preserves indices)
        if not skipNewBlock
            int removeCount = array.size(indicesToRemove)
            if removeCount > 0
                for j = removeCount - 1 to 0
                    int idx_to_remove = array.get(indicesToRemove, j)
                    deleteBlock(array.get(blocks, idx_to_remove))
                    array.remove(blocks, idx_to_remove)

            int leftBar = bar_index - idx

            // Guard against na/inf for relative volume
            float relVol = (not na(avgVol) and avgVol > 0) ? vol / avgVol : 1.0
            int direction = isBull ? DIR_BULL : DIR_BEAR

            // PERFORMANCE: Pre-format volume string (avoids repeated formatting in dashboard)
            string fmtVol = formatVolume(vol)

            // Create new block
            OrderBlock newBlock = OrderBlock.new(
                 array.new<box>(), na, na, na, na, array.new<box>(),  // volumeBoxes, lines, fill, label, corners
                 top, bot, direction,
                 vol, relVol, strength, false, 0, false, false,
                 na, 0, false, false, fmtVol)  // State tracking + cached formattedVol

            box[] volBoxes = createVolumeGradient(newBlock, leftBar, effectiveGridSegments, effectiveRenderMode)
            newBlock.volumeBoxes := volBoxes

            [topLine, botLine, fill] = createBorder(newBlock, leftBar, effectiveRenderMode)
            newBlock.topLine := topLine
            newBlock.botLine := botLine
            newBlock.bgFill := fill

            // Add corner accents
            newBlock.cornerBoxes := createCornerAccents(newBlock, leftBar, effectiveRenderMode)

            // Create label if any label feature is enabled
            if showAnyLabel
                label lbl = createVolumeLabel(newBlock)
                newBlock.volLabel := lbl

            array.push(blocks, newBlock)
            created := true

    created

// === LIQUIDITY SWEEP HELPER FUNCTIONS ===
// Delete liquidity sweep visuals
deleteLiquiditySweep(LiquiditySweep sweep) =>
    if not na(sweep.levelLine)
        line.delete(sweep.levelLine)
    if not na(sweep.sweepBox)
        box.delete(sweep.sweepBox)
    if not na(sweep.sweepLabel)
        label.delete(sweep.sweepLabel)

// Update liquidity level line
updateLiquidityLevel(LiquiditySweep sweep) =>
    if not na(sweep.levelLine) and not sweep.swept and not sweep.ranThrough
        line.set_x2(sweep.levelLine, bar_index)

// Create liquidity level entry with equal H/L check
createLiquidityLevelEntry(float level, int levelBar, bool isBSL, array<LiquiditySweep> levels, bool createVisualLine) =>
    bool isEqual = false

    // Check existing levels for "equality" (clustered stops)
    int levelCount = array.size(levels)
    if markEqualHL and levelCount > 0
        for i = 0 to levelCount - 1
            LiquiditySweep existing = array.get(levels, i)
            if isEqualLevel(level, existing.level, equalHLThreshold)
                isEqual := true
                existing.isEqual := true  // Mark existing as equal too
                break

    // Create level line only if requested
    line levelLine = na
    if createVisualLine
        levelLine := createLiquidityLevel(level, levelBar, isBSL)

    // Create LiquiditySweep object
    int direction = isBSL ? DIR_BEAR : DIR_BULL  // BSL breaks bearish, SSL breaks bullish
    LiquiditySweep newLevel = LiquiditySweep.new(
         levelLine, na, na, level, levelBar, direction, isEqual,
         false, false, 0, 0.0, 0.0, "", false, 0, bar_index)

    array.push(levels, newLevel)

// Process sweeps and runs for liquidity levels
// Returns: [sweepDetected, runDetected, sweepBar]
// NOTE: Detection is decoupled from visuals - sweeps/runs are always detected when conditions met,
//       but visuals (boxes/labels) are only created when showSweepEvents is true.
//       This enables alerts-only mode (alerts fire without any visual clutter).
processSweepsAndRuns(array<LiquiditySweep> levels, bool isBSL) =>
    bool sweepDetected = false
    bool runDetected = false
    int sweepBar = 0

    int levelCount = array.size(levels)
    if levelCount > 0
        for i = levelCount - 1 to 0
            LiquiditySweep sweep = array.get(levels, i)

            // Skip if already swept or run
            if sweep.swept or sweep.ranThrough
                continue

            if isBSL
                // Check for bearish sweep (BSL taken, price reverses down)
                [detected, wickExt] = checkBearishSweep(sweep.level, sweepWickMin)
                if detected
                    // Always update state (detection decoupled from visuals)
                    sweep.swept := true
                    sweep.sweepBar := bar_index
                    sweep.sweepWick := wickExt
                    sweep.sweepClose := close

                    // Check confluence with order blocks
                    bool nearOB = false
                    int bullBlockCount = array.size(bullBlocks)
                    if bullBlockCount > 0
                        for j = 0 to bullBlockCount - 1
                            OrderBlock b = array.get(bullBlocks, j)
                            if math.abs(sweep.level - b.top) / sweep.level * 100 < 0.5
                                nearOB := true
                                break

                    // Calculate quality
                    bool volSpike = volume > avgVol
                    sweep.quality := getSweepQuality(wickExt, volSpike, nearOB, sweep.isEqual)

                    // Only create visuals when showSweepEvents is enabled
                    if showSweepEvents
                        sweep.sweepBox := createSweepBox(sweep.level, wickExt, bar_index, false)
                        sweep.sweepLabel := createSweepLabel(sweep.level, wickExt, bar_index, false, sweep.quality)

                    sweepDetected := true
                    sweepBar := bar_index
                else
                    // Check for bearish run (BSL taken, price continues up)
                    bool detected2 = checkBearishRun(sweep.level)
                    if detected2
                        // Always update state (detection decoupled from visuals)
                        sweep.ranThrough := true
                        sweep.sweepBar := bar_index
                        runDetected := true
            else
                // Check for bullish sweep (SSL taken, price reverses up)
                [detected, wickExt] = checkBullishSweep(sweep.level, sweepWickMin)
                if detected
                    // Always update state (detection decoupled from visuals)
                    sweep.swept := true
                    sweep.sweepBar := bar_index
                    sweep.sweepWick := wickExt
                    sweep.sweepClose := close

                    // Check confluence with order blocks
                    bool nearOB = false
                    int bearBlockCount = array.size(bearBlocks)
                    if bearBlockCount > 0
                        for j = 0 to bearBlockCount - 1
                            OrderBlock b = array.get(bearBlocks, j)
                            if math.abs(sweep.level - b.bot) / sweep.level * 100 < 0.5
                                nearOB := true
                                break

                    // Calculate quality
                    bool volSpike = volume > avgVol
                    sweep.quality := getSweepQuality(wickExt, volSpike, nearOB, sweep.isEqual)

                    // Only create visuals when showSweepEvents is enabled
                    if showSweepEvents
                        sweep.sweepBox := createSweepBox(sweep.level, wickExt, bar_index, true)
                        sweep.sweepLabel := createSweepLabel(sweep.level, wickExt, bar_index, true, sweep.quality)

                    sweepDetected := true
                    sweepBar := bar_index
                else
                    // Check for bullish run (SSL taken, price continues down)
                    bool detected2 = checkBullishRun(sweep.level)
                    if detected2
                        // Always update state (detection decoupled from visuals)
                        sweep.ranThrough := true
                        sweep.sweepBar := bar_index
                        runDetected := true

    [sweepDetected, runDetected, sweepBar]

// Update all liquidity levels
updateLiquidityLevels(array<LiquiditySweep> levels) =>
    int levelCount = array.size(levels)
    if levelCount > 0
        for i = 0 to levelCount - 1
            updateLiquidityLevel(array.get(levels, i))

// Trim old liquidity levels
trimLevels(array<LiquiditySweep> levels, int maxCount) =>
    if array.size(levels) > maxCount
        // Remove oldest swept/run levels first
        for i = array.size(levels) - 1 to 0
            if array.size(levels) <= maxCount
                break
            LiquiditySweep sweep = array.get(levels, i)
            if sweep.swept or sweep.ranThrough
                deleteLiquiditySweep(sweep)
                array.remove(levels, i)

        // If still too many, remove oldest
        while array.size(levels) > maxCount
            deleteLiquiditySweep(array.shift(levels))

// Check proximity to liquidity levels
checkLiquidityProximity(array<LiquiditySweep> levels, bool isBSL) =>
    bool isNear = false
    int levelCount = array.size(levels)
    if levelCount > 0
        for i = 0 to levelCount - 1
            LiquiditySweep sweep = array.get(levels, i)
            if sweep.swept or sweep.ranThrough
                continue

            float dist = 0.0
            if isBSL
                dist := sweep.level > close ? (sweep.level - close) / close * 100 : -1.0
            else
                dist := sweep.level < close ? (close - sweep.level) / close * 100 : -1.0

            if dist > 0 and dist <= liquidityProximityPct
                isNear := true
                break
    isNear

// === DETECTION LOGIC ===
bool validBull = false
bool validBear = false
int scalperBullIdx = 0
int scalperBearIdx = 0

// === PERFORMANCE: Skip detection on intrabar ticks in Confirmed mode ===
// OBs only form on bar close, so detection calculations are wasted on every tick
// Realtime mode: run detection every tick (for live feedback)
// Confirmed mode: only run detection on bar close (significant CPU savings)
bool shouldRunDetection = signalTiming == "Realtime (intrabar)" or barstate.isconfirmed

// Pre-compute filter results only when needed (Institutional method + filter enabled)
// Scalper method doesn't use these filters, so skip computation entirely
bool hasDisplacement = false
bool hasBullFVG = false
bool hasBearFVG = false
bool hasBullMSB = false
bool hasBearMSB = false

if shouldRunDetection and detectionMethod == "Institutional"
    if useDisplacement
        hasDisplacement := checkDisplacement(actualLookback - 1, dispMagnitude)
    if actualFVG
        hasBullFVG := checkFVG(actualLookback, "Bull")
        hasBearFVG := checkFVG(actualLookback, "Bear")
    if actualMSB
        hasBullMSB := checkMSB(actualLookback, actualLookback - 1, actualMsbPeriod, "Bull")
        hasBearMSB := checkMSB(actualLookback, actualLookback - 1, actualMsbPeriod, "Bear")

if shouldRunDetection and detectionMethod == "Scalper"
    // === SCALPER DETECTION (ICT/SMC Method - Candle immediately before impulse) ===
    [scalperBear, scalperBull, bearIdx, bullIdx, bearImpStr, bullImpStr] = checkScalperCondition(scalperLookback)
    validBull := scalperBull
    validBear := scalperBear
    scalperBullIdx := bullIdx
    scalperBearIdx := bearIdx

    // Mutual exclusivity: if both trigger, pick the one with stronger IMPULSE candle
    if validBull and validBear
        // Compare impulse candle strength (not OB candle)
        if bullImpStr >= bearImpStr
            validBear := false
        else
            validBull := false
else if shouldRunDetection
    // === INSTITUTIONAL DETECTION (Pivot-based with filters - stricter) ===
    bool isPivotLow = false
    bool isPivotHigh = false

    // Early-bars guard: need at least actualLookback * 2 bars of history
    if bar_index >= actualLookback * 2
        isPivotLow := true
        isPivotHigh := true

        for i = 1 to actualLookback
            if low[actualLookback] >= low[actualLookback + i] or low[actualLookback] >= low[actualLookback - i]
                isPivotLow := false
            if high[actualLookback] <= high[actualLookback + i] or high[actualLookback] <= high[actualLookback - i]
                isPivotHigh := false
            // Early exit if both already failed
            if not isPivotLow and not isPivotHigh
                break

    // Validation
    validBull := isPivotLow
    validBear := isPivotHigh

    // Filter: Displacement (use pre-computed values)
    if useDisplacement
        if validBull and close[actualLookback - 1] <= open[actualLookback - 1]
            validBull := false
        if validBear and close[actualLookback - 1] >= open[actualLookback - 1]
            validBear := false

        if validBull and not hasDisplacement
            validBull := false
        if validBear and not hasDisplacement
            validBear := false

    // Filter: FVG (use pre-computed values)
    if actualFVG
        if validBull and not hasBullFVG
            validBull := false
        if validBear and not hasBearFVG
            validBear := false

    // Filter: MSB (use pre-computed values)
    if actualMSB
        if validBull and not hasBullMSB
            validBull := false
        if validBear and not hasBearMSB
            validBear := false

// === CREATE ORDER BLOCKS ===
bool shouldCreateBull = barstate.isconfirmed and validBull
bool shouldCreateBear = barstate.isconfirmed and validBear
int bullIdx = detectionMethod == "Scalper" ? scalperBullIdx : actualLookback
int bearIdx = detectionMethod == "Scalper" ? scalperBearIdx : actualLookback
newBullOB := createOrderBlock(bullIdx, true, bullBlocks, shouldCreateBull)
newBearOB := createOrderBlock(bearIdx, false, bearBlocks, shouldCreateBear)

// === UPDATE & MITIGATION (OPTIMIZED: Single-pass processing) ===
// PERFORMANCE: Combined update + process + isInAny check into single iteration
// Reduces 5 array iterations to 2 (one per side)
[bullTouchTmp, bullRejectTmp, inBullOBNow] = processAndUpdateBlocks(bullBlocks, true, effectiveGridSegments, time)
bullTouch := bullTouchTmp
bullReject := bullRejectTmp
[bearTouchTmp, bearRejectTmp, inBearOBNow] = processAndUpdateBlocks(bearBlocks, false, effectiveGridSegments, time)
bearTouch := bearTouchTmp
bearReject := bearRejectTmp

// === OB TOUCH ANTI-SPAM LATCH ===
// inBullOBNow and inBearOBNow now come from the combined function above

// Edge-trigger: fire alert only on FIRST entry into any OB zone of that side
bool bullTouchTrigger = inBullOBNow and not wasInBullOB
bool bearTouchTrigger = inBearOBNow and not wasInBearOB

// Update latch state (must persist across bars, NOT reset each bar)
wasInBullOB := inBullOBNow
wasInBearOB := inBearOBNow

// === PROXIMITY ALERT DETECTION ===
if proximityAlertEnabled
    // Find nearest qualifying OB zones
    [nearBull, _distBull] = findNearestOB(bullBlocks, true)
    [nearBear, _distBear] = findNearestOB(bearBlocks, false)

    // Trigger alert only on state change (entering proximity range)
    // This prevents spam - only alerts once when first entering the zone
    nearBullOB := nearBull and not wasNearBullOB
    nearBearOB := nearBear and not wasNearBearOB

    // Update state for next bar
    wasNearBullOB := nearBull
    wasNearBearOB := nearBear

// Memory management (user-configurable)
int effectiveMaxBlocks = maxBlocks
if maxBlocksUser != "Auto"
    effectiveMaxBlocks := int(math.round(str.tonumber(maxBlocksUser)))

trimBlocks(bullBlocks, effectiveMaxBlocks)
trimBlocks(bearBlocks, effectiveMaxBlocks)

// === LIQUIDITY SWEEP DETECTION ===
// Gate all liquidity behavior behind enableLiquidity master toggle
// Run detection if ANY liquidity feature is enabled (visuals OR alerts)
bool liquidityVisualsEnabled = showLiquidityLevels or showSweepEvents or showLiquidityRuns
bool liquidityAlertsEnabled = alertLiquiditySweep or alertLiquidityRun or alertApproachingLiquidity
bool shouldRunLiquidity = enableLiquidity and (liquidityVisualsEnabled or liquidityAlertsEnabled)

if shouldRunLiquidity
    // 1. Detect new swing highs/lows (confirmed after rightBars)
    int confirmBars = math.round(sweepLookback / 2)
    [isNewSwingHigh, shLevel] = findSwingHigh(sweepLookback, confirmBars)
    [isNewSwingLow, slLevel] = findSwingLow(sweepLookback, confirmBars)

    // 2. Add new BSL levels (swing highs) - check for equal highs
    if isNewSwingHigh and barstate.isconfirmed
        createLiquidityLevelEntry(shLevel, bar_index - confirmBars, true, bslLevels, showLiquidityLevels)

    // 3. Add new SSL levels (swing lows) - check for equal lows
    if isNewSwingLow and barstate.isconfirmed
        createLiquidityLevelEntry(slLevel, bar_index - confirmBars, false, sslLevels, showLiquidityLevels)

    // 4. Check for sweeps AND runs on existing levels
    [bearSweep, bearRun, _] = processSweepsAndRuns(bslLevels, true)   // Check BSL for bearish sweeps/runs
    [bullSweep, bullRun, _] = processSweepsAndRuns(sslLevels, false)  // Check SSL for bullish sweeps/runs

    // Update global flags
    bearSweepDetected := bearSweep
    bearRunDetected := bearRun
    bullSweepDetected := bullSweep
    bullRunDetected := bullRun

    // 5. Update visuals (only if showing levels)
    if showLiquidityLevels
        updateLiquidityLevels(bslLevels)
        updateLiquidityLevels(sslLevels)

    // 6. Trim old levels (remove swept/run levels after N bars)
    trimLevels(bslLevels, maxLiquidityLevels)
    trimLevels(sslLevels, maxLiquidityLevels)

    // 7. Check proximity alerts (also gated by enableLiquidity)
    if alertApproachingLiquidity
        nearBSL := checkLiquidityProximity(bslLevels, true)
        nearSSL := checkLiquidityProximity(sslLevels, false)

// === LIQUIDITY PROXIMITY ANTI-SPAM LATCH ===
// Edge-trigger: fire alert only on FIRST entry into proximity zone
// Re-arm when price exits the zone
bool triggerNearBSL = nearBSL and not wasNearBSL
bool triggerNearSSL = nearSSL and not wasNearSSL

// Update latch state (must persist across bars, NOT reset each bar)
if nearBSL
    wasNearBSL := true
else
    wasNearBSL := false  // Re-arm when price exits proximity

if nearSSL
    wasNearSSL := true
else
    wasNearSSL := false  // Re-arm when price exits proximity

// === DASHBOARD ===
// Helper function to map location string to position enum
getDashboardPosition(string loc) =>
    loc == "Top Left" ? position.top_left : loc == "Bottom Right" ? position.bottom_right : loc == "Bottom Left" ? position.bottom_left : position.top_right

if showDashboard and barstate.islast
    // Check if location, transparency, or size changed - need to recreate table
    bool settingsChanged = (not na(lastDashboardLocation) and dashboardLocation != lastDashboardLocation) or
                           (not na(lastDashboardTransparency) and dashboardTransparency != lastDashboardTransparency) or
                           (not na(lastDashboardSize) and dashboardSize != lastDashboardSize)
    if settingsChanged
        if not na(dashboard)
            table.delete(dashboard)
            dashboard := na

    if na(dashboard)
        dashboard := table.new(getDashboardPosition(dashboardLocation), 7, 12, bgcolor=color.new(#000000, dashboardTransparency),
             border_color=color.new(color.white, 70), border_width=1)
        lastDashboardLocation := dashboardLocation
        lastDashboardTransparency := dashboardTransparency
        lastDashboardSize := dashboardSize

    table.clear(dashboard, 0, 0, 6, 11)

    // Header with mode tags
    table.merge_cells(dashboard, 0, 0, 6, 0)
    string presetDisplay = effectivePreset == "Scalping" ? "SCALPING" : effectivePreset == "Swing" ? "SWING" : "POSITION"
    string modeTag = settingsMode == "Auto" ? "MODE:AUTO" : "MODE:MANUAL"
    string confirmTag = signalTiming == "Confirmed (bar close)" ? " | CONFIRMED" : ""

    // HTF Trend in Header (uses cached security data from global scope)
    bool uptrend = close > sma50
    string htfStr = ""
    // Use pre-fetched HTF data (security calls at global scope for performance)
    if _needHtfData and not na(htfClose) and not na(htfSma50)
        htfStr := " | LTF:" + (uptrend ? "â–²" : "â–¼") + " HTF:" + (htfClose > htfSma50 ? "â–²" : "â–¼")

    string headerText = presetDisplay + " | " + modeTag + confirmTag + htfStr
    table.cell(dashboard, 0, 0, headerText, text_color=color.white, text_size=dashHeaderSize)

    // Column headers (width=0 auto-fits to content)
    table.cell(dashboard, 0, 1, "Type", text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 1, 1, "Volume", text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 2, 1, "Dist%", text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 3, 1, "Strength", text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 4, 1, "Tests", text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 5, 1, "Status", text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 6, 1, "Vol", text_color=color.gray, text_size=dashTextSize, width=0)

    int row = 2
    row := renderDashboardBlocks(dashboard, row, bearBlocks, false)
    row := renderDashboardBlocks(dashboard, row, bullBlocks, true)

    // Liquidity section (show if liquidity module is enabled with visuals OR any alerts)
    // Dashboard shows BSL/SSL info even in alerts-only mode (no visual lines)
    if enableLiquidity and (showLiquidityLevels or showSweepEvents or showLiquidityRuns or alertLiquiditySweep or alertLiquidityRun or alertApproachingLiquidity)
        int bslCount = array.size(bslLevels)
        int sslCount = array.size(sslLevels)
        if bslCount > 0 or sslCount > 0
            if row <= 7  // Leave rows 8-9 for Power
                table.cell(dashboard, 0, row, "LIQUIDITY", text_color=color.gray, text_size=dashTextSize, width=0)
                row += 1

            // Show nearest BSL
            if bslCount > 0 and row <= 7  // Leave rows 8-9 for Power
                LiquiditySweep nearestBSL = array.get(bslLevels, 0)
                float bslDist = 999999.0  // Start with sentinel value
                bool foundValidBSL = false
                for i = 0 to bslCount - 1
                    LiquiditySweep sweep = array.get(bslLevels, i)
                    if not sweep.swept and not sweep.ranThrough
                        float dist = (sweep.level - close) / close * 100
                        if dist > 0 and dist < bslDist
                            nearestBSL := sweep
                            bslDist := dist
                            foundValidBSL := true

                if foundValidBSL
                    string bslStatus = nearestBSL.isEqual ? "EQ BSL" : "BSL"
                    table.cell(dashboard, 0, row, bslStatus + " â–²", text_color=color.new(#00bfff, 0), text_size=dashTextSize, width=0)
                    table.cell(dashboard, 1, row, str.tostring(round2(bslDist)) + "%", text_color=color.white, text_size=dashTextSize, width=0)
                    row += 1

            // Show nearest SSL
            if sslCount > 0 and row <= 7  // Leave rows 8-9 for Power
                LiquiditySweep nearestSSL = array.get(sslLevels, 0)
                float sslDist = 999999.0  // Start with sentinel value
                bool foundValidSSL = false
                for i = 0 to sslCount - 1
                    LiquiditySweep sweep = array.get(sslLevels, i)
                    if not sweep.swept and not sweep.ranThrough
                        float dist = (close - sweep.level) / close * 100
                        if dist > 0 and dist < sslDist
                            nearestSSL := sweep
                            sslDist := dist
                            foundValidSSL := true

                if foundValidSSL
                    string sslStatus = nearestSSL.isEqual ? "EQ SSL" : "SSL"
                    table.cell(dashboard, 0, row, sslStatus + " â–¼", text_color=color.new(#ff6600, 0), text_size=dashTextSize, width=0)
                    table.cell(dashboard, 1, row, str.tostring(round2(sslDist)) + "%", text_color=color.white, text_size=dashTextSize, width=0)
                    row += 1

    // === POWER ROW (Intrabar Volume Dominance) - Always at bottom ===
    if showPowerRow
        // Use fixed rows at bottom of table (rows 8 and 9)
        int powerSepRow = 8
        int powerDataRow = 9

        // Format LTF indicator for display
        string ltfDisplay = effectivePowerLtf == "1" ? "@1m" : effectivePowerLtf == "5" ? "@5m" :
             effectivePowerLtf == "15" ? "@15m" : effectivePowerLtf == "60" ? "@1h" :
             effectivePowerLtf == "240" ? "@4h" : "@" + effectivePowerLtf

        // Separator line with LTF indicator
        string powerHeader = "POWER " + ltfDisplay
        table.cell(dashboard, 0, powerSepRow, powerHeader, text_color=color.gray, text_size=dashTextSize, width=0)
        table.cell(dashboard, 1, powerSepRow, "", text_size=dashTextSize, width=0)
        table.cell(dashboard, 2, powerSepRow, "", text_size=dashTextSize, width=0)
        table.cell(dashboard, 3, powerSepRow, "", text_size=dashTextSize, width=0)
        table.cell(dashboard, 4, powerSepRow, "", text_size=dashTextSize, width=0)
        table.cell(dashboard, 5, powerSepRow, "", text_size=dashTextSize, width=0)
        table.cell(dashboard, 6, powerSepRow, "", text_size=dashTextSize, width=0)

        // Select display values based on signal timing mode
        // Confirmed mode uses latched values (stable, no intrabar flicker)
        // Realtime mode uses live values (updates every tick)
        int displaySide = signalTiming == "Confirmed (bar close)" ? latchedPowerSide : powerSide
        float displayPctRaw = signalTiming == "Confirmed (bar close)" ? latchedPowerPct : (na(smoothedPowerPct) ? 0.0 : smoothedPowerPct)
        int displayIntrabarCount = signalTiming == "Confirmed (bar close)" ? latchedIntrabarCount : intrabarCount
        // Include na(smoothedPowerPct) check so "â€”" is shown instead of "0%" when data is invalid
        bool displayLowConf = signalTiming == "Confirmed (bar close)" ? latchedPowerLowConf : (powerLowConf or na(smoothedPowerPct))

        // Determine display values
        string sideText = displaySide == 1 ? "BUY" : (displaySide == -1 ? "SELL" : "NEUTRAL")
        color sideCol = displaySide == 1 ? bullBorder : (displaySide == -1 ? bearBorder : color.gray)

        // Use smoothed value for display, handle low confidence
        float displayPct = displayLowConf ? 0.0 : math.min(displayPctRaw, 100.0)
        color pctCol = displayLowConf ? color.gray : sideCol

        // Column 0: "Power" label with mode indicator
        string modeIndicator = powerMode == "Auto" ? "Power" : "Power*"
        table.cell(dashboard, 0, powerDataRow, modeIndicator, text_color=color.white, text_size=dashTextSize, width=0)
        // Column 1: BUY/SELL/NEUTRAL (colored)
        table.cell(dashboard, 1, powerDataRow, sideText, text_color=sideCol, text_size=dashTextSize, width=0)
        // Column 2: Percentage (colored to match side)
        string pctText = displayLowConf ? "â€”" : (str.tostring(round1(displayPct)) + "%")
        table.cell(dashboard, 2, powerDataRow, pctText, text_color=pctCol, text_size=dashTextSize, width=0)
        // Column 3: Intrabar count (confidence indicator)
        string confText = str.tostring(displayIntrabarCount) + " bars"
        color confCol = displayLowConf ? color.orange : color.gray
        table.cell(dashboard, 3, powerDataRow, confText, text_color=confCol, text_size=dashTextSize, width=0)
        // Column 4: Flip confirmation progress (shows pending direction change)
        string confirmStatus = flipConfirmCount > 0 ? "(" + str.tostring(flipConfirmCount) + ")" : ""
        table.cell(dashboard, 4, powerDataRow, confirmStatus, text_color=color.gray, text_size=dashTextSize, width=0)
        // Columns 5-6: blank
        table.cell(dashboard, 5, powerDataRow, "", text_size=dashTextSize, width=0)
        table.cell(dashboard, 6, powerDataRow, "", text_size=dashTextSize, width=0)

    // === PREMIUM/DISCOUNT ZONE (Below Power Row) ===
    int zoneRow = 10
    string zoneLabel = inDiscount ? "DISCOUNT" : inPremium ? "PREMIUM" : "EQUILIBRIUM"
    color zoneCol = inDiscount ? bullBorder : inPremium ? bearBorder : color.gray
    string oteLabel = inOteLong ? "OTEâ–²" : inOteShort ? "OTEâ–¼" : ""
    color oteCol = color.new(#ffd700, 0)

    // Zone header row
    table.cell(dashboard, 0, zoneRow, "ZONE", text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 1, zoneRow, zoneLabel, text_color=zoneCol, text_size=dashTextSize, width=0)
    table.cell(dashboard, 2, zoneRow, oteLabel, text_color=oteCol, text_size=dashTextSize, width=0)
    table.cell(dashboard, 3, zoneRow, "", text_size=dashTextSize, width=0)
    table.cell(dashboard, 4, zoneRow, "", text_size=dashTextSize, width=0)
    table.cell(dashboard, 5, zoneRow, "", text_size=dashTextSize, width=0)
    table.cell(dashboard, 6, zoneRow, "", text_size=dashTextSize, width=0)

    // Zone detail row - show distance to equilibrium
    int zoneDetailRow = 11
    float eqDist = zoneRange > 0 ? math.abs(close - zoneEquilibrium) / zoneRange * 100 : 0
    string depthLabel = inDiscount ? "Depth" : inPremium ? "Height" : "At EQ"
    string depthValue = zoneRange > 0 ? str.tostring(math.round(eqDist)) + "%" : "â€”"

    table.cell(dashboard, 0, zoneDetailRow, depthLabel, text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 1, zoneDetailRow, depthValue, text_color=color.white, text_size=dashTextSize, width=0)
    table.cell(dashboard, 2, zoneDetailRow, "", text_size=dashTextSize, width=0)
    table.cell(dashboard, 3, zoneDetailRow, "", text_size=dashTextSize, width=0)
    table.cell(dashboard, 4, zoneDetailRow, "", text_size=dashTextSize, width=0)
    table.cell(dashboard, 5, zoneDetailRow, "", text_size=dashTextSize, width=0)
    table.cell(dashboard, 6, zoneDetailRow, "", text_size=dashTextSize, width=0)

// === ALERTS ===
// Note: alertcondition must be at global scope
// Gate conditions with granular alert flags
alertcondition(alertNewOB and newBullOB, "New Bullish Order Block", "ğŸŸ¢ New Bull OB detected on {{ticker}} {{interval}}")
alertcondition(alertNewOB and newBearOB, "New Bearish Order Block", "ğŸ”´ New Bear OB detected on {{ticker}} {{interval}}")
// Touch alerts are edge-triggered: fires once per entry, re-arms when price exits all zones of that side
alertcondition(alertTouch and bullTouchTrigger, "Price in Bull Zone", "ğŸ’š Price testing Bull OB on {{ticker}} {{interval}}")
alertcondition(alertTouch and bearTouchTrigger, "Price in Bear Zone", "â¤ï¸ Price testing Bear OB on {{ticker}} {{interval}}")
alertcondition(alertReject and bullReject, "Bull Zone Rejection", "ğŸš€ Rejection from Bull OB on {{ticker}} {{interval}} - Potential LONG")
alertcondition(alertReject and bearReject, "Bear Zone Rejection", "ğŸ’¥ Rejection from Bear OB on {{ticker}} {{interval}} - Potential SHORT")

// Proximity Alerts - advance warning before price reaches zones
alertcondition(proximityAlertEnabled and nearBullOB, "Approaching Bull OB", "âš ï¸ Price approaching BULLISH Order Block on {{ticker}} {{interval}} - Prepare LONG setup")
alertcondition(proximityAlertEnabled and nearBearOB, "Approaching Bear OB", "âš ï¸ Price approaching BEARISH Order Block on {{ticker}} {{interval}} - Prepare SHORT setup")

// === LIQUIDITY SWEEP ALERTS ===
// All liquidity alerts gated by enableLiquidity master toggle
// Liquidity Sweep Alerts
alertcondition(enableLiquidity and alertLiquiditySweep and bullSweepDetected, "Bullish Liquidity Sweep", "Bullish sweep on {{ticker}} {{interval}} - SSL taken, potential LONG")
alertcondition(enableLiquidity and alertLiquiditySweep and bearSweepDetected, "Bearish Liquidity Sweep", "Bearish sweep on {{ticker}} {{interval}} - BSL taken, potential SHORT")

// Liquidity Run Alerts (continuation after taking liquidity)
// BSL Run = price took buy-side liquidity (highs) and continued UP
// SSL Run = price took sell-side liquidity (lows) and continued DOWN
alertcondition(enableLiquidity and alertLiquidityRun and bearRunDetected, "BSL Run (Upside Continuation)", "Price took buy-side liquidity (BSL) on {{ticker}} {{interval}} and continued higher")
alertcondition(enableLiquidity and alertLiquidityRun and bullRunDetected, "SSL Run (Downside Continuation)", "Price took sell-side liquidity (SSL) on {{ticker}} {{interval}} and continued lower")

// Liquidity Proximity Alerts (edge-triggered: fires once per approach, re-arms when price exits)
alertcondition(enableLiquidity and alertApproachingLiquidity and triggerNearBSL, "Approaching BSL", "Price approaching buy-side liquidity on {{ticker}} {{interval}}")
alertcondition(enableLiquidity and alertApproachingLiquidity and triggerNearSSL, "Approaching SSL", "Price approaching sell-side liquidity on {{ticker}} {{interval}}")

// === CRYPTO REGIME ALERTS ===
// Alerts for BTC.D regime shifts (gated by crypto module)
alertcondition(i_cryptoModule and i_useBtcDom and btc_regime == 1 and btc_regime[1] != 1, "Alt Season Signal", "ğŸŒŠ BTC.D falling on {{ticker}} {{interval}} - Alt season favorable for altcoins")
alertcondition(i_cryptoModule and i_useBtcDom and btc_regime == -1 and btc_regime[1] != -1, "BTC Dominance Signal", "âš ï¸ BTC.D rising on {{ticker}} {{interval}} - Risk-off for altcoins")
