//@version=6
indicator("ICT Order Block Pro [Paganie] v3.6.0", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// ============================================================================
// ICT ORDER BLOCK PRO V3.6.0 - INSTITUTIONAL SMART MONEY CONCEPTS
// Professional-grade order block detection with ICT/SMC methodology
//
// V3.6.0 - Locked Settings for Optimal Performance:
// â€¢ Settings reduced to ~20 essential controls
// â€¢ All algorithm parameters locked to optimal values
// â€¢ Users can only adjust: Mode, Modules, Visuals, Alerts, Colors
// â€¢ Detection, Zone, Strength, Liquidity params auto-optimized by timeframe
// â€¢ Power Row always uses Auto mode with Pressure method
// â€¢ Prevents users from accidentally degrading signal quality
//
// V3.5.0 - Enhanced Volume Classification:
// â€¢ NEW: Buying/Selling Pressure method for Power Row (more accurate than Polarity)
//   - Uses (close-low)/(high-low) ratio to assign proportional buy/sell volume
//   - Provides nuanced readings instead of binary all-or-nothing classification
// â€¢ Added powerVolumeMethod setting to choose between Pressure and Polarity
// â€¢ Pressure method is now the default for improved accuracy
//
// V3.4.1 - Array Bounds & Edge Case Fixes:
// â€¢ Fixed trimLevels function index out-of-bounds when removing liquidity levels
// â€¢ Added array size validation in calcPower for intrabar data consistency
// â€¢ Added pivotIdx upper bound check in checkMSB function
// â€¢ Added defensive guards against division by zero in gradient rendering
// â€¢ Enhanced updateBlock with segment bounds protection
//
// V3.4.0 - Production Default UX + Stability Finalization:
// â€¢ Settings Mode: Auto (default) optimizes all settings per timeframe
// â€¢ Signal Timing: Confirmed mode now fully latches Power row (no intrabar flicker)
// â€¢ Liquidity Module: Opt-in by default (enableLiquidity master toggle OFF)
// â€¢ Alerts-only mode: Liquidity alerts work even when all drawings are disabled
// â€¢ Anti-spam edge-triggered alerts for Touch and Liquidity Proximity
// â€¢ Touch alerts respect touchMode setting (wick vs close)
// â€¢ Clearer run alerts: "BSL Run (Upside)" / "SSL Run (Downside)"
// â€¢ Volume Profile Enhancement: ON by default
// â€¢ Dashboard location: Selectable corners with proper table recreation
//
// Features:
// â€¢ Two detection methods: Institutional (stricter) & Scalper (faster)
// â€¢ Multi-TF Power Row with real-time BUY/SELL pressure
// â€¢ ICT Liquidity Sweep Detection: BSL/SSL levels, sweep/run detection
// â€¢ Volume Profile integration for Eliteâ˜… blocks (Premium)
// â€¢ Quality ratings: â˜… Elite, â—† Strong, â—‡ Mid, â—‹ Weak
// â€¢ Proximity & rejection alerts with anti-spam protection
// â€¢ Auto-adapts settings based on timeframe
// ============================================================================

// === TIMEFRAME AUTO-DETECTION ===
tf_in_minutes = timeframe.in_seconds() / 60
is_scalping = tf_in_minutes <= 15  // 1m, 3m, 5m, 10m, 15m
is_swing = tf_in_minutes > 15 and tf_in_minutes <= 240  // 30m, 1H, 2H, 4H
is_position = tf_in_minutes > 240  // Daily, Weekly

// Prefer targeted history buffers over indicator(max_bars_back=...)
max_bars_back(open, 600)
max_bars_back(high, 600)
max_bars_back(low, 600)
max_bars_back(close, 600)
max_bars_back(volume, 600)
max_bars_back(time, 600)

// === HELPER FUNCTIONS ===
formatVolume(float vol) =>
    string s = ""
    if na(vol) or vol == 0
        s := ""
    else
        float k = vol / 1000.0
        float m = vol / 1000000.0
        // Promote to M if K value rounds to 1000 or more
        if m >= 1.0 or k >= 999.5
            s := str.tostring(math.round(m * 100) / 100) + "M"
        else if k >= 1.0
            s := str.tostring(math.round(k * 100) / 100) + "K"
        else
            s := str.tostring(math.round(vol))
    s

// Helper for rounding to 2 decimal places
round2(float x) =>
    math.round(x * 100) / 100

// Helper for rounding to 1 decimal place
round1(float x) =>
    math.round(x * 10) / 10

// Helper to convert strength to numeric score for comparison
strengthScore(string s) =>
    s == "Elite" ? 4 : s == "Strong" ? 3 : s == "Mid" ? 2 : 1

// Direction constants (avoid string comparisons)
int DIR_BULL = 1
int DIR_BEAR = -1

// === INPUTS ===
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// MODE
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string GRP_MODE = "âš™ï¸ Mode"
settingsMode = input.string("Auto", "Settings Mode", options=["Auto", "Manual"], group=GRP_MODE,
     tooltip="AUTO: Optimizes all settings based on timeframe.\nMANUAL: Full control over preset and advanced settings.")
manualPreset = input.string("Auto", "Preset Override", options=["Auto", "Scalping", "Swing", "Position"], group=GRP_MODE,
     tooltip="Override auto-detected preset (Manual mode only).\nAUTO: Use timeframe-based preset.\nSCALPING: More signals, faster.\nSWING: Balanced.\nPOSITION: Fewer, higher-quality signals.")
detectionMethod = input.string("Scalper", "Detection Method", options=["Institutional", "Scalper"], group=GRP_MODE,
     tooltip="INSTITUTIONAL: Pivot-based, stricter, fewer signals.\nSCALPER: Pattern-based, more signals, faster.")
signalTiming = input.string("Realtime (intrabar)", "Signal Timing", options=["Realtime (intrabar)", "Confirmed (bar close)"], group=GRP_MODE,
     tooltip="REALTIME: Updates on every tick.\nCONFIRMED: Updates on bar close only.")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// MODULES
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string GRP_MOD = "ğŸ“Š Modules"
useVolumeProfile = input.bool(true, "Volume Profile Enhancement", group=GRP_MOD,
     tooltip="Boosts OBs that align with high-volume zones. Auto-scales lookback based on timeframe.")
enableLiquidity = input.bool(true, "Liquidity Sweeps", group=GRP_MOD,
     tooltip="Enable BSL/SSL level tracking and sweep detection.")
enableRejection = input.bool(true, "Track Rejections", group=GRP_MOD,
     tooltip="Detect bounces and retests off order blocks.")
showPowerRow = input.bool(true, "Power Row", group=GRP_MOD,
     tooltip="Display intrabar BUY/SELL pressure in dashboard.")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// VISUALS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string GRP_VIS = "ğŸ¨ Visuals"
showDashboard = input.bool(true, "Show Dashboard", group=GRP_VIS)
dashboardLocation = input.string("Top Right", "Dashboard Position", options=["Top Right", "Top Left", "Bottom Right", "Bottom Left"], group=GRP_VIS)
dashboardSize = input.string("Small", "Dashboard Size", options=["Tiny", "Small", "Normal"], group=GRP_VIS)
dashboardTransparency = input.int(90, "Dashboard Transparency", minval=0, maxval=90, step=5, group=GRP_VIS)
showOnlyStrongElite = input.bool(false, "Show Only Strong/Elite OBs", group=GRP_VIS,
     tooltip="Filter out Weak and Mid strength order blocks.")
renderMode = input.string("Gradient", "Render Mode", options=["Gradient", "Simple fill", "Borders only"], group=GRP_VIS,
     tooltip="Gradient = full visuals. Simple/Borders = fewer objects.")
showLabels = input.bool(true, "Show Labels", group=GRP_VIS, tooltip="Show strength and volume labels on OBs.")
showCornerAccents = input.bool(true, "Corner Accents", group=GRP_VIS, tooltip="Corner markers on Strong/Elite blocks.")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ALERTS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string GRP_ALERT = "ğŸ”” Alerts"
alertNewOB = input.bool(true, "New Order Block", group=GRP_ALERT)
alertTouch = input.bool(true, "Zone Touch", group=GRP_ALERT)
alertReject = input.bool(true, "Rejection", group=GRP_ALERT)
alertProximity = input.bool(true, "Approaching Zone", group=GRP_ALERT, tooltip="Alert when price approaches OB zones.")
alertLiquidity = input.bool(false, "Liquidity Events", group=GRP_ALERT, tooltip="Alert on sweeps and liquidity runs.")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// COLORS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string GRP_COL = "ğŸ¨ Colors"
bullBorder = input.color(color.new(#00ff88, 0), "Bullish", group=GRP_COL)
bearBorder = input.color(color.new(#ff3366, 0), "Bearish", group=GRP_COL)
bslColor = input.color(color.new(#00bfff, 30), "BSL Level", group=GRP_COL)
sslColor = input.color(color.new(#ff6600, 30), "SSL Level", group=GRP_COL)

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// OPTIMAL PARAMETERS (Locked for best performance)
// These are auto-optimized based on timeframe - not user-adjustable
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// Detection
int scalperLookback = 10
int obScanWindow = 3
int gridSegments = 10
float dispAtrBodyMult = 0.8
float dispBodyToRangeMin = 0.6
bool useDisplacement = true
bool useFVG = true
bool useMSB = true
bool useVolume = true
string fvgMode = "Classic 3-candle"
float fvgMinGapAtr = 0.0
int msbLookback = 10
bool msbUsePivotFallback = true

// Zones
float smartSizeAtrMult = 1.2
string smartAnchor = "Wick"
string mitigationMode = "Auto"
float minPenZonePct = 0.10
float minPenAtrPct = 0.05
float meanMitigationLevel = 0.5
string touchMode = "Wick"
string retestDebounce = "Require exit before recount"
string rejectionCloseLevel = "Mid"
float rejectionPercent = 0.5
int fillAlpha = 75
bool showRetests = true

// Strength
float volScoreMult = 1.5
float bodyScoreMult = 1.5
int vpScoreBoost = 1
int vpLookback = 100
float vpThreshold = 1.5
bool eliteRequiresVP = true
string maxBlocksUser = "Auto"

// Liquidity
bool showLiquidityLevels = true
bool showSweepEvents = true
bool showLiquidityRuns = false
bool markEqualHL = true
int sweepLookback = 20
float equalHLThreshold = 0.1
float sweepWickMin = 0.5
bool requireVolumeSpike = true
int maxLiquidityLevelsInput = 6
color sweepBullColor = color.new(#00ff88, 20)
color sweepBearColor = color.new(#ff3366, 20)

// Alerts
float proximityThreshold = 1.0
float liquidityProximityPct = 0.5

// Power Row
string powerMode = "Auto"
string powerLtf = "1"
string powerVolumeMethod = "Pressure"
string powerTieBreak = "Carry last direction"
float powerNeutralBandPct = 10.0
int powerFlipConfirmBars = 0
int powerSmoothingLen = 8
string powerSmoothingType = "EMA"
int powerMinIntrabars = 4

// === DERIVED VARIABLES (Backward compatibility) ===
// These maintain compatibility with the rest of the code
bool showStrength = showLabels
bool showVolLabel = showLabels
bool proximityAlertEnabled = alertProximity
bool alertOnlyStrongBlocks = true  // Always true in simplified mode
bool alertOnlyFreshBlocks = false
bool requireDirectionalApproach = true  // Always true
bool alertLiquiditySweep = alertLiquidity
bool alertLiquidityRun = alertLiquidity
bool alertApproachingLiquidity = alertLiquidity
string smartSizingAppliesTo = "Scalping only"
string blockSizing = "Smart"

// === EFFECTIVE PRESET DETERMINATION ===
// Auto mode: derive preset from timeframe
// Manual mode: use manualPreset override (if not "Auto")
string tfBasedPreset = is_scalping ? "Scalping" : is_swing ? "Swing" : "Position"
string effectivePreset = (settingsMode == "Manual" and manualPreset != "Auto") ? manualPreset : tfBasedPreset
bool effectiveAutoMode = settingsMode == "Auto"

// === AUTO-CONFIGURATION BASED ON PRESET ===
int actualLookback = 5  // Default, overwritten by preset
float dispMagnitude = 1.3
int actualMsbPeriod = msbLookback  // Now uses user input as base
bool actualFVG = useFVG
bool actualMSB = useMSB
int maxBlocks = 10
string mitigationMethod = "Wick"

// Performance guardrails (Auto mode forces safe defaults)
int effectiveGridSegments = gridSegments
string effectiveRenderMode = renderMode

if effectivePreset == "Scalping"
    // Scalping: More signals, faster response
    actualLookback := 3
    dispMagnitude := 1.1
    actualMsbPeriod := 5
    actualFVG := settingsMode == "Auto" ? false : useFVG  // Auto forces off for scalping
    actualMSB := true
    maxBlocks := 8
    mitigationMethod := mitigationMode == "Auto" ? "Wick" : mitigationMode
    // Performance guardrails for scalping (Auto mode)
    if settingsMode == "Auto"
        effectiveGridSegments := math.min(gridSegments, 8)  // Cap at 8 for speed
        effectiveRenderMode := tf_in_minutes <= 3 ? "Simple fill" : renderMode  // Force simple on very low TF
else if effectivePreset == "Swing"
    // Swing: Balanced approach
    actualLookback := 5
    dispMagnitude := 1.3
    actualMsbPeriod := 10
    actualFVG := settingsMode == "Auto" ? true : useFVG
    actualMSB := true
    maxBlocks := 6
    mitigationMethod := mitigationMode == "Auto" ? "Close" : mitigationMode
    if settingsMode == "Auto"
        effectiveGridSegments := math.min(gridSegments, 12)
else
    // Position: Quality focus
    actualLookback := 7
    dispMagnitude := 1.5
    actualMsbPeriod := 15
    actualFVG := settingsMode == "Auto" ? true : useFVG
    actualMSB := true
    maxBlocks := 5
    mitigationMethod := mitigationMode == "Auto" ? "Mean" : mitigationMode
    if settingsMode == "Auto"
        effectiveGridSegments := math.min(gridSegments, 15)

// User override for MSB lookback (only in Manual mode)
if settingsMode == "Manual"
    actualMsbPeriod := msbLookback

// === LIQUIDITY AUTO-SCALING ===
// Cap maxLiquidityLevels in Auto mode for scalping to reduce object load
int maxLiquidityLevels = maxLiquidityLevelsInput
if settingsMode == "Auto" and effectivePreset == "Scalping"
    maxLiquidityLevels := math.min(maxLiquidityLevelsInput, 4)  // Cap at 4 for scalping performance
else if settingsMode == "Auto" and effectivePreset == "Swing"
    maxLiquidityLevels := math.min(maxLiquidityLevelsInput, 5)  // Cap at 5 for swing

// === VOLUME PROFILE AUTO-SCALING ===
// Automatically reduce VP lookback on lower timeframes to improve performance
var int vpLookbackEff = vpLookback

if useVolumeProfile
    if effectiveAutoMode
        // Auto-scale based on timeframe (reduces CPU load on low TF)
        // Mapping: 1mâ†’60, 3mâ†’80, 5mâ†’100, 15mâ†’150, 1hâ†’200, 4h+â†’300
        if tf_in_minutes <= 1
            vpLookbackEff := math.min(60, vpLookback)
        else if tf_in_minutes <= 3
            vpLookbackEff := math.min(80, vpLookback)
        else if tf_in_minutes <= 5
            vpLookbackEff := math.min(100, vpLookback)
        else if tf_in_minutes <= 15
            vpLookbackEff := math.min(150, vpLookback)
        else if tf_in_minutes <= 60
            vpLookbackEff := math.min(200, vpLookback)
        else
            vpLookbackEff := math.min(300, vpLookback)
    else
        // Manual mode: use raw vpLookback input
        vpLookbackEff := vpLookback

// === POWER ROW: INTRABAR VOLUME ANALYSIS ===
// Auto-select lower timeframe based on chart TF with expanded mapping
// Never request a timeframe higher than the chart TF
getPowerLtf() =>
    string ltf = "1"
    int chartSeconds = timeframe.in_seconds()
    
    // Expanded mapping for all timeframes
    if tf_in_minutes <= 5
        ltf := "1"          // Chart â‰¤5m â†’ 1-min intrabars
    else if tf_in_minutes <= 15
        ltf := "1"          // Chart â‰¤15m â†’ 1-min intrabars
    else if tf_in_minutes <= 60
        ltf := "5"          // Chart â‰¤1h â†’ 5-min intrabars
    else if tf_in_minutes <= 240
        ltf := "15"         // Chart â‰¤4h â†’ 15-min intrabars
    else if tf_in_minutes <= 1440
        ltf := "60"         // Chart â‰¤1D â†’ 1h intrabars
    else
        ltf := "240"        // Weekly+ â†’ 4h intrabars
    
    // Safety check: never request higher TF than chart
    // Convert ltf to seconds for comparison
    int ltfSeconds = ltf == "1" ? 60 : ltf == "5" ? 300 : ltf == "15" ? 900 : ltf == "60" ? 3600 : 14400
    if ltfSeconds >= chartSeconds
        // Fallback: use smallest valid LTF (1 min) or chart TF itself
        ltf := chartSeconds <= 60 ? timeframe.period : "1"
    
    ltf

// Auto-scale smoothing length based on chart TF
getAutoSmoothingLen() =>
    int len = 8
    if tf_in_minutes <= 15
        len := 6           // Faster charts: lighter smoothing (5-8)
    else if tf_in_minutes <= 60
        len := 10          // 1h: moderate smoothing (10-14)
    else if tf_in_minutes <= 240
        len := 14          // 4h: heavier smoothing (14-18)
    else
        len := 18          // Daily+: strongest smoothing (14-21)
    len

// Auto-scale flip confirmation bars based on chart TF
getAutoFlipConfirm() =>
    int confirm = 2
    if tf_in_minutes <= 15
        confirm := 2       // Fast charts: 2-3 bars
    else if tf_in_minutes <= 60
        confirm := 3       // 1h: 3-4 bars
    else if tf_in_minutes <= 240
        confirm := 4       // 4h: 4-5 bars
    else
        confirm := 5       // Daily+: 5-8 bars
    confirm

// Determine effective Power settings based on settingsMode
// When settingsMode=Auto: force stability settings regardless of powerMode
// When settingsMode=Manual: respect powerMode (Auto/Manual within Power)
string effectivePowerLtf = na
int effectiveSmoothingLen = 0
int effectiveFlipConfirm = 0
string effectivePowerTieBreak = powerTieBreak
float effectiveNeutralBandPct = powerNeutralBandPct
int effectivePowerMinIntrabars = powerMinIntrabars

if settingsMode == "Auto"
    // Force all Power stability settings based on preset
    effectivePowerLtf := getPowerLtf()
    effectiveSmoothingLen := getAutoSmoothingLen()
    effectiveFlipConfirm := getAutoFlipConfirm()
    effectivePowerTieBreak := "Carry last direction"  // Most stable option
    // Neutral band by preset (higher = more stable)
    effectiveNeutralBandPct := effectivePreset == "Scalping" ? 12.0 : effectivePreset == "Swing" ? 15.0 : 18.0
    // Min intrabars by preset (lower = faster response on faster TF)
    effectivePowerMinIntrabars := effectivePreset == "Scalping" ? 4 : effectivePreset == "Swing" ? 3 : 2
else
    // Manual mode: respect powerMode input
    effectivePowerLtf := powerMode == "Auto" ? getPowerLtf() : powerLtf
    effectiveSmoothingLen := powerMode == "Auto" ? getAutoSmoothingLen() : powerSmoothingLen
    effectiveFlipConfirm := powerFlipConfirmBars == 0 ? getAutoFlipConfirm() : powerFlipConfirmBars
    // Keep user's settings
    effectivePowerTieBreak := powerTieBreak
    effectiveNeutralBandPct := powerNeutralBandPct
    effectivePowerMinIntrabars := powerMinIntrabars

// Request intrabar data (only 3 calls for efficiency)
// These return arrays of values for each intrabar within the current chart bar
int chartTfSec = timeframe.in_seconds()
int powerTfSec = timeframe.in_seconds(effectivePowerLtf)
string powerLtfSafe = powerTfSec <= chartTfSec ? effectivePowerLtf : timeframe.period

arrOpen = request.security_lower_tf(syminfo.tickerid, powerLtfSafe, open, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)
arrHigh = request.security_lower_tf(syminfo.tickerid, powerLtfSafe, high, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)
arrLow = request.security_lower_tf(syminfo.tickerid, powerLtfSafe, low, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)
arrClose = request.security_lower_tf(syminfo.tickerid, powerLtfSafe, close, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)
arrVol = request.security_lower_tf(syminfo.tickerid, powerLtfSafe, volume, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)

// Calculate Power metrics from intrabar data
// Supports both Polarity (binary) and Pressure (proportional) methods
calcPower(string method, string tieBreakRule) =>
    float buyVol = 0.0
    float sellVol = 0.0
    // Validate all arrays have same size (edge case: symbol/timeframe errors)
    int sizeVol = array.size(arrVol)
    int sizeOpen = array.size(arrOpen)
    int sizeHigh = array.size(arrHigh)
    int sizeLow = array.size(arrLow)
    int sizeClose = array.size(arrClose)
    int intrabarCount = math.min(sizeVol, math.min(sizeOpen, math.min(sizeHigh, math.min(sizeLow, sizeClose))))
    int lastDir = 0  // 1 = bullish, -1 = bearish, 0 = unknown
    
    if intrabarCount > 0
        float prevClose = na
        for i = 0 to intrabarCount - 1
            float o = array.get(arrOpen, i)
            float h = array.get(arrHigh, i)
            float l = array.get(arrLow, i)
            float c = array.get(arrClose, i)
            float v = array.get(arrVol, i)
            
            if method == "Pressure"
                // === BUYING/SELLING PRESSURE METHOD ===
                // Proportionally assigns volume based on where price closed within the range
                // (close - low) = buying pressure, (high - close) = selling pressure
                float candleRange = h - l
                if candleRange > 0
                    float buyRatio = (c - l) / candleRange
                    float sellRatio = (h - c) / candleRange
                    buyVol += v * buyRatio
                    sellVol += v * sellRatio
                else
                    // No range (h == l), use direction from open to close
                    if c > o
                        buyVol += v
                    else if c < o
                        sellVol += v
                    else
                        // True doji - split evenly
                        buyVol += v * 0.5
                        sellVol += v * 0.5
            else
                // === POLARITY METHOD ===
                // Binary classification: all volume goes to buy or sell
                int dir = 0
                if c > o
                    dir := 1   // Bullish intrabar
                else if c < o
                    dir := -1  // Bearish intrabar
                else
                    // Doji (close == open) - apply tie-break rule (uses effective setting)
                    if tieBreakRule == "Carry last direction"
                        dir := lastDir
                    else if tieBreakRule == "Use prev intrabar close"
                        if not na(prevClose)
                            dir := c > prevClose ? 1 : (c < prevClose ? -1 : 0)
                    // else "Ignore dojis" - dir stays 0, volume not counted
                
                // Accumulate volume by direction
                if dir == 1
                    buyVol += v
                else if dir == -1
                    sellVol += v
                
                // Update state for next iteration
                if dir != 0
                    lastDir := dir
                prevClose := c
    
    [buyVol, sellVol, intrabarCount]

[rawBuyVol, rawSellVol, intrabarCount] = calcPower(powerVolumeMethod, effectivePowerTieBreak)

// Compute delta and percentage
float rawDelta = rawBuyVol - rawSellVol
float rawTotal = rawBuyVol + rawSellVol
float rawPowerPct = rawTotal > 0 ? 100.0 * math.abs(rawDelta) / rawTotal : na

// Apply smoothing for display stability (uses effective length)
float smoothedPowerPct = powerSmoothingType == "EMA" ? 
     ta.ema(rawPowerPct, effectiveSmoothingLen) : 
     ta.sma(rawPowerPct, effectiveSmoothingLen)

// Determine RAW side from delta (before stability filters)
int rawPowerSide = rawDelta > 0 ? 1 : (rawDelta < 0 ? -1 : 0)  // 1=BUY, -1=SELL, 0=NEUTRAL

// === STABILITY FILTERS ===
// 1) Neutral band: if powerPct is in the neutral zone, force NEUTRAL
//    Neutral zone = [50 - band/2, 50 + band/2] mapped to powerPct scale
//    Since powerPct is 0-100 (dominance), neutral band applies when dominance is LOW
float neutralThreshold = effectiveNeutralBandPct  // Uses effective setting (Auto forces per preset)
bool inNeutralZone = na(smoothedPowerPct) or smoothedPowerPct < neutralThreshold

// 2) Flip confirmation: require N consecutive bars supporting new side before switching
var int confirmedPowerSide = 0  // Persisted displayed side
var int flipConfirmCount = 0    // Counter for confirmation

// Get the candidate side (after neutral zone filter)
int candidateSide = inNeutralZone ? 0 : rawPowerSide

// Signal timing: only update stateful counters when appropriate
// Realtime: update every tick | Confirmed: update only on bar close
bool shouldUpdatePowerState = signalTiming == "Realtime (intrabar)" or barstate.isconfirmed

// Apply flip confirmation logic (respects signal timing)
if shouldUpdatePowerState
    if candidateSide == confirmedPowerSide
        // Same side - reset confirmation counter
        flipConfirmCount := 0
    else if candidateSide == 0
        // Moving to NEUTRAL - confirm immediately (no delay for de-escalation)
        confirmedPowerSide := 0
        flipConfirmCount := 0
    else
        // Different non-neutral side - require confirmation
        flipConfirmCount += 1
        if flipConfirmCount >= effectiveFlipConfirm
            confirmedPowerSide := candidateSide
            flipConfirmCount := 0

// Final displayed side (uses confirmed side for stability)
int powerSide = confirmedPowerSide

// Low confidence check (uses effective min intrabars setting)
bool powerLowConf = intrabarCount < effectivePowerMinIntrabars or rawTotal == 0 or na(rawPowerPct)

// === LATCHED POWER VALUES FOR CONFIRMED MODE ===
// When signalTiming="Confirmed (bar close)", dashboard should show stable values
// that only update on bar close (no intrabar flicker)
var float latchedPowerPct = 0.0
var int latchedIntrabarCount = 0
var bool latchedPowerLowConf = true
var int latchedPowerSide = 0

// Determine if we should update latched values
// Realtime mode: always use live values (no latching needed, handled in dashboard)
// Confirmed mode: only update latched values on bar close
// NOTE: latchedPowerLowConf must also consider na(smoothedPowerPct) for proper "â€”" display
if signalTiming == "Confirmed (bar close)"
    if barstate.isconfirmed
        latchedPowerPct := na(smoothedPowerPct) ? 0.0 : smoothedPowerPct
        latchedIntrabarCount := intrabarCount
        latchedPowerLowConf := powerLowConf or na(smoothedPowerPct)  // Include na check for display
        latchedPowerSide := powerSide
else
    // Realtime mode: keep latched values in sync (for consistency)
    latchedPowerPct := na(smoothedPowerPct) ? 0.0 : smoothedPowerPct
    latchedIntrabarCount := intrabarCount
    latchedPowerLowConf := powerLowConf or na(smoothedPowerPct)  // Include na check for display
    latchedPowerSide := powerSide

// === DATA STRUCTURES ===
type OrderBlock
    box[] volumeBoxes
    line topLine
    line botLine
    linefill bgFill
    label volLabel
    box[] cornerBoxes  // Corner accent markers
    float top
    float bot
    int direction
    float totalVolume
    float relativeVol
    string strength
    bool touched
    int retestCount
    bool mitigated
    bool rejected
    // State tracking for conditional updates (performance optimization)
    int lastUpdateBar       // Track last bar_index updated
    int lastRetestCount     // For label rebuild check
    bool lastTouched
    bool lastRejected

type LiquiditySweep
    line levelLine           // Horizontal line at swing high/low
    box sweepBox             // Highlight box for sweep event
    label sweepLabel         // Info label
    float level              // Price level of swing high/low
    int levelBar             // Bar index where level formed
    int direction            // DIR_BULL (1) or DIR_BEAR (-1)
    bool isEqual             // Is this an "equal high/low" (clustered liquidity)
    bool swept               // Has been swept (reversal)
    bool ranThrough          // Has been run through (continuation)
    int sweepBar             // Bar when sweep/run occurred
    float sweepWick          // Wick extent beyond level
    float sweepClose         // Close price of sweep candle
    string quality           // "Strong", "Mid", "Weak" based on factors
    bool confirmed           // Sweep confirmed (reversal started)
    int retestCount          // Times level retested after sweep
    int lastUpdateBar        // State tracking

// Dashboard size helpers (must be before renderDashboardRow)
getDashTextSize() =>
    dashboardSize == "Tiny" ? size.tiny : dashboardSize == "Normal" ? size.normal : size.small

getDashHeaderSize() =>
    dashboardSize == "Tiny" ? size.tiny : dashboardSize == "Normal" ? size.small : size.small

string dashTextSize = getDashTextSize()
string dashHeaderSize = getDashHeaderSize()

// Helper to render a dashboard row for an order block
// Returns the next row number (incremented if row was rendered)
renderDashboardRow(table tbl, int row, OrderBlock b, string dirLabel, color dirCol, float dist, string rejectedLabel) =>
    int nextRow = row
    // Render regardless of distance; negative means price is beyond the zone
    if row <= 7  // Leave rows 8-9 for Power
        table.cell(tbl, 0, row, dirLabel, text_color=dirCol, text_size=dashTextSize, width=0)
        table.cell(tbl, 1, row, formatVolume(b.totalVolume), text_color=dirCol, text_size=dashTextSize, width=0)
        table.cell(tbl, 2, row, str.tostring(round2(dist)) + "%", text_color=color.white, text_size=dashTextSize, width=0)

        color strengthCol = b.strength == "Elite" ? color.yellow : b.strength == "Strong" ? dirCol : b.strength == "Mid" ? color.orange : color.gray
        table.cell(tbl, 3, row, b.strength, text_color=strengthCol, text_size=dashTextSize, width=0)
        table.cell(tbl, 4, row, str.tostring(b.retestCount), text_color=color.white, text_size=dashTextSize, width=0)

        // Check if price is currently in zone
        bool currentlyInZone = low <= b.top and high >= b.bot
        string status = b.rejected ? rejectedLabel : (b.retestCount > 0 ? (currentlyInZone ? "ACTIVE" : "TESTED") : "FRESH")
        color statusCol = b.rejected ? dirCol : (currentlyInZone ? color.yellow : (b.retestCount > 0 ? color.orange : color.white))
        table.cell(tbl, 5, row, status, text_color=statusCol, text_size=dashTextSize, width=0)
        table.cell(tbl, 6, row, str.tostring(round1(b.relativeVol)) + "x", text_color=color.white, text_size=dashTextSize, width=0)
        nextRow := row + 1
    nextRow

renderDashboardBlocks(table tbl, int row, array<OrderBlock> blocks, bool isBull) =>
    int nextRow = row
    int blockCount = array.size(blocks)
    if blockCount > 0
        string dirLabel = isBull ? "BULL â–²" : "BEAR â–¼"
        color dirCol = isBull ? bullBorder : bearBorder
        string rejectedLabel = isBull ? "BOUNCE" : "REJECT"
        for i = blockCount - 1 to 0
            if nextRow > 7  // Leave rows 8-9 for Power
                break
            OrderBlock b = array.get(blocks, i)
            float dist = isBull ? (close - b.bot) / close * 100 : (b.top - close) / close * 100
            nextRow := renderDashboardRow(tbl, nextRow, b, dirLabel, dirCol, dist, rejectedLabel)
    nextRow

var bullBlocks = array.new<OrderBlock>()
var bearBlocks = array.new<OrderBlock>()
var bslLevels = array.new<LiquiditySweep>()  // Buy-side liquidity (above price)
var sslLevels = array.new<LiquiditySweep>()  // Sell-side liquidity (below price)
var table dashboard = na
var string lastDashboardLocation = na  // Track location for table recreation
var int lastDashboardTransparency = na  // Track transparency for table recreation
var string lastDashboardSize = na  // Track size for table recreation

// Market context (no var needed - recalculated each bar)
float atr = ta.atr(14)
float avgVol = ta.sma(volume, 20)
float avgBody = ta.sma(math.abs(close - open), 20)
float sma50 = ta.sma(close, 50)

// Premium/Discount Zone Calculation (ICT concept)
// Auto-scale lookback based on timeframe for optimal zone responsiveness
int zoneLookback = is_scalping ? 30 : is_swing ? 50 : 80
float zoneSwingHigh = ta.highest(high, zoneLookback)
float zoneSwingLow = ta.lowest(low, zoneLookback)
float zoneRange = zoneSwingHigh - zoneSwingLow
float zoneEquilibrium = zoneSwingLow + zoneRange * 0.5
bool inDiscount = close < zoneEquilibrium
bool inPremium = close > zoneEquilibrium
// OTE zones (62-79% Fibonacci retracement)
float oteLongTop = zoneSwingLow + zoneRange * 0.38    // 62% retracement from high
float oteLongBot = zoneSwingLow + zoneRange * 0.21    // 79% retracement from high
float oteShortBot = zoneSwingLow + zoneRange * 0.62   // 62% retracement from low
float oteShortTop = zoneSwingLow + zoneRange * 0.79   // 79% retracement from low
bool inOteLong = close >= oteLongBot and close <= oteLongTop
bool inOteShort = close >= oteShortBot and close <= oteShortTop

max_bars_back(atr, 600)
max_bars_back(avgBody, 600)

// Displacement checks are inlined in checkScalperCondition to avoid Pine consistency warnings.

// Alert flags
var bool newBullOB = false
var bool newBearOB = false
var bool bullTouch = false
var bool bearTouch = false
var bool bullReject = false
// Anti-spam latch for OB Touch alerts - persist across bars (NOT reset each bar)
var bool wasInBullOB = false
var bool wasInBearOB = false
var bool bearReject = false

// Proximity alert flags
var bool nearBullOB = false
var bool nearBearOB = false
var bool wasNearBullOB = false  // State tracking to prevent spam
var bool wasNearBearOB = false

// Liquidity sweep alert flags
var bool bullSweepDetected = false
var bool bearSweepDetected = false
var bool bullRunDetected = false
var bool bearRunDetected = false
var bool nearBSL = false
var bool nearSSL = false
// Anti-spam latch for proximity alerts - persist across bars (NOT reset each bar)
var bool wasNearBSL = false
var bool wasNearSSL = false

bool showAnyLabel = showVolLabel or showStrength or showRetests

newBullOB := false
newBearOB := false
bullTouch := false
bearTouch := false
bullReject := false
bearReject := false
nearBullOB := false
nearBearOB := false
bullSweepDetected := false
bearSweepDetected := false
bullRunDetected := false
bearRunDetected := false
nearBSL := false
nearSSL := false

// === VALIDATION FUNCTIONS ===
checkDisplacement(int idx, float threshold) =>
    // Used by Institutional method - now respects user's body/range threshold
    if idx < 0 or idx > bar_index
        false
    else
        float body = math.abs(close[idx] - open[idx])
        float candle_range = high[idx] - low[idx]
        bool strongBody = body > avgBody[idx] * threshold
        bool fullBodied = candle_range > 0 ? body / candle_range > dispBodyToRangeMin : false
        strongBody and fullBodied

checkFVG(int idx, string dir) =>
    // FVG (Fair Value Gap) = 3-candle pattern showing strong momentum
    // 
    // CANDLE MAPPING (in Pine offset terms, higher = older):
    //   idx-2 = Most recent (continuation after gap)
    //   idx-1 = Middle (displacement/impulse that created gap)
    //   idx   = Oldest (order block candle before displacement)
    //
    // Bullish FVG: Price gaps UP, leaving unfilled zone
    //   - Check: low[idx-2] > high[idx]
    //   - Meaning: Recent candle's LOW is above old candle's HIGH (gap between them)
    //   - The gap was created by the middle candle (idx-1) jumping up
    //
    // Bearish FVG: Price gaps DOWN, leaving unfilled zone
    //   - Check: high[idx-2] < low[idx]
    //   - Meaning: Recent candle's HIGH is below old candle's LOW (gap between them)
    //   - The gap was created by the middle candle (idx-1) jumping down
    //
    // NOTE: If FVGs appear "off by 2 bars", this mapping may need adjustment
    
    // Check mode
    if fvgMode == "Off"
        true  // Always pass if FVG is off
    else
        // Bounds check: need idx-2 to be valid (closer to current bar)
        if idx < 2 or idx > bar_index
            false
        else
            bool hasGap = false
            float gapSize = 0.0
            
            if dir == "Bull"
                if fvgMode == "Strict (body gap)"
                    // Strict: require body gap (close vs open)
                    float recentLow = math.min(close[idx - 2], open[idx - 2])
                    float oldHigh = math.max(close[idx], open[idx])
                    hasGap := recentLow > oldHigh
                    gapSize := hasGap ? recentLow - oldHigh : 0.0
                else if fvgMode == "Loose (wick gap)"
                    // Loose: allow partial gaps (any separation)
                    hasGap := low[idx - 2] >= high[idx]
                    gapSize := hasGap ? low[idx - 2] - high[idx] : 0.0
                else  // Classic 3-candle
                    // Classic: wick gap (standard)
                    hasGap := low[idx - 2] > high[idx]
                    gapSize := hasGap ? low[idx - 2] - high[idx] : 0.0
            else  // Bear
                if fvgMode == "Strict (body gap)"
                    // Strict: require body gap
                    float recentHigh = math.max(close[idx - 2], open[idx - 2])
                    float oldLow = math.min(close[idx], open[idx])
                    hasGap := recentHigh < oldLow
                    gapSize := hasGap ? oldLow - recentHigh : 0.0
                else if fvgMode == "Loose (wick gap)"
                    // Loose: allow partial gaps
                    hasGap := high[idx - 2] <= low[idx]
                    gapSize := hasGap ? low[idx] - high[idx - 2] : 0.0
                else  // Classic 3-candle
                    // Classic: wick gap
                    hasGap := high[idx - 2] < low[idx]
                    gapSize := hasGap ? low[idx] - high[idx - 2] : 0.0
            
            // Apply minimum gap filter
            bool meetsMinGap = true
            if fvgMinGapAtr > 0.0 and hasGap
                meetsMinGap := gapSize > atr[idx] * fvgMinGapAtr
            
            hasGap and meetsMinGap

checkMSB(int pivotIdx, int dispIdx, int lookback, string dir) =>
    // Market Structure Break: Check if displacement candle broke recent swing structure
    // Scan backwards FROM displacement (excluding dispIdx itself) to find recent structure
    bool confirmed = false
    int scanStart = dispIdx + 1
    int scanEnd = math.min(dispIdx + lookback, bar_index)
    
    // Need at least one bar to check structure
    // pivotIdx must be within valid historical range for array access
    if pivotIdx < 0 or pivotIdx > bar_index or dispIdx < 0 or dispIdx > bar_index or scanStart > bar_index
        confirmed := false
    else
        if dir == "Bull"
            // Find highest high in lookback period BEFORE displacement (excluding dispIdx)
            // Initialize from first bar in scan range (NOT from dispIdx)
            float recentHigh = high[scanStart]
            
            // Scan remaining bars in lookback period (if any)
            if scanStart < scanEnd
                for i = scanStart + 1 to scanEnd
                    if high[i] > recentHigh
                        recentHigh := high[i]
            
            // Also consider pivot as minimum structure level (fallback) - user configurable
            if msbUsePivotFallback and high[pivotIdx] > recentHigh
                recentHigh := high[pivotIdx]
            
            // MSB confirmed if displacement broke above the recent structure
            if high[dispIdx] > recentHigh
                confirmed := true
        else
            // Find lowest low in lookback period BEFORE displacement (excluding dispIdx)
            // Initialize from first bar in scan range (NOT from dispIdx)
            float recentLow = low[scanStart]
            
            // Scan remaining bars in lookback period (if any)
            if scanStart < scanEnd
                for i = scanStart + 1 to scanEnd
                    if low[i] < recentLow
                        recentLow := low[i]
            
            // Also consider pivot as minimum structure level (fallback) - user configurable
            if msbUsePivotFallback and low[pivotIdx] < recentLow
                recentLow := low[pivotIdx]
            
            // MSB confirmed if displacement broke below the recent structure
            if low[dispIdx] < recentLow
                confirmed := true
    confirmed

// === LIQUIDITY SWEEP DETECTION FUNCTIONS ===
// Detect swing highs (potential BSL)
findSwingHigh(int leftBars, int rightBars) =>
    bool isSwing = false
    float level = na

    // Need enough history to validate both sides.
    if bar_index >= leftBars + rightBars
        isSwing := true
        level := high[rightBars]
        // Left side (older bars)
        for i = 1 to leftBars
            if high[rightBars + i] >= level
                isSwing := false
                break
        // Right side (newer bars) - must include current bar at index 0
        for i = 0 to rightBars - 1
            if high[i] >= level
                isSwing := false
                break

    [isSwing, level]

// Detect swing lows (potential SSL)
findSwingLow(int leftBars, int rightBars) =>
    bool isSwing = false
    float level = na

    // Need enough history to validate both sides.
    if bar_index >= leftBars + rightBars
        isSwing := true
        level := low[rightBars]
        // Left side (older bars)
        for i = 1 to leftBars
            if low[rightBars + i] <= level
                isSwing := false
                break
        // Right side (newer bars) - must include current bar at index 0
        for i = 0 to rightBars - 1
            if low[i] <= level
                isSwing := false
                break

    [isSwing, level]

// Check if new swing is "equal" to existing level (clustered liquidity = stronger)
isEqualLevel(float newLevel, float existingLevel, float thresholdPct) =>
    float diff = math.abs(newLevel - existingLevel) / existingLevel * 100
    diff <= thresholdPct

// Check for bullish sweep (price sweeps SSL then reverses up)
checkBullishSweep(float sslLevel, float minWickAtr) =>
    bool swept = false
    float wickExtent = 0.0
    // Wick went below level but close stayed above
    if low < sslLevel and close > sslLevel
        wickExtent := sslLevel - low
        bool wickOk = wickExtent >= atr * minWickAtr
        bool volumeOk = not requireVolumeSpike or volume > avgVol
        swept := wickOk and volumeOk
    [swept, wickExtent]

// Check for bearish sweep (price sweeps BSL then reverses down)
checkBearishSweep(float bslLevel, float minWickAtr) =>
    bool swept = false
    float wickExtent = 0.0
    // Wick went above level but close stayed below
    if high > bslLevel and close < bslLevel
        wickExtent := high - bslLevel
        bool wickOk = wickExtent >= atr * minWickAtr
        bool volumeOk = not requireVolumeSpike or volume > avgVol
        swept := wickOk and volumeOk
    [swept, wickExtent]

// Check for bullish run (price takes SSL and CONTINUES down)
checkBullishRun(float sslLevel) =>
    bool isRun = false
    // Price broke below level AND closed below (continuation, not reversal)
    if low < sslLevel and close < sslLevel
        isRun := true
    isRun

// Check for bearish run (price takes BSL and CONTINUES up)
checkBearishRun(float bslLevel) =>
    bool isRun = false
    // Price broke above level AND closed above (continuation, not reversal)
    if high > bslLevel and close > bslLevel
        isRun := true
    isRun

// Sweep quality scoring
getSweepQuality(float wickExtent, bool volumeSpike, bool atOrderBlock, bool equalLevel) =>
    int score = 0
    if wickExtent > atr * 1.0
        score += 1  // Strong wick
    if volumeSpike
        score += 1  // Volume confirmation
    if atOrderBlock
        score += 1  // Near order block (confluence)
    if equalLevel
        score += 1  // Equal highs/lows (stronger liquidity)
    score >= 3 ? "Strong" : score >= 2 ? "Mid" : "Weak"

// === VOLUME PROFILE ANALYSIS (Premium Feature) ===
analyzeVolumeProfile(float obTop, float obBot, int lookback) =>
    // Calculate volume distribution in the order block zone
    // Optimized with early exit when sufficient samples collected
    float totalVol = 0.0
    float zoneVol = 0.0
    int barsInZone = 0
    int barsProcessed = 0

    // Confidence thresholds for early exit
    int minBarsForConfidence = 5
    int minBarsToProcess = 20

    int maxBars = math.min(lookback - 1, bar_index)

    // Analyze volume over lookback period with early exit
    for i = 0 to maxBars
        float barHigh = high[i]
        float barLow = low[i]
        float barVol = volume[i]

        totalVol += barVol
        barsProcessed += 1

        // Check if this bar's price range overlaps with order block zone
        bool overlaps = barLow <= obTop and barHigh >= obBot
        if overlaps
            // Calculate overlap percentage
            float overlapHigh = math.min(barHigh, obTop)
            float overlapLow = math.max(barLow, obBot)
            float barRange = barHigh - barLow

            if barRange > 0
                float overlapRatio = (overlapHigh - overlapLow) / barRange
                zoneVol += barVol * overlapRatio
                barsInZone += 1

        // Early exit: enough samples collected for confident estimate
        if barsInZone >= minBarsForConfidence and barsProcessed >= minBarsToProcess
            break

    // Calculate volume metrics using actual bars processed
    float avgVolPerBar = barsProcessed > 0 ? totalVol / barsProcessed : 0.0
    float zoneVolPerBar = barsInZone > 0 ? zoneVol / barsInZone : 0.0
    float volumeConcentration = avgVolPerBar > 0 ? zoneVolPerBar / avgVolPerBar : 0.0

    volumeConcentration

getStrength(float vol, float body, bool trendAlign) =>
    int score = 0
    if useVolume and vol > avgVol * volScoreMult
        score += 1
    if body > avgBody * bodyScoreMult
        score += 1
    if trendAlign
        score += 1
    score >= 2 ? "Strong" : score == 1 ? "Mid" : "Weak"

getEnhancedStrength(float vol, float body, bool trendAlign, float vpConcentration) =>
    int score = 0
    
    // Base scoring (user-configurable)
    if useVolume and vol > avgVol * volScoreMult
        score += 1
    if body > avgBody * bodyScoreMult
        score += 1
    if trendAlign
        score += 1
    
    // Volume Profile boost (Premium feature - user-configurable)
    bool hasVPConfirmation = useVolumeProfile and vpConcentration >= vpThreshold
    if hasVPConfirmation
        score += vpScoreBoost
    
    // Enhanced rating with VP (user can configure if Elite requires VP)
    if useVolumeProfile
        if eliteRequiresVP
            // Elite requires VP confirmation
            if hasVPConfirmation and score >= 3
                "Elite"
            else
                score >= 2 ? "Strong" : score == 1 ? "Mid" : "Weak"
        else
            // Elite available without VP if base score is high enough (3 or 4+)
            score >= 3 ? "Elite" : score >= 2 ? "Strong" : score == 1 ? "Mid" : "Weak"
    else
        score >= 2 ? "Strong" : score == 1 ? "Mid" : "Weak"

// === PROXIMITY ALERT HELPER ===
findNearestOB(array<OrderBlock> blocks, bool isBull) =>
    // Find nearest qualifying order block within proximity threshold
    float nearestDist = 999999.0
    bool isNear = false

    int blockCount = array.size(blocks)
    if blockCount > 0
        for i = 0 to blockCount - 1
            OrderBlock b = array.get(blocks, i)

            // Skip mitigated blocks
            if b.mitigated
                continue

            // Apply quality filters
            if alertOnlyStrongBlocks and (b.strength != "Strong" and b.strength != "Elite")
                continue
            if alertOnlyFreshBlocks and b.retestCount > 0
                continue

            // Calculate distance from current price to zone
            float dist = 0.0
            if isBull
                // Bull OB: distance from current close to zone bottom (approaching from above)
                dist := close > b.bot ? (close - b.bot) / close * 100 : -1.0
            else
                // Bear OB: distance from zone top to current close (approaching from below)
                dist := close < b.top ? (b.top - close) / close * 100 : -1.0

            // Check if within threshold and not yet inside zone
            if dist > 0 and dist <= proximityThreshold
                // Check directional approach for more actionable signals
                bool correctDirection = true
                if requireDirectionalApproach
                    // Bull OB: price falling = potential bounce | Bear OB: price rising = potential rejection
                    correctDirection := isBull ? (close < open) : (close > open)

                if correctDirection and dist < nearestDist
                    nearestDist := dist
                    isNear := true

    [isNear, nearestDist]

// === SCALPER DETECTION METHOD (ICT/SMC - Correct Formula) ===
// Based on Inner Circle Trader methodology
// Order Block = Nearest opposite candle within 1-3 bars before the impulse candle
// Prioritizes recency: takes the most recent qualifying impulse, not just strongest
checkScalperCondition(int tuning) =>
    
    // Max candles to scan back from impulse to find opposite candle (user-adjustable)
    
    // BULL ORDER BLOCK: BEARISH candle before UPWARD impulse
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    bool bullOB = false
    int bullOBIdx = 0
    float bullImpulseStrength = 0.0  // Normalized: body/atr
    
    // BEAR ORDER BLOCK: BULLISH candle before DOWNWARD impulse
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    bool bearOB = false
    int bearOBIdx = 0
    float bearImpulseStrength = 0.0  // Normalized: body/atr
    
    // 1. Find the most recent qualifying impulse candles (single pass)
    int bullImpulseIdx = -1
    int bearImpulseIdx = -1
    int maxIdx = math.min(tuning - 1, bar_index)
    
    for i = 0 to maxIdx
        float body = math.abs(close[i] - open[i])
        float range_c = high[i] - low[i]
        float atrAtIdx = atr[i]  // Use ATR at the historical candle (atr series already calculated)
        bool sizeOk = body > atrAtIdx * dispAtrBodyMult
        bool dominanceOk = range_c > 0 ? body / range_c > dispBodyToRangeMin : false
        if sizeOk and dominanceOk
            if bullImpulseIdx == -1 and close[i] > open[i]
                bullImpulseIdx := i
            if bearImpulseIdx == -1 and close[i] < open[i]
                bearImpulseIdx := i
            if bullImpulseIdx != -1 and bearImpulseIdx != -1
                break
    
    // 2. Scan 1-3 candles back from impulse to find nearest opposite (bearish) candle
    if bullImpulseIdx >= 0
        float impulseBody = close[bullImpulseIdx] - open[bullImpulseIdx]
        float atrAtImpulse = atr[bullImpulseIdx]  // Use ATR at impulse candle (from global atr series)
        bullImpulseStrength := atrAtImpulse > 0 ? impulseBody / atrAtImpulse : 0.0  // Normalized strength
        
        for j = 1 to obScanWindow
            int candidateIdx = bullImpulseIdx + j
            if candidateIdx > bar_index
                break
            // Stop if we hit another qualifying displacement candle (same full predicate)
            float body = math.abs(close[candidateIdx] - open[candidateIdx])
            float range_c = high[candidateIdx] - low[candidateIdx]
            float atrAtIdx = atr[candidateIdx]  // Use ATR at the historical candle (atr series already calculated)
            bool sizeOk = body > atrAtIdx * dispAtrBodyMult
            bool dominanceOk = range_c > 0 ? body / range_c > dispBodyToRangeMin : false
            bool dispBull = sizeOk and dominanceOk and close[candidateIdx] > open[candidateIdx]
            bool dispBear = sizeOk and dominanceOk and close[candidateIdx] < open[candidateIdx]
            if dispBull or dispBear
                break
            // Check if this candle is bearish (opposite to bullish impulse)
            if close[candidateIdx] < open[candidateIdx]
                bullOBIdx := candidateIdx
                bullOB := true
                break
    
    // 2. Scan 1-3 candles back from impulse to find nearest opposite (bullish) candle
    if bearImpulseIdx >= 0
        float bearImpBody = open[bearImpulseIdx] - close[bearImpulseIdx]
        float atrAtBearImpulse = atr[bearImpulseIdx]  // Use ATR at impulse candle (from global atr series)
        bearImpulseStrength := atrAtBearImpulse > 0 ? bearImpBody / atrAtBearImpulse : 0.0  // Normalized strength
        
        for j = 1 to obScanWindow
            int candidateIdx = bearImpulseIdx + j
            if candidateIdx > bar_index
                break
            // Stop if we hit another qualifying displacement candle
            float body = math.abs(close[candidateIdx] - open[candidateIdx])
            float range_c = high[candidateIdx] - low[candidateIdx]
            float atrAtIdx = atr[candidateIdx]  // Use ATR at the historical candle (atr series already calculated)
            bool sizeOk = body > atrAtIdx * dispAtrBodyMult
            bool dominanceOk = range_c > 0 ? body / range_c > dispBodyToRangeMin : false
            bool dispBull = sizeOk and dominanceOk and close[candidateIdx] > open[candidateIdx]
            bool dispBear = sizeOk and dominanceOk and close[candidateIdx] < open[candidateIdx]
            if dispBull or dispBear
                break
            // Check if this candle is bullish (opposite to bearish impulse)
            if close[candidateIdx] > open[candidateIdx]
                bearOBIdx := candidateIdx
                bearOB := true
                break
    
    [bearOB, bullOB, bearOBIdx, bullOBIdx, bearImpulseStrength, bullImpulseStrength]

// === VISUAL GENERATION ===
createVolumeGradient(OrderBlock block, int leftBar, int segments, string rMode) =>
    boxArray = array.new<box>()
    
    // Check render mode (uses effective settings)
    if rMode == "Gradient"
        // Create elegant gradient layers with edge-to-center fading
        float blockHeight = block.top - block.bot
        // Ensure segments is at least 2 to prevent division by zero
        int safeSegments = math.max(segments, 2)
        float segmentHeight = blockHeight / safeSegments  // Pre-compute loop invariant
        int lastSegment = safeSegments - 1                // Pre-compute loop invariant
        float invLastSegment = 1.0 / lastSegment          // Pre-compute for progress calculation (safe: lastSegment >= 1)
        bool isStrong = block.strength == "Strong" or block.strength == "Elite"

        // Base colors
        color baseCol = block.direction == DIR_BULL ? bullBorder : bearBorder

        // Use bar_index instead of time for boxes to avoid xloc issues
        int leftBarIdx = leftBar
        int rightBarIdx = bar_index

        // Create multiple gradient layers for smooth visual
        for i = 0 to lastSegment
            float topGrid = block.top - segmentHeight * i
            float botGrid = block.top - segmentHeight * (i + 1)

            // Edge-to-center gradient (strongest in middle)
            float progress = i * invLastSegment
            float centerWeight = 1.0 - math.abs(progress - 0.5) * 2.0  // Peak at center

            // Elegant transparency gradient
            // Strong/Elite: more visible (70-95), Weak/Mid: much lighter (88-95)
            int alpha = isStrong ?
                 int(70 + centerWeight * 25) :  // More visible for strong/elite
                 int(88 + centerWeight * 7)      // Much lighter for weak/mid

            color layerCol = color.new(baseCol, alpha)

            // Full-width boxes using bar_index (default xloc)
            box newBox = box.new(leftBarIdx, topGrid, rightBarIdx, botGrid,
                 border_width=0, bgcolor=layerCol)
            array.push(boxArray, newBox)
    else if rMode == "Simple fill"
        // Simple mode: single fill box (much fewer objects)
        color baseCol = block.direction == DIR_BULL ? bullBorder : bearBorder
        bool isStrong = block.strength == "Strong" or block.strength == "Elite"
        // Strong/Elite use fillAlpha, Weak/Mid are much lighter (90)
        int simpleAlpha = isStrong ? fillAlpha : 90
        color fillCol = color.new(baseCol, simpleAlpha)
        int leftBarIdx = leftBar
        int rightBarIdx = bar_index

        box fillBox = box.new(leftBarIdx, block.top, rightBarIdx, block.bot,
             border_width=0, bgcolor=fillCol)
        array.push(boxArray, fillBox)
    // else "Borders only" - no fill boxes created
    
    boxArray

createBorder(OrderBlock block, int leftTime, string rMode) =>
    color baseCol = block.direction == DIR_BULL ? bullBorder : bearBorder
    
    // Top line (full length, subtle)
    color mainLineCol = color.new(baseCol, 30)
    line topLine = line.new(x1=leftTime, y1=block.top, x2=time, y2=block.top, 
         xloc=xloc.bar_time, color=mainLineCol, width=1, style=line.style_dotted)
    
    // Bottom line (full length, subtle)
    line botLine = line.new(x1=leftTime, y1=block.bot, x2=time, y2=block.bot, 
         xloc=xloc.bar_time, color=mainLineCol, width=1, style=line.style_dotted)
    
    // Glow effect for strong blocks (multiple transparent fills) - only if not "Borders only"
    linefill fill = na
    
    if rMode != "Borders only"
        if block.strength == "Strong" or block.strength == "Elite"
            // Add glow with gradient fill
            color glowCol = color.new(baseCol, 85)
            fill := linefill.new(topLine, botLine, glowCol)
        else
            // Much lighter fill for Weak/Mid blocks (alpha 90 for subtlety)
            color fillCol = color.new(baseCol, 90)
            fill := linefill.new(topLine, botLine, fillCol)
    
    [topLine, botLine, fill]

createCornerAccents(OrderBlock block, int leftBar, string rMode) =>
    // Create elegant corner markers
    corners = array.new<box>()
    
    // Only create corners if enabled, for Strong/Elite blocks, and not in Borders only mode
    if showCornerAccents and (block.strength == "Strong" or block.strength == "Elite") and rMode != "Borders only"
        color accentCol = block.direction == DIR_BULL ? bullBorder : bearBorder
        float blockHeight = block.top - block.bot
        float cornerHeight = blockHeight * 0.15  // 15% of block height
        int cornerWidth = 6  // 6 bars width
        
        // Use bar_index for corners
        int leftBarIdx = leftBar
        int rightBarIdx = leftBarIdx + cornerWidth
        
        // Top-left corner
        box tlCorner = box.new(leftBarIdx, block.top, 
             rightBarIdx, block.top - cornerHeight, 
             border_color=accentCol, border_width=2, bgcolor=color.new(accentCol, 70))
        array.push(corners, tlCorner)
        
        // Bottom-left corner
        box blCorner = box.new(leftBarIdx, block.bot + cornerHeight,
             rightBarIdx, block.bot,
             border_color=accentCol, border_width=2, bgcolor=color.new(accentCol, 70))
        array.push(corners, blCorner)
    
    corners

buildLabelText(OrderBlock block) =>
    string labelText = ""
    
    // Strength indicator (using elegant symbols)
    if showStrength
        if block.strength == "Elite"
            labelText += "â˜… "
        else if block.strength == "Strong"
            labelText += "â—† "
        else if block.strength == "Mid"
            labelText += "â—‡ "
        else
            labelText += "â—‹ "
    
    // Volume
    if showVolLabel
        labelText += formatVolume(block.totalVolume)
    
    // Retest count with elegant format
    if showRetests and block.retestCount > 0
        labelText += "\n" + str.tostring(block.retestCount) + "Ã— TEST"
    
    // Status indicator
    if block.rejected
        labelText += block.direction == DIR_BULL ? "\nâ†— BOUNCE" : "\nâ†˜ REJECT"
    else if block.touched
        labelText += "\nâ— ACTIVE"
    
    labelText

// === LIQUIDITY SWEEP VISUAL FUNCTIONS ===
// Create horizontal level line for liquidity pool
createLiquidityLevel(float level, int startBar, bool isBSL) =>
    color levelCol = isBSL ? bslColor : sslColor
    line levelLine = line.new(startBar, level, bar_index, level,
         xloc=xloc.bar_index, color=levelCol, width=1, style=line.style_dashed)
    levelLine

// Create sweep event highlight box
createSweepBox(float level, float wickExtent, int sweepBar, bool isBullish) =>
    color boxCol = isBullish ? sweepBullColor : sweepBearColor
    float top = isBullish ? level : level + wickExtent
    float bot = isBullish ? level - wickExtent : level
    box sweepBox = box.new(sweepBar - 1, top, sweepBar + 2, bot,
         border_color=boxCol, border_width=2, bgcolor=color.new(boxCol, 80))
    sweepBox

// Create sweep label
createSweepLabel(float level, float wickExtent, int sweepBar, bool isBullish, string quality) =>
    string txt = (isBullish ? "SWEEP â†—" : "SWEEP â†˜") + "\n" + quality
    color txtCol = isBullish ? sweepBullColor : sweepBearColor
    // Position label above (bearish) or below (bullish) the wick
    float labelPrice = isBullish ? level - wickExtent : level + wickExtent
    string labelStyle = isBullish ? label.style_label_up : label.style_label_down
    label lbl = label.new(sweepBar, labelPrice, txt, xloc=xloc.bar_index, yloc=yloc.price,
         color=color.new(#1a1a1a, 15), style=labelStyle, textcolor=txtCol, size=size.small)
    lbl

createVolumeLabel(OrderBlock block) =>
    // Create elegant side panel label
    float labelY = block.top - (block.top - block.bot) * 0.25  // Upper quarter position
    
    // Elegant label styling with dark background and colored accent
    color bgCol = color.new(#1a1a1a, 15)  // Dark semi-transparent background
    color textCol = block.direction == DIR_BULL ? bullBorder : bearBorder
    
    // Create elegant label with dark bg and vibrant text
    label lbl = label.new(time, labelY, buildLabelText(block), xloc.bar_time, yloc.price, bgCol, label.style_label_left, textCol, size.small)
    
    lbl

deleteBlock(OrderBlock block) =>
    if not na(block.topLine)
        line.delete(block.topLine)
    if not na(block.botLine)
        line.delete(block.botLine)
    if not na(block.bgFill)
        linefill.delete(block.bgFill)
    if not na(block.volLabel)
        label.delete(block.volLabel)
    
    int volBoxCount = array.size(block.volumeBoxes)
    if volBoxCount > 0
        for i = 0 to volBoxCount - 1
            box.delete(array.get(block.volumeBoxes, i))
    
    int cornerCount = array.size(block.cornerBoxes)
    if cornerCount > 0
        for i = 0 to cornerCount - 1
            box.delete(array.get(block.cornerBoxes, i))

processBlocks(array<OrderBlock> blocks, bool isBull) =>
    bool touched = false
    bool rejected = false
    
    int blockCount = array.size(blocks)
    if blockCount > 0
        for i = blockCount - 1 to 0
            OrderBlock block = array.get(blocks, i)
            
            if not block.mitigated
                // Check mitigation (user-configurable)
                bool mitigated = false
                float zoneHeight = block.top - block.bot
                float minPenetration = math.max(zoneHeight * minPenZonePct, atr * minPenAtrPct)
                
                if mitigationMethod == "Wick"
                    mitigated := isBull ? low < block.bot - minPenetration : high > block.top + minPenetration
                else if mitigationMethod == "Close"
                    mitigated := isBull ? close < block.bot : close > block.top
                else  // Mean
                    float mean = block.bot + (zoneHeight * meanMitigationLevel)
                    mitigated := isBull ? close < mean : close > mean
                
                if mitigated
                    block.mitigated := true
                    deleteBlock(block)
                    array.remove(blocks, i)
                    continue
                
                // Track touches (user-configurable)
                bool inZone = false
                if touchMode == "Wick"
                    inZone := low <= block.top and high >= block.bot
                else  // "Close inside zone"
                    inZone := close >= block.bot and close <= block.top
                
                if inZone
                    if retestDebounce == "Require exit before recount"
                        if not block.touched
                            block.touched := true
                            block.retestCount += 1
                            touched := true
                    else  // "Count each bar in zone"
                        block.retestCount += 1
                        touched := true
                        block.touched := true
                else
                    // Reset touched flag when price exits the zone
                    if block.touched
                        block.touched := false
                
                // Track rejections (user-configurable)
                if enableRejection
                    float rejectionLevel = 0.0
                    
                    if rejectionCloseLevel == "Mid"
                        rejectionLevel := (block.top + block.bot) / 2
                    else if rejectionCloseLevel == "Top/Bottom"
                        rejectionLevel := isBull ? block.top : block.bot
                    else  // "Percent into zone"
                        rejectionLevel := isBull ? (block.bot + (zoneHeight * rejectionPercent)) : (block.top - (zoneHeight * rejectionPercent))
                    
                    if isBull
                        if low <= block.bot and close >= rejectionLevel
                            if not block.rejected  // Only trigger once
                                block.rejected := true
                                rejected := true
                    else
                        if high >= block.top and close <= rejectionLevel
                            if not block.rejected  // Only trigger once
                                block.rejected := true
                                rejected := true
    
    [touched, rejected]

updateBlock(OrderBlock block, int currentTime, int segments) =>
    // Only extend visuals on new bars (not every tick)
    bool isNewBar = na(block.lastUpdateBar) or bar_index > block.lastUpdateBar

    if isNewBar
        // Update gradient boxes - extend to current bar (boxes use bar_index)
        int volBoxCount = array.size(block.volumeBoxes)
        if volBoxCount > 0
            // Ensure segments is at least 1 to prevent negative index
            int safeSegments = math.max(segments, 1)
            int maxIdx = math.min(safeSegments - 1, volBoxCount - 1)
            for i = 0 to maxIdx
                box.set_right(array.get(block.volumeBoxes, i), bar_index)

        // Update border lines (lines use time)
        if not na(block.topLine)
            line.set_x2(block.topLine, currentTime)
        if not na(block.botLine)
            line.set_x2(block.botLine, currentTime)

        // Update label position (labels use time)
        if not na(block.volLabel)
            label.set_x(block.volLabel, currentTime)

        block.lastUpdateBar := bar_index

    // Only rebuild label text on state change (not every bar)
    if showAnyLabel and not na(block.volLabel)
        bool stateChanged = block.retestCount != block.lastRetestCount or
                           block.touched != block.lastTouched or
                           block.rejected != block.lastRejected
        if stateChanged
            float labelY = block.top - (block.top - block.bot) * 0.25
            label.set_y(block.volLabel, labelY)
            label.set_text(block.volLabel, buildLabelText(block))
            block.lastRetestCount := block.retestCount
            block.lastTouched := block.touched
            block.lastRejected := block.rejected

updateBlocks(array<OrderBlock> blocks, int segments) =>
    int blockCount = array.size(blocks)
    if blockCount > 0
        for i = 0 to blockCount - 1
            updateBlock(array.get(blocks, i), time, segments)

trimBlocks(array<OrderBlock> blocks, int maxCount) =>
    if array.size(blocks) > maxCount
        deleteBlock(array.shift(blocks))

createOrderBlock(int idx, bool isBull, array<OrderBlock> blocks, bool shouldCreate) =>
    bool created = false
    if shouldCreate and idx > 0 and idx <= bar_index
        float top = high[idx]
        float bot = low[idx]
        
        // Smart sizing - now configurable with ICT-aligned anchoring
        bool applySmartSizing = blockSizing == "Smart" and (smartSizingAppliesTo == "All timeframes" or is_scalping)
        if applySmartSizing
            float minZoneHeight = syminfo.mintick
            float safeAtr = na(atr) ? math.max(high[idx] - low[idx], minZoneHeight) : atr
            if isBull
                // BULLISH OB: Anchor from BOTTOM (demand zone)
                // Zone sits near low/open where institutions accumulated
                float anchorBot = smartAnchor == "Wick" ? low[idx] : math.min(open[idx], close[idx])
                bot := anchorBot
                float maxTop = math.min(high[idx], anchorBot + safeAtr * smartSizeAtrMult)
                top := math.max(maxTop, bot + minZoneHeight)
            else
                // BEARISH OB: Anchor from TOP (supply zone)
                // Zone sits near high/open where institutions distributed
                float anchorTop = smartAnchor == "Wick" ? high[idx] : math.max(open[idx], close[idx])
                top := anchorTop
                float minBot = math.max(low[idx], anchorTop - safeAtr * smartSizeAtrMult)
                bot := math.min(minBot, top - minZoneHeight)
        else if blockSizing == "Body Only"
            top := math.max(open[idx], close[idx])
            bot := math.min(open[idx], close[idx])
        
        int leftTime = time[idx]
        float vol = volume[idx]
        bool aligned = isBull ? close[idx] > sma50[idx] : close[idx] < sma50[idx]
        float body = math.abs(close[idx] - open[idx])
        
        // Volume Profile analysis (Premium feature)
        float vpConcentration = useVolumeProfile ? analyzeVolumeProfile(top, bot, vpLookbackEff) : 0.0
        
        // Enhanced strength with VP
        string strength = useVolumeProfile ?
             getEnhancedStrength(vol, body, aligned, vpConcentration) :
             getStrength(vol, body, aligned)

        // Filter: Skip weak/mid blocks if only showing Strong/Elite
        bool skipNewBlock = showOnlyStrongElite and strength != "Strong" and strength != "Elite"

        // Handle overlapping blocks - keep higher quality
        // Single-pass with deferred batch deletion (O(N) instead of O(NÂ²))
        int newScore = strengthScore(strength)
        int[] indicesToRemove = array.new<int>()

        int blockCount = array.size(blocks)
        if blockCount > 0
            for i = 0 to blockCount - 1
                OrderBlock b = array.get(blocks, i)
                bool overlaps = math.max(b.bot, bot) <= math.min(b.top, top)
                if overlaps
                    if strengthScore(b.strength) >= newScore
                        skipNewBlock := true
                        break
                    else
                        array.push(indicesToRemove, i)

        // Batch removal in reverse order (preserves indices)
        if not skipNewBlock
            int removeCount = array.size(indicesToRemove)
            if removeCount > 0
                for j = removeCount - 1 to 0
                    int idx_to_remove = array.get(indicesToRemove, j)
                    deleteBlock(array.get(blocks, idx_to_remove))
                    array.remove(blocks, idx_to_remove)

            int leftBar = bar_index - idx

            // Guard against na/inf for relative volume
            float relVol = (not na(avgVol) and avgVol > 0) ? vol / avgVol : 1.0
            int direction = isBull ? DIR_BULL : DIR_BEAR

            // Create new block
            OrderBlock newBlock = OrderBlock.new(
                 array.new<box>(), na, na, na, na, array.new<box>(),
                 top, bot, direction,
                 vol, relVol, strength, false, 0, false, false,
                 na, 0, false, false)  // State tracking: lastUpdateBar, lastRetestCount, lastTouched, lastRejected
            
            box[] volBoxes = createVolumeGradient(newBlock, leftBar, effectiveGridSegments, effectiveRenderMode)
            newBlock.volumeBoxes := volBoxes
            
            [topLine, botLine, fill] = createBorder(newBlock, leftTime, effectiveRenderMode)
            newBlock.topLine := topLine
            newBlock.botLine := botLine
            newBlock.bgFill := fill
            
            // Add corner accents
            newBlock.cornerBoxes := createCornerAccents(newBlock, leftBar, effectiveRenderMode)
            
            // Create label if any label feature is enabled
            if showAnyLabel
                label lbl = createVolumeLabel(newBlock)
                newBlock.volLabel := lbl
            
            array.push(blocks, newBlock)
            created := true
    
    created

// === LIQUIDITY SWEEP HELPER FUNCTIONS ===
// Delete liquidity sweep visuals
deleteLiquiditySweep(LiquiditySweep sweep) =>
    if not na(sweep.levelLine)
        line.delete(sweep.levelLine)
    if not na(sweep.sweepBox)
        box.delete(sweep.sweepBox)
    if not na(sweep.sweepLabel)
        label.delete(sweep.sweepLabel)

// Update liquidity level line
updateLiquidityLevel(LiquiditySweep sweep) =>
    if not na(sweep.levelLine) and not sweep.swept and not sweep.ranThrough
        line.set_x2(sweep.levelLine, bar_index)

// Create liquidity level entry with equal H/L check
createLiquidityLevelEntry(float level, int levelBar, bool isBSL, array<LiquiditySweep> levels, bool createVisualLine) =>
    bool isEqual = false
    
    // Check existing levels for "equality" (clustered stops)
    int levelCount = array.size(levels)
    if markEqualHL and levelCount > 0
        for i = 0 to levelCount - 1
            LiquiditySweep existing = array.get(levels, i)
            if isEqualLevel(level, existing.level, equalHLThreshold)
                isEqual := true
                existing.isEqual := true  // Mark existing as equal too
                break
    
    // Create level line only if requested
    line levelLine = na
    if createVisualLine
        levelLine := createLiquidityLevel(level, levelBar, isBSL)
    
    // Create LiquiditySweep object
    int direction = isBSL ? DIR_BEAR : DIR_BULL  // BSL breaks bearish, SSL breaks bullish
    LiquiditySweep newLevel = LiquiditySweep.new(
         levelLine, na, na, level, levelBar, direction, isEqual,
         false, false, 0, 0.0, 0.0, "", false, 0, bar_index)
    
    array.push(levels, newLevel)

// Process sweeps and runs for liquidity levels
// Returns: [sweepDetected, runDetected, sweepBar]
// NOTE: Detection is decoupled from visuals - sweeps/runs are always detected when conditions met,
//       but visuals (boxes/labels) are only created when showSweepEvents is true.
//       This enables alerts-only mode (alerts fire without any visual clutter).
processSweepsAndRuns(array<LiquiditySweep> levels, bool isBSL) =>
    bool sweepDetected = false
    bool runDetected = false
    int sweepBar = 0
    
    int levelCount = array.size(levels)
    if levelCount > 0
        for i = levelCount - 1 to 0
            LiquiditySweep sweep = array.get(levels, i)
            
            // Skip if already swept or run
            if sweep.swept or sweep.ranThrough
                continue
            
            if isBSL
                // Check for bearish sweep (BSL taken, price reverses down)
                [detected, wickExt] = checkBearishSweep(sweep.level, sweepWickMin)
                if detected
                    // Always update state (detection decoupled from visuals)
                    sweep.swept := true
                    sweep.sweepBar := bar_index
                    sweep.sweepWick := wickExt
                    sweep.sweepClose := close
                    
                    // Check confluence with order blocks
                    bool nearOB = false
                    int bullBlockCount = array.size(bullBlocks)
                    if bullBlockCount > 0
                        for j = 0 to bullBlockCount - 1
                            OrderBlock b = array.get(bullBlocks, j)
                            if math.abs(sweep.level - b.top) / sweep.level * 100 < 0.5
                                nearOB := true
                                break
                    
                    // Calculate quality
                    bool volSpike = volume > avgVol
                    sweep.quality := getSweepQuality(wickExt, volSpike, nearOB, sweep.isEqual)
                    
                    // Only create visuals when showSweepEvents is enabled
                    if showSweepEvents
                        sweep.sweepBox := createSweepBox(sweep.level, wickExt, bar_index, false)
                        sweep.sweepLabel := createSweepLabel(sweep.level, wickExt, bar_index, false, sweep.quality)
                    
                    sweepDetected := true
                    sweepBar := bar_index
                else
                    // Check for bearish run (BSL taken, price continues up)
                    bool detected2 = checkBearishRun(sweep.level)
                    if detected2
                        // Always update state (detection decoupled from visuals)
                        sweep.ranThrough := true
                        sweep.sweepBar := bar_index
                        runDetected := true
            else
                // Check for bullish sweep (SSL taken, price reverses up)
                [detected, wickExt] = checkBullishSweep(sweep.level, sweepWickMin)
                if detected
                    // Always update state (detection decoupled from visuals)
                    sweep.swept := true
                    sweep.sweepBar := bar_index
                    sweep.sweepWick := wickExt
                    sweep.sweepClose := close
                    
                    // Check confluence with order blocks
                    bool nearOB = false
                    int bearBlockCount = array.size(bearBlocks)
                    if bearBlockCount > 0
                        for j = 0 to bearBlockCount - 1
                            OrderBlock b = array.get(bearBlocks, j)
                            if math.abs(sweep.level - b.bot) / sweep.level * 100 < 0.5
                                nearOB := true
                                break
                    
                    // Calculate quality
                    bool volSpike = volume > avgVol
                    sweep.quality := getSweepQuality(wickExt, volSpike, nearOB, sweep.isEqual)
                    
                    // Only create visuals when showSweepEvents is enabled
                    if showSweepEvents
                        sweep.sweepBox := createSweepBox(sweep.level, wickExt, bar_index, true)
                        sweep.sweepLabel := createSweepLabel(sweep.level, wickExt, bar_index, true, sweep.quality)
                    
                    sweepDetected := true
                    sweepBar := bar_index
                else
                    // Check for bullish run (SSL taken, price continues down)
                    bool detected2 = checkBullishRun(sweep.level)
                    if detected2
                        // Always update state (detection decoupled from visuals)
                        sweep.ranThrough := true
                        sweep.sweepBar := bar_index
                        runDetected := true
    
    [sweepDetected, runDetected, sweepBar]

// Update all liquidity levels
updateLiquidityLevels(array<LiquiditySweep> levels) =>
    int levelCount = array.size(levels)
    if levelCount > 0
        for i = 0 to levelCount - 1
            updateLiquidityLevel(array.get(levels, i))

// Trim old liquidity levels
trimLevels(array<LiquiditySweep> levels, int maxCount) =>
    if array.size(levels) > maxCount
        // Remove oldest swept/run levels first
        for i = array.size(levels) - 1 to 0
            if array.size(levels) <= maxCount
                break
            LiquiditySweep sweep = array.get(levels, i)
            if sweep.swept or sweep.ranThrough
                deleteLiquiditySweep(sweep)
                array.remove(levels, i)
        
        // If still too many, remove oldest
        while array.size(levels) > maxCount
            deleteLiquiditySweep(array.shift(levels))

// Check proximity to liquidity levels
checkLiquidityProximity(array<LiquiditySweep> levels, bool isBSL) =>
    bool isNear = false
    int levelCount = array.size(levels)
    if levelCount > 0
        for i = 0 to levelCount - 1
            LiquiditySweep sweep = array.get(levels, i)
            if sweep.swept or sweep.ranThrough
                continue
            
            float dist = 0.0
            if isBSL
                dist := sweep.level > close ? (sweep.level - close) / close * 100 : -1.0
            else
                dist := sweep.level < close ? (close - sweep.level) / close * 100 : -1.0
            
            if dist > 0 and dist <= liquidityProximityPct
                isNear := true
                break
    isNear

// === DETECTION LOGIC ===
bool validBull = false
bool validBear = false
int scalperBullIdx = 0
int scalperBearIdx = 0

// === PERFORMANCE: Skip detection on intrabar ticks in Confirmed mode ===
// OBs only form on bar close, so detection calculations are wasted on every tick
// Realtime mode: run detection every tick (for live feedback)
// Confirmed mode: only run detection on bar close (significant CPU savings)
bool shouldRunDetection = signalTiming == "Realtime (intrabar)" or barstate.isconfirmed

// Pre-compute filter results only when needed (Institutional method + filter enabled)
// Scalper method doesn't use these filters, so skip computation entirely
bool hasDisplacement = false
bool hasBullFVG = false
bool hasBearFVG = false
bool hasBullMSB = false
bool hasBearMSB = false

if shouldRunDetection and detectionMethod == "Institutional"
    if useDisplacement
        hasDisplacement := checkDisplacement(actualLookback - 1, dispMagnitude)
    if actualFVG
        hasBullFVG := checkFVG(actualLookback, "Bull")
        hasBearFVG := checkFVG(actualLookback, "Bear")
    if actualMSB
        hasBullMSB := checkMSB(actualLookback, actualLookback - 1, actualMsbPeriod, "Bull")
        hasBearMSB := checkMSB(actualLookback, actualLookback - 1, actualMsbPeriod, "Bear")

if shouldRunDetection and detectionMethod == "Scalper"
    // === SCALPER DETECTION (ICT/SMC Method - Candle immediately before impulse) ===
    [scalperBear, scalperBull, bearIdx, bullIdx, bearImpStr, bullImpStr] = checkScalperCondition(scalperLookback)
    validBull := scalperBull
    validBear := scalperBear
    scalperBullIdx := bullIdx
    scalperBearIdx := bearIdx

    // Mutual exclusivity: if both trigger, pick the one with stronger IMPULSE candle
    if validBull and validBear
        // Compare impulse candle strength (not OB candle)
        if bullImpStr >= bearImpStr
            validBear := false
        else
            validBull := false
else if shouldRunDetection
    // === INSTITUTIONAL DETECTION (Pivot-based with filters - stricter) ===
    bool isPivotLow = false
    bool isPivotHigh = false

    // Early-bars guard: need at least actualLookback * 2 bars of history
    if bar_index >= actualLookback * 2
        isPivotLow := true
        isPivotHigh := true

        for i = 1 to actualLookback
            if low[actualLookback] >= low[actualLookback + i] or low[actualLookback] >= low[actualLookback - i]
                isPivotLow := false
            if high[actualLookback] <= high[actualLookback + i] or high[actualLookback] <= high[actualLookback - i]
                isPivotHigh := false
            // Early exit if both already failed
            if not isPivotLow and not isPivotHigh
                break

    // Validation
    validBull := isPivotLow
    validBear := isPivotHigh

    // Filter: Displacement (use pre-computed values)
    if useDisplacement
        if validBull and close[actualLookback - 1] <= open[actualLookback - 1]
            validBull := false
        if validBear and close[actualLookback - 1] >= open[actualLookback - 1]
            validBear := false

        if validBull and not hasDisplacement
            validBull := false
        if validBear and not hasDisplacement
            validBear := false

    // Filter: FVG (use pre-computed values)
    if actualFVG
        if validBull and not hasBullFVG
            validBull := false
        if validBear and not hasBearFVG
            validBear := false

    // Filter: MSB (use pre-computed values)
    if actualMSB
        if validBull and not hasBullMSB
            validBull := false
        if validBear and not hasBearMSB
            validBear := false

// === CREATE ORDER BLOCKS ===
bool shouldCreateBull = barstate.isconfirmed and validBull
bool shouldCreateBear = barstate.isconfirmed and validBear
int bullIdx = detectionMethod == "Scalper" ? scalperBullIdx : actualLookback
int bearIdx = detectionMethod == "Scalper" ? scalperBearIdx : actualLookback
newBullOB := createOrderBlock(bullIdx, true, bullBlocks, shouldCreateBull)
newBearOB := createOrderBlock(bearIdx, false, bearBlocks, shouldCreateBear)

// === UPDATE & MITIGATION ===
// Update all blocks first (for proper anchoring)
updateBlocks(bullBlocks, effectiveGridSegments)
updateBlocks(bearBlocks, effectiveGridSegments)

// Then check mitigation and touches
[bullTouchTmp, bullRejectTmp] = processBlocks(bullBlocks, true)
bullTouch := bullTouchTmp
bullReject := bullRejectTmp
[bearTouchTmp, bearRejectTmp] = processBlocks(bearBlocks, false)
bearTouch := bearTouchTmp
bearReject := bearRejectTmp

// === OB TOUCH ANTI-SPAM LATCH ===
// Compute "in zone" state per side (must respect touchMode setting)
// This checks if price overlaps ANY active (non-mitigated) block of each side
isInAnyBlock(array<OrderBlock> blocks, string mode) =>
    bool inAny = false
    int blockCount = array.size(blocks)
    if blockCount > 0
        // Pre-compute mode check outside loop
        bool useWickMode = mode == "Wick"
        for i = 0 to blockCount - 1
            OrderBlock b = array.get(blocks, i)
            if b.mitigated
                continue
            // Respect touchMode setting (same logic as retest detection)
            bool inZone = useWickMode ? (low <= b.top and high >= b.bot) : (close >= b.bot and close <= b.top)
            if inZone
                inAny := true
                break
    inAny

bool inBullOBNow = isInAnyBlock(bullBlocks, touchMode)
bool inBearOBNow = isInAnyBlock(bearBlocks, touchMode)

// Edge-trigger: fire alert only on FIRST entry into any OB zone of that side
bool bullTouchTrigger = inBullOBNow and not wasInBullOB
bool bearTouchTrigger = inBearOBNow and not wasInBearOB

// Update latch state (must persist across bars, NOT reset each bar)
wasInBullOB := inBullOBNow
wasInBearOB := inBearOBNow

// === PROXIMITY ALERT DETECTION ===
if proximityAlertEnabled
    // Find nearest qualifying OB zones
    [nearBull, distBull] = findNearestOB(bullBlocks, true)
    [nearBear, distBear] = findNearestOB(bearBlocks, false)
    
    // Trigger alert only on state change (entering proximity range)
    // This prevents spam - only alerts once when first entering the zone
    nearBullOB := nearBull and not wasNearBullOB
    nearBearOB := nearBear and not wasNearBearOB
    
    // Update state for next bar
    wasNearBullOB := nearBull
    wasNearBearOB := nearBear

// Memory management (user-configurable)
int effectiveMaxBlocks = maxBlocks
if maxBlocksUser != "Auto"
    effectiveMaxBlocks := int(math.round(str.tonumber(maxBlocksUser)))

trimBlocks(bullBlocks, effectiveMaxBlocks)
trimBlocks(bearBlocks, effectiveMaxBlocks)

// === LIQUIDITY SWEEP DETECTION ===
// Gate all liquidity behavior behind enableLiquidity master toggle
// Run detection if ANY liquidity feature is enabled (visuals OR alerts)
bool liquidityVisualsEnabled = showLiquidityLevels or showSweepEvents or showLiquidityRuns
bool liquidityAlertsEnabled = alertLiquiditySweep or alertLiquidityRun or alertApproachingLiquidity
bool shouldRunLiquidity = enableLiquidity and (liquidityVisualsEnabled or liquidityAlertsEnabled)

if shouldRunLiquidity
    // 1. Detect new swing highs/lows (confirmed after rightBars)
    int confirmBars = math.round(sweepLookback / 2)
    [isNewSwingHigh, shLevel] = findSwingHigh(sweepLookback, confirmBars)
    [isNewSwingLow, slLevel] = findSwingLow(sweepLookback, confirmBars)

    // 2. Add new BSL levels (swing highs) - check for equal highs
    if isNewSwingHigh and barstate.isconfirmed
        createLiquidityLevelEntry(shLevel, bar_index - confirmBars, true, bslLevels, showLiquidityLevels)

    // 3. Add new SSL levels (swing lows) - check for equal lows
    if isNewSwingLow and barstate.isconfirmed
        createLiquidityLevelEntry(slLevel, bar_index - confirmBars, false, sslLevels, showLiquidityLevels)

    // 4. Check for sweeps AND runs on existing levels
    [bearSweep, bearRun, _] = processSweepsAndRuns(bslLevels, true)   // Check BSL for bearish sweeps/runs
    [bullSweep, bullRun, _] = processSweepsAndRuns(sslLevels, false)  // Check SSL for bullish sweeps/runs

    // Update global flags
    bearSweepDetected := bearSweep
    bearRunDetected := bearRun
    bullSweepDetected := bullSweep
    bullRunDetected := bullRun

    // 5. Update visuals (only if showing levels)
    if showLiquidityLevels
        updateLiquidityLevels(bslLevels)
        updateLiquidityLevels(sslLevels)

    // 6. Trim old levels (remove swept/run levels after N bars)
    trimLevels(bslLevels, maxLiquidityLevels)
    trimLevels(sslLevels, maxLiquidityLevels)
    
    // 7. Check proximity alerts (also gated by enableLiquidity)
    if alertApproachingLiquidity
        nearBSL := checkLiquidityProximity(bslLevels, true)
        nearSSL := checkLiquidityProximity(sslLevels, false)

// === LIQUIDITY PROXIMITY ANTI-SPAM LATCH ===
// Edge-trigger: fire alert only on FIRST entry into proximity zone
// Re-arm when price exits the zone
bool triggerNearBSL = nearBSL and not wasNearBSL
bool triggerNearSSL = nearSSL and not wasNearSSL

// Update latch state (must persist across bars, NOT reset each bar)
if nearBSL
    wasNearBSL := true
else
    wasNearBSL := false  // Re-arm when price exits proximity

if nearSSL
    wasNearSSL := true
else
    wasNearSSL := false  // Re-arm when price exits proximity

// === DASHBOARD ===
// Helper function to map location string to position enum
getDashboardPosition(string loc) =>
    loc == "Top Left" ? position.top_left : loc == "Bottom Right" ? position.bottom_right : loc == "Bottom Left" ? position.bottom_left : position.top_right

if showDashboard and barstate.islast
    // Check if location, transparency, or size changed - need to recreate table
    bool settingsChanged = (not na(lastDashboardLocation) and dashboardLocation != lastDashboardLocation) or
                           (not na(lastDashboardTransparency) and dashboardTransparency != lastDashboardTransparency) or
                           (not na(lastDashboardSize) and dashboardSize != lastDashboardSize)
    if settingsChanged
        if not na(dashboard)
            table.delete(dashboard)
            dashboard := na

    if na(dashboard)
        dashboard := table.new(getDashboardPosition(dashboardLocation), 7, 12, bgcolor=color.new(#000000, dashboardTransparency),
             border_color=color.new(color.white, 70), border_width=1)
        lastDashboardLocation := dashboardLocation
        lastDashboardTransparency := dashboardTransparency
        lastDashboardSize := dashboardSize

    table.clear(dashboard, 0, 0, 6, 11)
    
    // Header with mode tags
    table.merge_cells(dashboard, 0, 0, 6, 0)
    string presetDisplay = effectivePreset == "Scalping" ? "SCALPING" : effectivePreset == "Swing" ? "SWING" : "POSITION"
    string modeTag = settingsMode == "Auto" ? "MODE:AUTO" : "MODE:MANUAL"
    string confirmTag = signalTiming == "Confirmed (bar close)" ? " | CONFIRMED" : ""
    string headerText = presetDisplay + " | " + modeTag + confirmTag
    table.cell(dashboard, 0, 0, headerText, text_color=color.white, text_size=dashHeaderSize)

    // Column headers (width=0 auto-fits to content)
    table.cell(dashboard, 0, 1, "Type", text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 1, 1, "Volume", text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 2, 1, "Dist%", text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 3, 1, "Strength", text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 4, 1, "Tests", text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 5, 1, "Status", text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 6, 1, "Vol", text_color=color.gray, text_size=dashTextSize, width=0)
    
    int row = 2
    row := renderDashboardBlocks(dashboard, row, bearBlocks, false)
    row := renderDashboardBlocks(dashboard, row, bullBlocks, true)
    
    // Liquidity section (show if liquidity module is enabled with visuals OR any alerts)
    // Dashboard shows BSL/SSL info even in alerts-only mode (no visual lines)
    if enableLiquidity and (showLiquidityLevels or showSweepEvents or showLiquidityRuns or alertLiquiditySweep or alertLiquidityRun or alertApproachingLiquidity)
        int bslCount = array.size(bslLevels)
        int sslCount = array.size(sslLevels)
        if bslCount > 0 or sslCount > 0
            if row <= 7  // Leave rows 8-9 for Power
                table.cell(dashboard, 0, row, "LIQUIDITY", text_color=color.gray, text_size=dashTextSize, width=0)
                row += 1

            // Show nearest BSL
            if bslCount > 0 and row <= 7  // Leave rows 8-9 for Power
                LiquiditySweep nearestBSL = array.get(bslLevels, 0)
                float bslDist = 999999.0  // Start with sentinel value
                bool foundValidBSL = false
                for i = 0 to bslCount - 1
                    LiquiditySweep sweep = array.get(bslLevels, i)
                    if not sweep.swept and not sweep.ranThrough
                        float dist = (sweep.level - close) / close * 100
                        if dist > 0 and dist < bslDist
                            nearestBSL := sweep
                            bslDist := dist
                            foundValidBSL := true

                if foundValidBSL
                    string bslStatus = nearestBSL.isEqual ? "EQ BSL" : "BSL"
                    table.cell(dashboard, 0, row, bslStatus + " â–²", text_color=color.new(#00bfff, 0), text_size=dashTextSize, width=0)
                    table.cell(dashboard, 1, row, str.tostring(round2(bslDist)) + "%", text_color=color.white, text_size=dashTextSize, width=0)
                    row += 1

            // Show nearest SSL
            if sslCount > 0 and row <= 7  // Leave rows 8-9 for Power
                LiquiditySweep nearestSSL = array.get(sslLevels, 0)
                float sslDist = 999999.0  // Start with sentinel value
                bool foundValidSSL = false
                for i = 0 to sslCount - 1
                    LiquiditySweep sweep = array.get(sslLevels, i)
                    if not sweep.swept and not sweep.ranThrough
                        float dist = (close - sweep.level) / close * 100
                        if dist > 0 and dist < sslDist
                            nearestSSL := sweep
                            sslDist := dist
                            foundValidSSL := true

                if foundValidSSL
                    string sslStatus = nearestSSL.isEqual ? "EQ SSL" : "SSL"
                    table.cell(dashboard, 0, row, sslStatus + " â–¼", text_color=color.new(#ff6600, 0), text_size=dashTextSize, width=0)
                    table.cell(dashboard, 1, row, str.tostring(round2(sslDist)) + "%", text_color=color.white, text_size=dashTextSize, width=0)
                    row += 1
    
    // === POWER ROW (Intrabar Volume Dominance) - Always at bottom ===
    if showPowerRow
        // Use fixed rows at bottom of table (rows 8 and 9)
        int powerSepRow = 8
        int powerDataRow = 9
        
        // Format LTF indicator for display
        string ltfDisplay = effectivePowerLtf == "1" ? "@1m" : effectivePowerLtf == "5" ? "@5m" : 
             effectivePowerLtf == "15" ? "@15m" : effectivePowerLtf == "60" ? "@1h" : 
             effectivePowerLtf == "240" ? "@4h" : "@" + effectivePowerLtf
        
        // Separator line with LTF indicator
        string powerHeader = "POWER " + ltfDisplay
        table.cell(dashboard, 0, powerSepRow, powerHeader, text_color=color.gray, text_size=dashTextSize, width=0)
        table.cell(dashboard, 1, powerSepRow, "", text_size=dashTextSize, width=0)
        table.cell(dashboard, 2, powerSepRow, "", text_size=dashTextSize, width=0)
        table.cell(dashboard, 3, powerSepRow, "", text_size=dashTextSize, width=0)
        table.cell(dashboard, 4, powerSepRow, "", text_size=dashTextSize, width=0)
        table.cell(dashboard, 5, powerSepRow, "", text_size=dashTextSize, width=0)
        table.cell(dashboard, 6, powerSepRow, "", text_size=dashTextSize, width=0)
        
        // Select display values based on signal timing mode
        // Confirmed mode uses latched values (stable, no intrabar flicker)
        // Realtime mode uses live values (updates every tick)
        int displaySide = signalTiming == "Confirmed (bar close)" ? latchedPowerSide : powerSide
        float displayPctRaw = signalTiming == "Confirmed (bar close)" ? latchedPowerPct : (na(smoothedPowerPct) ? 0.0 : smoothedPowerPct)
        int displayIntrabarCount = signalTiming == "Confirmed (bar close)" ? latchedIntrabarCount : intrabarCount
        // Include na(smoothedPowerPct) check so "â€”" is shown instead of "0%" when data is invalid
        bool displayLowConf = signalTiming == "Confirmed (bar close)" ? latchedPowerLowConf : (powerLowConf or na(smoothedPowerPct))
        
        // Determine display values
        string sideText = displaySide == 1 ? "BUY" : (displaySide == -1 ? "SELL" : "NEUTRAL")
        color sideCol = displaySide == 1 ? bullBorder : (displaySide == -1 ? bearBorder : color.gray)
        
        // Use smoothed value for display, handle low confidence
        float displayPct = displayLowConf ? 0.0 : math.min(displayPctRaw, 100.0)
        color pctCol = displayLowConf ? color.gray : sideCol
        
        // Column 0: "Power" label with mode indicator
        string modeIndicator = powerMode == "Auto" ? "Power" : "Power*"
        table.cell(dashboard, 0, powerDataRow, modeIndicator, text_color=color.white, text_size=dashTextSize, width=0)
        // Column 1: BUY/SELL/NEUTRAL (colored)
        table.cell(dashboard, 1, powerDataRow, sideText, text_color=sideCol, text_size=dashTextSize, width=0)
        // Column 2: Percentage (colored to match side)
        string pctText = displayLowConf ? "â€”" : (str.tostring(round1(displayPct)) + "%")
        table.cell(dashboard, 2, powerDataRow, pctText, text_color=pctCol, text_size=dashTextSize, width=0)
        // Column 3: Intrabar count (confidence indicator)
        string confText = str.tostring(displayIntrabarCount) + " bars"
        color confCol = displayLowConf ? color.orange : color.gray
        table.cell(dashboard, 3, powerDataRow, confText, text_color=confCol, text_size=dashTextSize, width=0)
        // Column 4: Show confirmation status (optional debug info)
        string confirmStatus = flipConfirmCount > 0 ? "(" + str.tostring(flipConfirmCount) + ")" : ""
        table.cell(dashboard, 4, powerDataRow, confirmStatus, text_color=color.gray, text_size=dashTextSize, width=0)
        // Columns 5-6: blank
        table.cell(dashboard, 5, powerDataRow, "", text_size=dashTextSize, width=0)
        table.cell(dashboard, 6, powerDataRow, "", text_size=dashTextSize, width=0)

    // === PREMIUM/DISCOUNT ZONE (Below Power Row) ===
    int zoneRow = 10
    string zoneLabel = inDiscount ? "DISCOUNT" : inPremium ? "PREMIUM" : "EQUILIBRIUM"
    color zoneCol = inDiscount ? bullBorder : inPremium ? bearBorder : color.gray
    string oteLabel = inOteLong ? "OTEâ–²" : inOteShort ? "OTEâ–¼" : ""
    color oteCol = color.new(#ffd700, 0)

    // Zone header row
    table.cell(dashboard, 0, zoneRow, "ZONE", text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 1, zoneRow, zoneLabel, text_color=zoneCol, text_size=dashTextSize, width=0)
    table.cell(dashboard, 2, zoneRow, oteLabel, text_color=oteCol, text_size=dashTextSize, width=0)
    table.cell(dashboard, 3, zoneRow, "", text_size=dashTextSize, width=0)
    table.cell(dashboard, 4, zoneRow, "", text_size=dashTextSize, width=0)
    table.cell(dashboard, 5, zoneRow, "", text_size=dashTextSize, width=0)
    table.cell(dashboard, 6, zoneRow, "", text_size=dashTextSize, width=0)

    // Zone detail row - show distance to equilibrium
    int zoneDetailRow = 11
    float eqDist = zoneRange > 0 ? math.abs(close - zoneEquilibrium) / zoneRange * 100 : 0
    string depthLabel = inDiscount ? "Depth" : inPremium ? "Height" : "At EQ"
    string depthValue = zoneRange > 0 ? str.tostring(math.round(eqDist)) + "%" : "â€”"

    table.cell(dashboard, 0, zoneDetailRow, depthLabel, text_color=color.gray, text_size=dashTextSize, width=0)
    table.cell(dashboard, 1, zoneDetailRow, depthValue, text_color=color.white, text_size=dashTextSize, width=0)
    table.cell(dashboard, 2, zoneDetailRow, "", text_size=dashTextSize, width=0)
    table.cell(dashboard, 3, zoneDetailRow, "", text_size=dashTextSize, width=0)
    table.cell(dashboard, 4, zoneDetailRow, "", text_size=dashTextSize, width=0)
    table.cell(dashboard, 5, zoneDetailRow, "", text_size=dashTextSize, width=0)
    table.cell(dashboard, 6, zoneDetailRow, "", text_size=dashTextSize, width=0)

// === ALERTS ===
// Note: alertcondition must be at global scope
// Gate conditions with granular alert flags
alertcondition(alertNewOB and newBullOB, "New Bullish Order Block", "ğŸŸ¢ New Bull OB detected on {{ticker}} {{interval}}")
alertcondition(alertNewOB and newBearOB, "New Bearish Order Block", "ğŸ”´ New Bear OB detected on {{ticker}} {{interval}}")
// Touch alerts are edge-triggered: fires once per entry, re-arms when price exits all zones of that side
alertcondition(alertTouch and bullTouchTrigger, "Price in Bull Zone", "ğŸ’š Price testing Bull OB on {{ticker}} {{interval}}")
alertcondition(alertTouch and bearTouchTrigger, "Price in Bear Zone", "â¤ï¸ Price testing Bear OB on {{ticker}} {{interval}}")
alertcondition(alertReject and bullReject, "Bull Zone Rejection", "ğŸš€ Rejection from Bull OB on {{ticker}} {{interval}} - Potential LONG")
alertcondition(alertReject and bearReject, "Bear Zone Rejection", "ğŸ’¥ Rejection from Bear OB on {{ticker}} {{interval}} - Potential SHORT")

// Proximity Alerts (New - gives advance warning before price reaches zones)
alertcondition(proximityAlertEnabled and nearBullOB, "Approaching Bull OB", "âš ï¸ Price approaching BULLISH Order Block on {{ticker}} {{interval}} - Prepare LONG setup")
alertcondition(proximityAlertEnabled and nearBearOB, "Approaching Bear OB", "âš ï¸ Price approaching BEARISH Order Block on {{ticker}} {{interval}} - Prepare SHORT setup")

// === LIQUIDITY SWEEP ALERTS ===
// All liquidity alerts gated by enableLiquidity master toggle
// Liquidity Sweep Alerts
alertcondition(enableLiquidity and alertLiquiditySweep and bullSweepDetected, "Bullish Liquidity Sweep", "Bullish sweep on {{ticker}} {{interval}} - SSL taken, potential LONG")
alertcondition(enableLiquidity and alertLiquiditySweep and bearSweepDetected, "Bearish Liquidity Sweep", "Bearish sweep on {{ticker}} {{interval}} - BSL taken, potential SHORT")

// Liquidity Run Alerts (continuation after taking liquidity)
// BSL Run = price took buy-side liquidity (highs) and continued UP
// SSL Run = price took sell-side liquidity (lows) and continued DOWN
alertcondition(enableLiquidity and alertLiquidityRun and bearRunDetected, "BSL Run (Upside Continuation)", "Price took buy-side liquidity (BSL) on {{ticker}} {{interval}} and continued higher")
alertcondition(enableLiquidity and alertLiquidityRun and bullRunDetected, "SSL Run (Downside Continuation)", "Price took sell-side liquidity (SSL) on {{ticker}} {{interval}} and continued lower")

// Liquidity Proximity Alerts (edge-triggered: fires once per approach, re-arms when price exits)
alertcondition(enableLiquidity and alertApproachingLiquidity and triggerNearBSL, "Approaching BSL", "Price approaching buy-side liquidity on {{ticker}} {{interval}}")
alertcondition(enableLiquidity and alertApproachingLiquidity and triggerNearSSL, "Approaching SSL", "Price approaching sell-side liquidity on {{ticker}} {{interval}}")
