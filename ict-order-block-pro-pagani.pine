//@version=6
indicator("ICT Order Block Pro [Pagani] v3.4", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// ============================================================================
// ICT ORDER BLOCK PRO V3.4.0 - INSTITUTIONAL SMART MONEY CONCEPTS
// Professional-grade order block detection with ICT/SMC methodology
//
// V3.4.0 - Production Default UX + Stability Finalization:
// â€¢ Settings Mode: Auto (default) optimizes all settings per timeframe
// â€¢ Signal Timing: Confirmed mode now fully latches Power row (no intrabar flicker)
// â€¢ Liquidity Module: Opt-in by default (enableLiquidity master toggle OFF)
// â€¢ Alerts-only mode: Liquidity alerts work even when all drawings are disabled
// â€¢ Anti-spam edge-triggered alerts for Touch and Liquidity Proximity
// â€¢ Touch alerts respect touchMode setting (wick vs close)
// â€¢ Clearer run alerts: "BSL Run (Upside)" / "SSL Run (Downside)"
// â€¢ Volume Profile Enhancement: ON by default
// â€¢ Dashboard location: Selectable corners with proper table recreation
//
// Features:
// â€¢ Two detection methods: Institutional (stricter) & Scalper (faster)
// â€¢ Multi-TF Power Row with real-time BUY/SELL pressure
// â€¢ ICT Liquidity Sweep Detection: BSL/SSL levels, sweep/run detection
// â€¢ Volume Profile integration for Eliteâ˜… blocks (Premium)
// â€¢ Quality ratings: â˜… Elite, â—† Strong, â—‡ Mid, â—‹ Weak
// â€¢ Proximity & rejection alerts with anti-spam protection
// â€¢ Auto-adapts settings based on timeframe
// ============================================================================

// === TIMEFRAME AUTO-DETECTION ===
tf_in_minutes = timeframe.in_seconds() / 60
is_scalping = tf_in_minutes <= 15  // 1m, 3m, 5m, 10m, 15m
is_swing = tf_in_minutes > 15 and tf_in_minutes <= 240  // 30m, 1H, 2H, 4H
is_position = tf_in_minutes > 240  // Daily, Weekly

// Prefer targeted history buffers over indicator(max_bars_back=...)
max_bars_back(open, 600)
max_bars_back(high, 600)
max_bars_back(low, 600)
max_bars_back(close, 600)
max_bars_back(volume, 600)
max_bars_back(time, 600)

// === HELPER FUNCTIONS ===
formatVolume(float vol) =>
    string s = ""
    if na(vol) or vol == 0
        s := ""
    else
        float k = vol / 1000.0
        float m = vol / 1000000.0
        // Promote to M if K value rounds to 1000 or more
        if m >= 1.0 or k >= 999.5
            s := str.tostring(math.round(m * 100) / 100) + "M"
        else if k >= 1.0
            s := str.tostring(math.round(k * 100) / 100) + "K"
        else
            s := str.tostring(math.round(vol))
    s

// Helper for rounding to 2 decimal places
round2(float x) =>
    math.round(x * 100) / 100

// Helper for rounding to 1 decimal place
round1(float x) =>
    math.round(x * 10) / 10

// Helper to convert strength to numeric score for comparison
strengthScore(string s) =>
    s == "Elite" ? 4 : s == "Strong" ? 3 : s == "Mid" ? 2 : 1

// Direction constants (avoid string comparisons)
int DIR_BULL = 1
int DIR_BEAR = -1

// === INPUTS ===
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// SETTINGS MODE (Top-Level Control)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
settingsMode = input.string("Auto", "Settings Mode", options=["Auto", "Manual"], group="âš™ï¸ Settings Mode",
     tooltip="AUTO: Optimizes all settings based on timeframe for stability and performance.\nMANUAL: Full control over all settings (advanced users).")
signalTiming = input.string("Realtime (intrabar)", "Signal Timing", options=["Realtime (intrabar)", "Confirmed (bar close)"], group="âš™ï¸ Settings Mode",
     tooltip="REALTIME: Updates signals on every tick (faster but may flicker).\nCONFIRMED: Updates signals only on bar close (more stable, no repainting).")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// BASIC SETTINGS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

// Mode Selection (Legacy - ignored when settingsMode="Auto")
autoMode = input.bool(true, "Auto-Adjust for Timeframe", group="âš™ï¸ Mode", tooltip="Automatically optimizes settings based on current timeframe\n\nâš ï¸ When Settings Mode is 'Auto', this is ignored (Auto mode always uses timeframe-based settings).")
manualPreset = input.string("Scalping", "Manual Preset", options=["Scalping", "Swing", "Position"], group="âš™ï¸ Mode")

// Detection Method Selection
detectionMethod = input.string("Scalper", "Detection Method", options=["Institutional", "Scalper"], group="âš™ï¸ Mode", 
     tooltip="[Institutional] Pivot-based with institutional filters (stricter, fewer signals)\n[Scalper] Pattern-based detection optimized for scalping (more signals, faster response)")
scalperLookback = input.int(10, "Scalper Lookback", minval=2, maxval=30, group="âš™ï¸ Mode", 
     tooltip="Lookback period for Scalper detection method")

// Detection Settings
obLookback = input.int(5, "Swing Detection Period", minval=3, maxval=20, group="Detection")
blockSizing = input.string("Smart", "Block Sizing", options=["Smart", "Body Only", "Full Range"], group="Detection", tooltip="Smart: ATR-adjusted for scalping, Body for others")
gridSegments = input.int(10, "Volume Grid Segments", minval=5, maxval=20, group="Detection", 
     tooltip="Number of gradient layers per block. Higher = smoother visuals but more objects.\nWARNING: Each block creates ~12-15 objects (boxes/lines/labels). With maxBlocks=10 and gridSegments=20, you may hit object limits (500 boxes/500 lines max).")

// Validation Filters (Auto-adjust based on TF)
useDisplacement = input.bool(true, "Displacement Filter", group="Filters")
useFVG = input.bool(true, "Fair Value Gap Filter", group="Filters")
useMSB = input.bool(true, "Structure Break Filter", group="Filters")
useVolume = input.bool(true, "Volume Confirmation", group="Filters")

// Mean Reversion Settings
enableRejection = input.bool(true, "Track Rejections", group="Mean Reversion", tooltip="Detects bounces off order blocks")
showRetests = input.bool(true, "Show Retest Count", group="Mean Reversion")

// === LIQUIDITY SWEEP SETTINGS ===
enableLiquidity = input.bool(false, "ğŸ”“ Enable Liquidity Module", group="Liquidity Sweeps",
     tooltip="MASTER TOGGLE: Enable liquidity sweep detection.\nWhen OFF, no liquidity lines/boxes/labels or alerts are created.\nEnable this to use BSL/SSL tracking, sweep detection, and liquidity alerts.")
showLiquidityLevels = input.bool(false, "Show Liquidity Levels", group="Liquidity Sweeps",
     tooltip="Display horizontal lines at swing high/low liquidity levels")
showSweepEvents = input.bool(true, "Mark Sweep Events", group="Liquidity Sweeps",
     tooltip="Mark when price sweeps liquidity and reverses")
showLiquidityRuns = input.bool(false, "Mark Liquidity Runs", group="Liquidity Sweeps",
     tooltip="Also mark when price takes liquidity and CONTINUES (trend continuation)")
markEqualHL = input.bool(true, "Highlight Equal Highs/Lows", group="Liquidity Sweeps",
     tooltip="Mark clustered swing levels where more stops accumulate")
sweepLookback = input.int(20, "Swing Lookback", minval=5, maxval=50, group="Liquidity Sweeps",
     tooltip="Bars to identify swing highs/lows for liquidity pools")
equalHLThreshold = input.float(0.1, "Equal High/Low Threshold %", minval=0.0, maxval=1.0, group="Liquidity Sweeps",
     tooltip="Price range (%) to consider highs/lows as 'equal' (clustered liquidity)")
sweepWickMin = input.float(0.5, "Min Sweep Wick (ATR mult)", minval=0.1, maxval=2.0, group="Liquidity Sweeps",
     tooltip="Minimum wick beyond level to qualify as sweep")
requireVolumeSpike = input.bool(true, "Require Volume Spike", group="Liquidity Sweeps",
     tooltip="Sweep candle must have above-average volume")
maxLiquidityLevelsInput = input.int(6, "Max Levels per Side", minval=2, maxval=12, group="Liquidity Sweeps")

// Liquidity Visual Colors
bslColor = input.color(color.new(#00bfff, 30), "BSL Level Color", group="Liquidity Colors")
sslColor = input.color(color.new(#ff6600, 30), "SSL Level Color", group="Liquidity Colors")
sweepBullColor = input.color(color.new(#00ff88, 20), "Bullish Sweep", group="Liquidity Colors")
sweepBearColor = input.color(color.new(#ff3366, 20), "Bearish Sweep", group="Liquidity Colors")

// Liquidity Alerts (only active when enableLiquidity is true)
alertLiquiditySweep = input.bool(false, "Alert on Sweep", group="Alerts",
     tooltip="Alert when liquidity is swept (requires Enable Liquidity Module)")
alertLiquidityRun = input.bool(false, "Alert on Run (Continuation)", group="Alerts",
     tooltip="Alert when price takes liquidity and CONTINUES in direction (requires Enable Liquidity Module)")
alertApproachingLiquidity = input.bool(false, "Alert Approaching Liquidity", group="Alerts",
     tooltip="Alert when price approaches liquidity levels (requires Enable Liquidity Module)")
liquidityProximityPct = input.float(0.5, "Liquidity Proximity %", minval=0.1, maxval=3.0, group="Alerts")

// Alert Settings
alertNewOB = input.bool(true, "Alert on New OB", group="Alerts", tooltip="Alert when new order blocks are detected")
alertTouch = input.bool(true, "Alert on Touch", group="Alerts", tooltip="Alert when price enters an order block zone")
alertReject = input.bool(true, "Alert on Rejection", group="Alerts", tooltip="Alert when price rejects from an order block")

// Proximity Alert Settings
proximityAlertEnabled = input.bool(true, "ğŸ¯ Enable Proximity Alerts", group="Alerts", tooltip="Alert when price approaches nearest OB zones")
proximityThreshold = input.float(1.0, "Proximity Distance %", minval=0.1, maxval=5.0, step=0.1, group="Alerts", 
     tooltip="Alert when price is within this % of an OB zone\nScalping: 0.5-1% | Swing: 1-2% | Position: 2-3%")
alertOnlyStrongBlocks = input.bool(true, "Proximity: Only Strong/Elite", group="Alerts", tooltip="Only alert for high-quality order blocks")
alertOnlyFreshBlocks = input.bool(false, "Proximity: Only Fresh (Untested)", group="Alerts", tooltip="Only alert for zones with no prior retests")
requireDirectionalApproach = input.bool(true, "Require Directional Approach", group="Alerts", 
     tooltip="Bull OB: alert only when price falling\nBear OB: alert only when price rising\nMakes alerts more actionable")

// Premium Features (Requires TradingView Premium)
useVolumeProfile = input.bool(true, "ğŸ“Š Volume Profile Enhancement", group="ğŸ”¥ Premium Features", 
     tooltip="Requires TradingView Premium\nBoosts order blocks that align with high-volume price zones\nIdentifies institutional accumulation/distribution areas\n\nâœ… AUTO-SCALING (v2.4): When Auto-Adjust is ON, VP lookback automatically scales with timeframe (1mâ†’60, 5mâ†’100, 1hâ†’200) for optimal performance.\n\nâœ… ENABLED BY DEFAULT (v3.4+): VP is now ON by default for enhanced signal quality.")
vpLookback = input.int(100, "VP Analysis Period", minval=20, maxval=500, group="ğŸ”¥ Premium Features",
     tooltip="Maximum bars to analyze for volume distribution\n\nâœ… AUTO-SCALING: With Auto-Adjust ON, this acts as a CAP. Script auto-reduces on lower timeframes:\nâ€¢ 1m chart â†’ 60 bars (or your setting, whichever is lower)\nâ€¢ 5m chart â†’ 100 bars\nâ€¢ 1h chart â†’ 200 bars\nâ€¢ 4h+ chart â†’ 300 bars\n\nManual mode always uses your exact value.")
vpThreshold = input.float(1.5, "VP Strength Multiplier", minval=1.0, maxval=3.0, step=0.1, group="ğŸ”¥ Premium Features",
     tooltip="Volume threshold for confirmation (1.5 = 150% of average volume)")

// Visual Settings
showStrength = input.bool(true, "Show Strength Rating", group="Visuals")
showVolLabel = input.bool(true, "Show Volume Labels", group="Visuals")
showDashboard = input.bool(true, "Show Dashboard", group="Visuals")
dashboardLocation = input.string("Top Right", "Dashboard Location", options=["Top Right", "Top Left", "Bottom Right", "Bottom Left"], group="Visuals",
     tooltip="Position of the dashboard on the chart")
showCornerAccents = input.bool(true, "Corner Accents (Strong Blocks)", group="Visuals", tooltip="Display elegant corner markers on strong order blocks")
fillAlpha = input.int(75, "Fill Transparency", minval=50, maxval=95, group="Visuals")

// Colors - Elegant modern palette
bullHighVol = input.color(color.new(#00ff88, 20), "Bull High Volume", group="Colors", tooltip="Vibrant cyan-green for bullish zones")
bullLowVol = input.color(color.new(#00ff88, 85), "Bull Low Volume", group="Colors")
bearHighVol = input.color(color.new(#ff3366, 20), "Bear High Volume", group="Colors", tooltip="Vibrant pink-red for bearish zones")
bearLowVol = input.color(color.new(#ff3366, 85), "Bear Low Volume", group="Colors")
bullBorder = input.color(color.new(#00ff88, 0), "Bull Border/Accent", group="Colors")
bearBorder = input.color(color.new(#ff3366, 0), "Bear Border/Accent", group="Colors")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ADVANCED SETTINGS (Fine-tune signal quality vs frequency)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

// 1) Displacement / Impulse Tuning
dispAtrBodyMult = input.float(0.8, "Displacement ATR Body Mult", minval=0.5, maxval=2.0, step=0.1, group="âš™ï¸ Advanced: Displacement", 
     tooltip="Body size threshold: body > atr * this multiplier\nLower = more signals, Higher = stricter quality")
dispBodyToRangeMin = input.float(0.6, "Displacement Body/Range Min", minval=0.4, maxval=0.9, step=0.05, group="âš™ï¸ Advanced: Displacement", 
     tooltip="Body dominance: body/range must exceed this\nLower = more signals, Higher = cleaner candles")

// 2) Scalper OB Search Window
obScanWindow = input.int(3, "Scalper OB Scan Window", minval=1, maxval=6, group="âš™ï¸ Advanced: Scalper Method", 
     tooltip="Max bars to scan back from impulse to find opposite candle\nWider = more signals (finds OB further back)")

// 3) MSB Controls
msbLookbackMode = input.string("Auto (preset)", "MSB Lookback Mode", options=["Auto (preset)", "User override"], 
     group="âš™ï¸ Advanced: Structure Break", 
     tooltip="Auto = uses timeframe presets (5/10/15)\nUser override = uses your MSB Lookback value below")
msbLookback = input.int(10, "MSB Structure Lookback", minval=3, maxval=30, group="âš™ï¸ Advanced: Structure Break", 
     tooltip="Bars to scan for structure break confirmation\nHigher = stricter structure requirements\nOnly applies when 'User override' is selected above")
msbUsePivotFallback = input.bool(true, "MSB Use Pivot Fallback", group="âš™ï¸ Advanced: Structure Break", 
     tooltip="Include pivot point as minimum structure level")

// 4) FVG Controls
fvgMode = input.string("Classic 3-candle", "FVG Mode", options=["Classic 3-candle", "Off", "Strict (body gap)", "Loose (wick gap)"], 
     group="âš™ï¸ Advanced: FVG", tooltip="Fair Value Gap detection mode\nClassic = standard 3-candle gap\nStrict = requires body gap\nLoose = allows wick gap")
fvgMinGapAtr = input.float(0.0, "FVG Min Gap (ATR mult)", minval=0.0, maxval=1.0, step=0.05, group="âš™ï¸ Advanced: FVG", 
     tooltip="Minimum gap size: gapSize > atr * this\n0 = no minimum, higher = filters micro-gaps")

// 5) Zone Sizing Controls
smartSizeAtrMult = input.float(1.2, "Smart Size ATR Multiplier", minval=0.5, maxval=3.0, step=0.1, group="âš™ï¸ Advanced: Zone Sizing", 
     tooltip="Zone height for Smart sizing: atr * this multiplier\nHigher = wider zones")
smartSizingAppliesTo = input.string("Scalping only", "Smart Sizing Applies To", options=["Scalping only", "All timeframes"], 
     group="âš™ï¸ Advanced: Zone Sizing", tooltip="When to use Smart sizing vs other methods")
smartAnchor = input.string("Wick", "Smart Anchor Point", options=["Wick", "Body/Open"], 
     group="âš™ï¸ Advanced: Zone Sizing", tooltip="Wick = anchors from candle low (bull) / high (bear)\nBody/Open = anchors from body for refined institutional entries")

// 6) Mitigation Controls
mitigationMode = input.string("Auto", "Mitigation Mode", options=["Auto", "Wick", "Close", "Mean"], 
     group="âš™ï¸ Advanced: Mitigation", tooltip="Auto = adapts to timeframe\nWick = requires wick through zone\nClose = requires close through\nMean = requires close past midpoint")
minPenZonePct = input.float(0.10, "Min Penetration (Zone %)", minval=0.0, maxval=0.5, step=0.05, group="âš™ï¸ Advanced: Mitigation", 
     tooltip="Minimum zone penetration to confirm mitigation\nHigher = prevents premature deletion on noise")
minPenAtrPct = input.float(0.05, "Min Penetration (ATR %)", minval=0.0, maxval=0.3, step=0.01, group="âš™ï¸ Advanced: Mitigation", 
     tooltip="Minimum ATR-based penetration\nHigher = prevents premature deletion")
meanMitigationLevel = input.float(0.5, "Mean Mitigation Level", minval=0.0, maxval=1.0, step=0.1, group="âš™ï¸ Advanced: Mitigation", 
     tooltip="For Mean mode: 0 = top of zone, 1 = bottom, 0.5 = midpoint")

// 7) Retests + Rejections Controls
touchMode = input.string("Wick", "Touch Detection Mode", options=["Wick", "Close inside zone"], 
     group="âš™ï¸ Advanced: Retests", tooltip="What counts as a touch/retest")
retestDebounce = input.string("Require exit before recount", "Retest Counting", 
     options=["Require exit before recount", "Count each bar in zone"], group="âš™ï¸ Advanced: Retests", 
     tooltip="How to count multiple touches")
rejectionCloseLevel = input.string("Mid", "Rejection Close Level", options=["Mid", "Top/Bottom", "Percent into zone"], 
     group="âš™ï¸ Advanced: Retests", tooltip="Where close must be to confirm rejection")
rejectionPercent = input.float(0.5, "Rejection Close Percent", minval=0.0, maxval=1.0, step=0.1, group="âš™ï¸ Advanced: Retests", 
     tooltip="For 'Percent into zone' mode: 0 = zone edge, 1 = opposite edge")

// 8) Strength Scoring Thresholds
volScoreMult = input.float(1.5, "Volume Score Multiplier", minval=1.0, maxval=3.0, step=0.1, group="âš™ï¸ Advanced: Strength", 
     tooltip="Volume threshold for strength point: vol > avgVol * this")
bodyScoreMult = input.float(1.5, "Body Score Multiplier", minval=1.0, maxval=3.0, step=0.1, group="âš™ï¸ Advanced: Strength", 
     tooltip="Body size threshold for strength point: body > avgBody * this")
vpScoreBoost = input.int(1, "VP Score Boost", minval=0, maxval=2, group="âš™ï¸ Advanced: Strength", 
     tooltip="Extra strength points when VP confirms (Premium)")
eliteRequiresVP = input.bool(true, "Elite Requires VP", group="âš™ï¸ Advanced: Strength", 
     tooltip="Require Volume Profile confirmation for Elite rating")

// 9) Performance / Object Limits
maxBlocksUser = input.string("Auto", "Max Blocks", options=["Auto", "3", "5", "6", "8", "10", "12", "15"], 
     group="âš™ï¸ Advanced: Performance", tooltip="Auto = adapts to timeframe\nManual = fixed limit")
renderMode = input.string("Gradient", "Render Mode", options=["Gradient", "Simple fill", "Borders only"], 
     group="âš™ï¸ Advanced: Performance", tooltip="Gradient = full visuals\nSimple = less objects\nBorders = minimal objects\nUse Simple/Borders if hitting 500 box/line limits")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// POWER ROW (Intrabar Volume Dominance)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
showPowerRow = input.bool(true, "Show Power Row", group="ğŸ“Š Power (Intrabar)", 
     tooltip="Display intrabar volume dominance in dashboard\nShows BUY/SELL pressure from lower timeframe data")
powerMode = input.string("Auto", "Power Mode", options=["Auto", "Manual"], group="ğŸ“Š Power (Intrabar)", 
     tooltip="Auto: Optimizes LTF, smoothing, and stability based on chart TF\nManual: Full control over all settings")
powerLtf = input.timeframe("1", "Manual Lower TF", group="ğŸ“Š Power (Intrabar)", 
     tooltip="Only used when Mode is Manual\nRecommended: 1-5 min for most charts")
powerTieBreak = input.string("Carry last direction", "Doji Handling", 
     options=["Carry last direction", "Use prev intrabar close", "Ignore dojis"], group="ğŸ“Š Power (Intrabar)", 
     tooltip="How to classify intrabar candles where close == open\nâ€¢ Carry last: Use previous candle's direction\nâ€¢ Prev close: Compare to prior intrabar's close\nâ€¢ Ignore: Skip doji candles entirely")

// Stability Controls
powerNeutralBandPct = input.float(10.0, "Neutral Band %", minval=0.0, maxval=30.0, step=1.0, group="ğŸ“Š Power (Intrabar)", 
     tooltip="Creates a neutral zone around 50% dominance\nDefault 10% = neutral range [45%..55%]\nHigher = more NEUTRAL readings, less flipping")
powerFlipConfirmBars = input.int(0, "Flip Confirm Bars (0=Auto)", minval=0, maxval=10, group="ğŸ“Š Power (Intrabar)", 
     tooltip="Bars required to confirm side change\n0 = Auto-scale based on timeframe\nHigher = more stable but slower to react")
powerSmoothingLen = input.int(8, "Smoothing Length (Manual)", minval=1, maxval=30, group="ğŸ“Š Power (Intrabar)", 
     tooltip="EMA/SMA smoothing for display stability\nOnly used in Manual mode; Auto mode scales this")
powerSmoothingType = input.string("EMA", "Smoothing Type", options=["EMA", "SMA"], group="ğŸ“Š Power (Intrabar)")
powerMinIntrabars = input.int(4, "Min Intrabars (Confidence)", minval=1, maxval=20, group="ğŸ“Š Power (Intrabar)", 
     tooltip="Minimum intrabar candles required for confident reading\nBelow this, shows as low-confidence (grey)")

// === EFFECTIVE PRESET DETERMINATION ===
// When settingsMode=Auto, derive preset from timeframe (ignore autoMode toggle)
// When settingsMode=Manual, use the legacy autoMode/manualPreset logic
string effectivePreset = "Scalping"
bool effectiveAutoMode = settingsMode == "Auto" ? true : autoMode

if settingsMode == "Auto"
    // Force timeframe-based preset in Auto mode
    effectivePreset := is_scalping ? "Scalping" : is_swing ? "Swing" : "Position"
else
    // Manual mode: respect user's autoMode choice
    if autoMode
        effectivePreset := is_scalping ? "Scalping" : is_swing ? "Swing" : "Position"
    else
        effectivePreset := manualPreset

// === AUTO-CONFIGURATION BASED ON PRESET ===
int actualLookback = obLookback
float dispMagnitude = 1.3
int actualMsbPeriod = msbLookback  // Now uses user input as base
bool actualFVG = useFVG
bool actualMSB = useMSB
int maxBlocks = 10
string mitigationMethod = "Wick"

// Performance guardrails (Auto mode forces safe defaults)
int effectiveGridSegments = gridSegments
string effectiveRenderMode = renderMode

if effectivePreset == "Scalping"
    // Scalping: More signals, faster response
    actualLookback := 3
    dispMagnitude := 1.1
    actualMsbPeriod := 5
    actualFVG := settingsMode == "Auto" ? false : useFVG  // Auto forces off for scalping
    actualMSB := true
    maxBlocks := 8
    mitigationMethod := mitigationMode == "Auto" ? "Wick" : mitigationMode
    // Performance guardrails for scalping (Auto mode)
    if settingsMode == "Auto"
        effectiveGridSegments := math.min(gridSegments, 8)  // Cap at 8 for speed
        effectiveRenderMode := tf_in_minutes <= 3 ? "Simple fill" : renderMode  // Force simple on very low TF
else if effectivePreset == "Swing"
    // Swing: Balanced approach
    actualLookback := 5
    dispMagnitude := 1.3
    actualMsbPeriod := 10
    actualFVG := settingsMode == "Auto" ? true : useFVG
    actualMSB := true
    maxBlocks := 6
    mitigationMethod := mitigationMode == "Auto" ? "Close" : mitigationMode
    if settingsMode == "Auto"
        effectiveGridSegments := math.min(gridSegments, 12)
else
    // Position: Quality focus
    actualLookback := 7
    dispMagnitude := 1.5
    actualMsbPeriod := 15
    actualFVG := settingsMode == "Auto" ? true : useFVG
    actualMSB := true
    maxBlocks := 5
    mitigationMethod := mitigationMode == "Auto" ? "Mean" : mitigationMode
    if settingsMode == "Auto"
        effectiveGridSegments := math.min(gridSegments, 15)

// User override for MSB lookback (only in Manual mode or when explicitly set)
if settingsMode == "Manual" and msbLookbackMode == "User override"
    actualMsbPeriod := msbLookback

// === LIQUIDITY AUTO-SCALING ===
// Cap maxLiquidityLevels in Auto mode for scalping to reduce object load
int maxLiquidityLevels = maxLiquidityLevelsInput
if settingsMode == "Auto" and effectivePreset == "Scalping"
    maxLiquidityLevels := math.min(maxLiquidityLevelsInput, 4)  // Cap at 4 for scalping performance
else if settingsMode == "Auto" and effectivePreset == "Swing"
    maxLiquidityLevels := math.min(maxLiquidityLevelsInput, 5)  // Cap at 5 for swing

// === VOLUME PROFILE AUTO-SCALING ===
// Automatically reduce VP lookback on lower timeframes to improve performance
var int vpLookbackEff = vpLookback

if useVolumeProfile
    if effectiveAutoMode
        // Auto-scale based on timeframe (reduces CPU load on low TF)
        // Mapping: 1mâ†’60, 3mâ†’80, 5mâ†’100, 15mâ†’150, 1hâ†’200, 4h+â†’300
        if tf_in_minutes <= 1
            vpLookbackEff := math.min(60, vpLookback)
        else if tf_in_minutes <= 3
            vpLookbackEff := math.min(80, vpLookback)
        else if tf_in_minutes <= 5
            vpLookbackEff := math.min(100, vpLookback)
        else if tf_in_minutes <= 15
            vpLookbackEff := math.min(150, vpLookback)
        else if tf_in_minutes <= 60
            vpLookbackEff := math.min(200, vpLookback)
        else
            vpLookbackEff := math.min(300, vpLookback)
    else
        // Manual mode: use raw vpLookback input
        vpLookbackEff := vpLookback

// === POWER ROW: INTRABAR VOLUME ANALYSIS ===
// Auto-select lower timeframe based on chart TF with expanded mapping
// Never request a timeframe higher than the chart TF
getPowerLtf() =>
    string ltf = "1"
    int chartSeconds = timeframe.in_seconds()
    
    // Expanded mapping for all timeframes
    if tf_in_minutes <= 5
        ltf := "1"          // Chart â‰¤5m â†’ 1-min intrabars
    else if tf_in_minutes <= 15
        ltf := "1"          // Chart â‰¤15m â†’ 1-min intrabars
    else if tf_in_minutes <= 60
        ltf := "5"          // Chart â‰¤1h â†’ 5-min intrabars
    else if tf_in_minutes <= 240
        ltf := "15"         // Chart â‰¤4h â†’ 15-min intrabars
    else if tf_in_minutes <= 1440
        ltf := "60"         // Chart â‰¤1D â†’ 1h intrabars
    else
        ltf := "240"        // Weekly+ â†’ 4h intrabars
    
    // Safety check: never request higher TF than chart
    // Convert ltf to seconds for comparison
    int ltfSeconds = ltf == "1" ? 60 : ltf == "5" ? 300 : ltf == "15" ? 900 : ltf == "60" ? 3600 : 14400
    if ltfSeconds >= chartSeconds
        // Fallback: use smallest valid LTF (1 min) or chart TF itself
        ltf := chartSeconds <= 60 ? timeframe.period : "1"
    
    ltf

// Auto-scale smoothing length based on chart TF
getAutoSmoothingLen() =>
    int len = 8
    if tf_in_minutes <= 15
        len := 6           // Faster charts: lighter smoothing (5-8)
    else if tf_in_minutes <= 60
        len := 10          // 1h: moderate smoothing (10-14)
    else if tf_in_minutes <= 240
        len := 14          // 4h: heavier smoothing (14-18)
    else
        len := 18          // Daily+: strongest smoothing (14-21)
    len

// Auto-scale flip confirmation bars based on chart TF
getAutoFlipConfirm() =>
    int confirm = 2
    if tf_in_minutes <= 15
        confirm := 2       // Fast charts: 2-3 bars
    else if tf_in_minutes <= 60
        confirm := 3       // 1h: 3-4 bars
    else if tf_in_minutes <= 240
        confirm := 4       // 4h: 4-5 bars
    else
        confirm := 5       // Daily+: 5-8 bars
    confirm

// Determine effective Power settings based on settingsMode
// When settingsMode=Auto: force stability settings regardless of powerMode
// When settingsMode=Manual: respect powerMode (Auto/Manual within Power)
string effectivePowerLtf = na
int effectiveSmoothingLen = 0
int effectiveFlipConfirm = 0
string effectivePowerTieBreak = powerTieBreak
float effectiveNeutralBandPct = powerNeutralBandPct
int effectivePowerMinIntrabars = powerMinIntrabars

if settingsMode == "Auto"
    // Force all Power stability settings based on preset
    effectivePowerLtf := getPowerLtf()
    effectiveSmoothingLen := getAutoSmoothingLen()
    effectiveFlipConfirm := getAutoFlipConfirm()
    effectivePowerTieBreak := "Carry last direction"  // Most stable option
    // Neutral band by preset (higher = more stable)
    effectiveNeutralBandPct := effectivePreset == "Scalping" ? 12.0 : effectivePreset == "Swing" ? 15.0 : 18.0
    // Min intrabars by preset (lower = faster response on faster TF)
    effectivePowerMinIntrabars := effectivePreset == "Scalping" ? 4 : effectivePreset == "Swing" ? 3 : 2
else
    // Manual mode: respect powerMode input
    effectivePowerLtf := powerMode == "Auto" ? getPowerLtf() : powerLtf
    effectiveSmoothingLen := powerMode == "Auto" ? getAutoSmoothingLen() : powerSmoothingLen
    effectiveFlipConfirm := powerFlipConfirmBars == 0 ? getAutoFlipConfirm() : powerFlipConfirmBars
    // Keep user's settings
    effectivePowerTieBreak := powerTieBreak
    effectiveNeutralBandPct := powerNeutralBandPct
    effectivePowerMinIntrabars := powerMinIntrabars

// Request intrabar data (only 3 calls for efficiency)
// These return arrays of values for each intrabar within the current chart bar
int chartTfSec = timeframe.in_seconds()
int powerTfSec = timeframe.in_seconds(effectivePowerLtf)
string powerLtfSafe = powerTfSec <= chartTfSec ? effectivePowerLtf : timeframe.period

arrOpen = request.security_lower_tf(syminfo.tickerid, powerLtfSafe, open, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)
arrClose = request.security_lower_tf(syminfo.tickerid, powerLtfSafe, close, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)
arrVol = request.security_lower_tf(syminfo.tickerid, powerLtfSafe, volume, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)

// Calculate Power metrics from intrabar data
calcPower(string tieBreakRule) =>
    float buyVol = 0.0
    float sellVol = 0.0
    int intrabarCount = array.size(arrVol)
    int lastDir = 0  // 1 = bullish, -1 = bearish, 0 = unknown
    
    if intrabarCount > 0
        float prevClose = na
        for i = 0 to intrabarCount - 1
            float o = array.get(arrOpen, i)
            float c = array.get(arrClose, i)
            float v = array.get(arrVol, i)
            
            int dir = 0
            if c > o
                dir := 1   // Bullish intrabar
            else if c < o
                dir := -1  // Bearish intrabar
            else
                // Doji (close == open) - apply tie-break rule (uses effective setting)
                if tieBreakRule == "Carry last direction"
                    dir := lastDir
                else if tieBreakRule == "Use prev intrabar close"
                    if not na(prevClose)
                        dir := c > prevClose ? 1 : (c < prevClose ? -1 : 0)
                // else "Ignore dojis" - dir stays 0, volume not counted
            
            // Accumulate volume by direction
            if dir == 1
                buyVol += v
            else if dir == -1
                sellVol += v
            
            // Update state for next iteration
            if dir != 0
                lastDir := dir
            prevClose := c
    
    [buyVol, sellVol, intrabarCount]

[rawBuyVol, rawSellVol, intrabarCount] = calcPower(effectivePowerTieBreak)

// Compute delta and percentage
float rawDelta = rawBuyVol - rawSellVol
float rawTotal = rawBuyVol + rawSellVol
float rawPowerPct = rawTotal > 0 ? 100.0 * math.abs(rawDelta) / rawTotal : na

// Apply smoothing for display stability (uses effective length)
float smoothedPowerPct = powerSmoothingType == "EMA" ? 
     ta.ema(rawPowerPct, effectiveSmoothingLen) : 
     ta.sma(rawPowerPct, effectiveSmoothingLen)

// Determine RAW side from delta (before stability filters)
int rawPowerSide = rawDelta > 0 ? 1 : (rawDelta < 0 ? -1 : 0)  // 1=BUY, -1=SELL, 0=NEUTRAL

// === STABILITY FILTERS ===
// 1) Neutral band: if powerPct is in the neutral zone, force NEUTRAL
//    Neutral zone = [50 - band/2, 50 + band/2] mapped to powerPct scale
//    Since powerPct is 0-100 (dominance), neutral band applies when dominance is LOW
float neutralThreshold = effectiveNeutralBandPct  // Uses effective setting (Auto forces per preset)
bool inNeutralZone = na(smoothedPowerPct) or smoothedPowerPct < neutralThreshold

// 2) Flip confirmation: require N consecutive bars supporting new side before switching
var int confirmedPowerSide = 0  // Persisted displayed side
var int flipConfirmCount = 0    // Counter for confirmation

// Get the candidate side (after neutral zone filter)
int candidateSide = inNeutralZone ? 0 : rawPowerSide

// Signal timing: only update stateful counters when appropriate
// Realtime: update every tick | Confirmed: update only on bar close
bool shouldUpdatePowerState = signalTiming == "Realtime (intrabar)" or barstate.isconfirmed

// Apply flip confirmation logic (respects signal timing)
if shouldUpdatePowerState
    if candidateSide == confirmedPowerSide
        // Same side - reset confirmation counter
        flipConfirmCount := 0
    else if candidateSide == 0
        // Moving to NEUTRAL - confirm immediately (no delay for de-escalation)
        confirmedPowerSide := 0
        flipConfirmCount := 0
    else
        // Different non-neutral side - require confirmation
        flipConfirmCount += 1
        if flipConfirmCount >= effectiveFlipConfirm
            confirmedPowerSide := candidateSide
            flipConfirmCount := 0

// Final displayed side (uses confirmed side for stability)
int powerSide = confirmedPowerSide

// Low confidence check (uses effective min intrabars setting)
bool powerLowConf = intrabarCount < effectivePowerMinIntrabars or rawTotal == 0 or na(rawPowerPct)

// === LATCHED POWER VALUES FOR CONFIRMED MODE ===
// When signalTiming="Confirmed (bar close)", dashboard should show stable values
// that only update on bar close (no intrabar flicker)
var float latchedPowerPct = 0.0
var int latchedIntrabarCount = 0
var bool latchedPowerLowConf = true
var int latchedPowerSide = 0

// Determine if we should update latched values
// Realtime mode: always use live values (no latching needed, handled in dashboard)
// Confirmed mode: only update latched values on bar close
// NOTE: latchedPowerLowConf must also consider na(smoothedPowerPct) for proper "â€”" display
if signalTiming == "Confirmed (bar close)"
    if barstate.isconfirmed
        latchedPowerPct := na(smoothedPowerPct) ? 0.0 : smoothedPowerPct
        latchedIntrabarCount := intrabarCount
        latchedPowerLowConf := powerLowConf or na(smoothedPowerPct)  // Include na check for display
        latchedPowerSide := powerSide
else
    // Realtime mode: keep latched values in sync (for consistency)
    latchedPowerPct := na(smoothedPowerPct) ? 0.0 : smoothedPowerPct
    latchedIntrabarCount := intrabarCount
    latchedPowerLowConf := powerLowConf or na(smoothedPowerPct)  // Include na check for display
    latchedPowerSide := powerSide

// === DATA STRUCTURES ===
type OrderBlock
    box[] volumeBoxes
    line topLine
    line botLine
    linefill bgFill
    label volLabel
    box[] cornerBoxes  // Corner accent markers
    float top
    float bot
    int direction
    float totalVolume
    float relativeVol
    string strength
    bool touched
    int retestCount
    bool mitigated
    bool rejected
    // State tracking for conditional updates (performance optimization)
    int lastUpdateBar       // Track last bar_index updated
    int lastRetestCount     // For label rebuild check
    bool lastTouched
    bool lastRejected

type LiquiditySweep
    line levelLine           // Horizontal line at swing high/low
    box sweepBox             // Highlight box for sweep event
    label sweepLabel         // Info label
    float level              // Price level of swing high/low
    int levelBar             // Bar index where level formed
    int direction            // DIR_BULL (1) or DIR_BEAR (-1)
    bool isEqual             // Is this an "equal high/low" (clustered liquidity)
    bool swept               // Has been swept (reversal)
    bool ranThrough          // Has been run through (continuation)
    int sweepBar             // Bar when sweep/run occurred
    float sweepWick          // Wick extent beyond level
    float sweepClose         // Close price of sweep candle
    string quality           // "Strong", "Mid", "Weak" based on factors
    bool confirmed           // Sweep confirmed (reversal started)
    int retestCount          // Times level retested after sweep
    int lastUpdateBar        // State tracking

// Helper to render a dashboard row for an order block
// Returns the next row number (incremented if row was rendered)
renderDashboardRow(table tbl, int row, OrderBlock b, string dirLabel, color dirCol, float dist, string rejectedLabel) =>
    int nextRow = row
    // Render regardless of distance; negative means price is beyond the zone
    if row <= 7  // Leave rows 8-9 for Power
        table.cell(tbl, 0, row, dirLabel, text_color=dirCol, text_size=size.small)
        table.cell(tbl, 1, row, formatVolume(b.totalVolume), text_color=dirCol, text_size=size.small)
        table.cell(tbl, 2, row, str.tostring(round2(dist)) + "%", text_color=color.white, text_size=size.small)

        color strengthCol = b.strength == "Elite" ? color.yellow : b.strength == "Strong" ? dirCol : b.strength == "Mid" ? color.orange : color.gray
        table.cell(tbl, 3, row, b.strength, text_color=strengthCol, text_size=size.small)
        table.cell(tbl, 4, row, str.tostring(b.retestCount), text_color=color.white, text_size=size.small)

        // Check if price is currently in zone
        bool currentlyInZone = low <= b.top and high >= b.bot
        string status = b.rejected ? rejectedLabel : (b.retestCount > 0 ? (currentlyInZone ? "ACTIVE" : "TESTED") : "FRESH")
        color statusCol = b.rejected ? dirCol : (currentlyInZone ? color.yellow : (b.retestCount > 0 ? color.orange : color.white))
        table.cell(tbl, 5, row, status, text_color=statusCol, text_size=size.small)
        table.cell(tbl, 6, row, str.tostring(round1(b.relativeVol)) + "x", text_color=color.white, text_size=size.small)
        nextRow := row + 1
    nextRow

renderDashboardBlocks(table tbl, int row, array<OrderBlock> blocks, bool isBull) =>
    int nextRow = row
    int blockCount = array.size(blocks)
    if blockCount > 0
        string dirLabel = isBull ? "BULL â–²" : "BEAR â–¼"
        color dirCol = isBull ? bullBorder : bearBorder
        string rejectedLabel = isBull ? "BOUNCE" : "REJECT"
        for i = blockCount - 1 to 0
            if nextRow > 7  // Leave rows 8-9 for Power
                break
            OrderBlock b = array.get(blocks, i)
            float dist = isBull ? (close - b.bot) / close * 100 : (b.top - close) / close * 100
            nextRow := renderDashboardRow(tbl, nextRow, b, dirLabel, dirCol, dist, rejectedLabel)
    nextRow

var bullBlocks = array.new<OrderBlock>()
var bearBlocks = array.new<OrderBlock>()
var bslLevels = array.new<LiquiditySweep>()  // Buy-side liquidity (above price)
var sslLevels = array.new<LiquiditySweep>()  // Sell-side liquidity (below price)
var table dashboard = na
var string lastDashboardLocation = na  // Track location for table recreation

// Market context (no var needed - recalculated each bar)
float atr = ta.atr(14)
float avgVol = ta.sma(volume, 20)
float avgBody = ta.sma(math.abs(close - open), 20)
float sma50 = ta.sma(close, 50)

max_bars_back(atr, 600)
max_bars_back(avgBody, 600)

// Displacement checks are inlined in checkScalperCondition to avoid Pine consistency warnings.

// Alert flags
var bool newBullOB = false
var bool newBearOB = false
var bool bullTouch = false
var bool bearTouch = false
var bool bullReject = false
// Anti-spam latch for OB Touch alerts - persist across bars (NOT reset each bar)
var bool wasInBullOB = false
var bool wasInBearOB = false
var bool bearReject = false

// Proximity alert flags
var bool nearBullOB = false
var bool nearBearOB = false
var bool wasNearBullOB = false  // State tracking to prevent spam
var bool wasNearBearOB = false

// Liquidity sweep alert flags
var bool bullSweepDetected = false
var bool bearSweepDetected = false
var bool bullRunDetected = false
var bool bearRunDetected = false
var bool nearBSL = false
var bool nearSSL = false
// Anti-spam latch for proximity alerts - persist across bars (NOT reset each bar)
var bool wasNearBSL = false
var bool wasNearSSL = false
var int lastBearSweepBar = 0
var int lastBullSweepBar = 0

bool showAnyLabel = showVolLabel or showStrength or showRetests

newBullOB := false
newBearOB := false
bullTouch := false
bearTouch := false
bullReject := false
bearReject := false
nearBullOB := false
nearBearOB := false
bullSweepDetected := false
bearSweepDetected := false
bullRunDetected := false
bearRunDetected := false
nearBSL := false
nearSSL := false

// === VALIDATION FUNCTIONS ===
checkDisplacement(int idx, float threshold) =>
    // Used by Institutional method - now respects user's body/range threshold
    if idx < 0 or idx > bar_index
        false
    else
        float body = math.abs(close[idx] - open[idx])
        float candle_range = high[idx] - low[idx]
        bool strongBody = body > avgBody[idx] * threshold
        bool fullBodied = candle_range > 0 ? body / candle_range > dispBodyToRangeMin : false
        strongBody and fullBodied

checkFVG(int idx, string dir) =>
    // FVG (Fair Value Gap) = 3-candle pattern showing strong momentum
    // 
    // CANDLE MAPPING (in Pine offset terms, higher = older):
    //   idx-2 = Most recent (continuation after gap)
    //   idx-1 = Middle (displacement/impulse that created gap)
    //   idx   = Oldest (order block candle before displacement)
    //
    // Bullish FVG: Price gaps UP, leaving unfilled zone
    //   - Check: low[idx-2] > high[idx]
    //   - Meaning: Recent candle's LOW is above old candle's HIGH (gap between them)
    //   - The gap was created by the middle candle (idx-1) jumping up
    //
    // Bearish FVG: Price gaps DOWN, leaving unfilled zone
    //   - Check: high[idx-2] < low[idx]
    //   - Meaning: Recent candle's HIGH is below old candle's LOW (gap between them)
    //   - The gap was created by the middle candle (idx-1) jumping down
    //
    // NOTE: If FVGs appear "off by 2 bars", this mapping may need adjustment
    
    // Check mode
    if fvgMode == "Off"
        true  // Always pass if FVG is off
    else
        // Bounds check: need idx-2 to be valid (closer to current bar)
        if idx < 2 or idx > bar_index
            false
        else
            bool hasGap = false
            float gapSize = 0.0
            
            if dir == "Bull"
                if fvgMode == "Strict (body gap)"
                    // Strict: require body gap (close vs open)
                    float recentLow = math.min(close[idx - 2], open[idx - 2])
                    float oldHigh = math.max(close[idx], open[idx])
                    hasGap := recentLow > oldHigh
                    gapSize := hasGap ? recentLow - oldHigh : 0.0
                else if fvgMode == "Loose (wick gap)"
                    // Loose: allow partial gaps (any separation)
                    hasGap := low[idx - 2] >= high[idx]
                    gapSize := hasGap ? low[idx - 2] - high[idx] : 0.0
                else  // Classic 3-candle
                    // Classic: wick gap (standard)
                    hasGap := low[idx - 2] > high[idx]
                    gapSize := hasGap ? low[idx - 2] - high[idx] : 0.0
            else  // Bear
                if fvgMode == "Strict (body gap)"
                    // Strict: require body gap
                    float recentHigh = math.max(close[idx - 2], open[idx - 2])
                    float oldLow = math.min(close[idx], open[idx])
                    hasGap := recentHigh < oldLow
                    gapSize := hasGap ? oldLow - recentHigh : 0.0
                else if fvgMode == "Loose (wick gap)"
                    // Loose: allow partial gaps
                    hasGap := high[idx - 2] <= low[idx]
                    gapSize := hasGap ? low[idx] - high[idx - 2] : 0.0
                else  // Classic 3-candle
                    // Classic: wick gap
                    hasGap := high[idx - 2] < low[idx]
                    gapSize := hasGap ? low[idx] - high[idx - 2] : 0.0
            
            // Apply minimum gap filter
            bool meetsMinGap = true
            if fvgMinGapAtr > 0.0 and hasGap
                meetsMinGap := gapSize > atr[idx] * fvgMinGapAtr
            
            hasGap and meetsMinGap

checkMSB(int pivotIdx, int dispIdx, int lookback, string dir) =>
    // Market Structure Break: Check if displacement candle broke recent swing structure
    // Scan backwards FROM displacement (excluding dispIdx itself) to find recent structure
    bool confirmed = false
    int scanStart = dispIdx + 1
    int scanEnd = math.min(dispIdx + lookback, bar_index)
    
    // Need at least one bar to check structure
    if pivotIdx < 0 or dispIdx < 0 or dispIdx > bar_index or scanStart > bar_index
        confirmed := false
    else
        if dir == "Bull"
            // Find highest high in lookback period BEFORE displacement (excluding dispIdx)
            // Initialize from first bar in scan range (NOT from dispIdx)
            float recentHigh = high[scanStart]
            
            // Scan remaining bars in lookback period (if any)
            if scanStart < scanEnd
                for i = scanStart + 1 to scanEnd
                    if high[i] > recentHigh
                        recentHigh := high[i]
            
            // Also consider pivot as minimum structure level (fallback) - user configurable
            if msbUsePivotFallback and high[pivotIdx] > recentHigh
                recentHigh := high[pivotIdx]
            
            // MSB confirmed if displacement broke above the recent structure
            if high[dispIdx] > recentHigh
                confirmed := true
        else
            // Find lowest low in lookback period BEFORE displacement (excluding dispIdx)
            // Initialize from first bar in scan range (NOT from dispIdx)
            float recentLow = low[scanStart]
            
            // Scan remaining bars in lookback period (if any)
            if scanStart < scanEnd
                for i = scanStart + 1 to scanEnd
                    if low[i] < recentLow
                        recentLow := low[i]
            
            // Also consider pivot as minimum structure level (fallback) - user configurable
            if msbUsePivotFallback and low[pivotIdx] < recentLow
                recentLow := low[pivotIdx]
            
            // MSB confirmed if displacement broke below the recent structure
            if low[dispIdx] < recentLow
                confirmed := true
    confirmed

// === LIQUIDITY SWEEP DETECTION FUNCTIONS ===
// Detect swing highs (potential BSL)
findSwingHigh(int leftBars, int rightBars) =>
    bool isSwing = false
    float level = na

    // Need enough history to validate both sides.
    if bar_index >= leftBars + rightBars
        isSwing := true
        level := high[rightBars]
        // Left side (older bars)
        for i = 1 to leftBars
            if high[rightBars + i] >= level
                isSwing := false
                break
        // Right side (newer bars) - must include current bar at index 0
        for i = 0 to rightBars - 1
            if high[i] >= level
                isSwing := false
                break

    [isSwing, level]

// Detect swing lows (potential SSL)
findSwingLow(int leftBars, int rightBars) =>
    bool isSwing = false
    float level = na

    // Need enough history to validate both sides.
    if bar_index >= leftBars + rightBars
        isSwing := true
        level := low[rightBars]
        // Left side (older bars)
        for i = 1 to leftBars
            if low[rightBars + i] <= level
                isSwing := false
                break
        // Right side (newer bars) - must include current bar at index 0
        for i = 0 to rightBars - 1
            if low[i] <= level
                isSwing := false
                break

    [isSwing, level]

// Check if new swing is "equal" to existing level (clustered liquidity = stronger)
isEqualLevel(float newLevel, float existingLevel, float thresholdPct) =>
    float diff = math.abs(newLevel - existingLevel) / existingLevel * 100
    diff <= thresholdPct

// Check for bullish sweep (price sweeps SSL then reverses up)
checkBullishSweep(float sslLevel, float minWickAtr) =>
    bool swept = false
    float wickExtent = 0.0
    // Wick went below level but close stayed above
    if low < sslLevel and close > sslLevel
        wickExtent := sslLevel - low
        bool wickOk = wickExtent >= atr * minWickAtr
        bool volumeOk = not requireVolumeSpike or volume > avgVol
        swept := wickOk and volumeOk
    [swept, wickExtent]

// Check for bearish sweep (price sweeps BSL then reverses down)
checkBearishSweep(float bslLevel, float minWickAtr) =>
    bool swept = false
    float wickExtent = 0.0
    // Wick went above level but close stayed below
    if high > bslLevel and close < bslLevel
        wickExtent := high - bslLevel
        bool wickOk = wickExtent >= atr * minWickAtr
        bool volumeOk = not requireVolumeSpike or volume > avgVol
        swept := wickOk and volumeOk
    [swept, wickExtent]

// Check for bullish run (price takes SSL and CONTINUES down)
checkBullishRun(float sslLevel) =>
    bool isRun = false
    // Price broke below level AND closed below (continuation, not reversal)
    if low < sslLevel and close < sslLevel
        isRun := true
    isRun

// Check for bearish run (price takes BSL and CONTINUES up)
checkBearishRun(float bslLevel) =>
    bool isRun = false
    // Price broke above level AND closed above (continuation, not reversal)
    if high > bslLevel and close > bslLevel
        isRun := true
    isRun

// Sweep quality scoring
getSweepQuality(float wickExtent, bool volumeSpike, bool atOrderBlock, bool equalLevel) =>
    int score = 0
    if wickExtent > atr * 1.0
        score += 1  // Strong wick
    if volumeSpike
        score += 1  // Volume confirmation
    if atOrderBlock
        score += 1  // Near order block (confluence)
    if equalLevel
        score += 1  // Equal highs/lows (stronger liquidity)
    score >= 3 ? "Strong" : score >= 2 ? "Mid" : "Weak"

// === VOLUME PROFILE ANALYSIS (Premium Feature) ===
analyzeVolumeProfile(float obTop, float obBot, int lookback) =>
    // Calculate volume distribution in the order block zone
    // Optimized with early exit when sufficient samples collected
    float totalVol = 0.0
    float zoneVol = 0.0
    int barsInZone = 0
    int barsProcessed = 0

    // Confidence thresholds for early exit
    int minBarsForConfidence = 5
    int minBarsToProcess = 20

    int maxBars = math.min(lookback - 1, bar_index)

    // Analyze volume over lookback period with early exit
    for i = 0 to maxBars
        float barHigh = high[i]
        float barLow = low[i]
        float barVol = volume[i]

        totalVol += barVol
        barsProcessed += 1

        // Check if this bar's price range overlaps with order block zone
        bool overlaps = barLow <= obTop and barHigh >= obBot
        if overlaps
            // Calculate overlap percentage
            float overlapHigh = math.min(barHigh, obTop)
            float overlapLow = math.max(barLow, obBot)
            float barRange = barHigh - barLow

            if barRange > 0
                float overlapRatio = (overlapHigh - overlapLow) / barRange
                zoneVol += barVol * overlapRatio
                barsInZone += 1

        // Early exit: enough samples collected for confident estimate
        if barsInZone >= minBarsForConfidence and barsProcessed >= minBarsToProcess
            break

    // Calculate volume metrics using actual bars processed
    float avgVolPerBar = barsProcessed > 0 ? totalVol / barsProcessed : 0.0
    float zoneVolPerBar = barsInZone > 0 ? zoneVol / barsInZone : 0.0
    float volumeConcentration = avgVolPerBar > 0 ? zoneVolPerBar / avgVolPerBar : 0.0

    volumeConcentration

getStrength(float vol, float body, bool trendAlign) =>
    int score = 0
    if useVolume and vol > avgVol * volScoreMult
        score += 1
    if body > avgBody * bodyScoreMult
        score += 1
    if trendAlign
        score += 1
    score >= 2 ? "Strong" : score == 1 ? "Mid" : "Weak"

getEnhancedStrength(float vol, float body, bool trendAlign, float vpConcentration) =>
    int score = 0
    
    // Base scoring (user-configurable)
    if useVolume and vol > avgVol * volScoreMult
        score += 1
    if body > avgBody * bodyScoreMult
        score += 1
    if trendAlign
        score += 1
    
    // Volume Profile boost (Premium feature - user-configurable)
    bool hasVPConfirmation = useVolumeProfile and vpConcentration >= vpThreshold
    if hasVPConfirmation
        score += vpScoreBoost
    
    // Enhanced rating with VP (user can configure if Elite requires VP)
    if useVolumeProfile
        if eliteRequiresVP
            // Elite requires VP confirmation
            if hasVPConfirmation and score >= 3
                "Elite"
            else
                score >= 2 ? "Strong" : score == 1 ? "Mid" : "Weak"
        else
            // Elite available without VP if base score is high enough (3 or 4+)
            score >= 3 ? "Elite" : score >= 2 ? "Strong" : score == 1 ? "Mid" : "Weak"
    else
        score >= 2 ? "Strong" : score == 1 ? "Mid" : "Weak"

// === PROXIMITY ALERT HELPER ===
findNearestOB(array<OrderBlock> blocks, bool isBull) =>
    // Find nearest qualifying order block within proximity threshold
    float nearestDist = 999999.0
    bool isNear = false
    bool qualifiesForAlert = false
    
    int blockCount = array.size(blocks)
    if blockCount > 0
        for i = 0 to blockCount - 1
            OrderBlock b = array.get(blocks, i)
            
            // Skip mitigated blocks
            if b.mitigated
                continue
            
            // Apply quality filters (user-configurable)
            if alertOnlyStrongBlocks and (b.strength != "Strong" and b.strength != "Elite")
                continue
            if alertOnlyFreshBlocks and b.retestCount > 0
                continue
            
            // Calculate distance from current price to zone
            float dist = 0.0
            if isBull
                // Bull OB: distance from current close to zone bottom (approaching from above)
                dist := close > b.bot ? (close - b.bot) / close * 100 : -1.0
            else
                // Bear OB: distance from zone top to current close (approaching from below)
                dist := close < b.top ? (b.top - close) / close * 100 : -1.0
            
            // Check if within threshold and not yet inside zone
            if dist > 0 and dist <= proximityThreshold
                // Optional: Check directional approach for more actionable signals
                bool correctDirection = true
                if requireDirectionalApproach
                    // Bull OB: price should be falling (bearish pressure = potential bounce setup)
                    // Bear OB: price should be rising (bullish pressure = potential rejection setup)
                    correctDirection := isBull ? (close < open) : (close > open)
                
                if correctDirection and dist < nearestDist
                    nearestDist := dist
                    isNear := true
                    qualifiesForAlert := true
    
    [isNear, nearestDist]

// === SCALPER DETECTION METHOD (ICT/SMC - Correct Formula) ===
// Based on Inner Circle Trader methodology
// Order Block = Nearest opposite candle within 1-3 bars before the impulse candle
// Prioritizes recency: takes the most recent qualifying impulse, not just strongest
checkScalperCondition(int tuning) =>
    
    // Max candles to scan back from impulse to find opposite candle (user-adjustable)
    
    // BULL ORDER BLOCK: BEARISH candle before UPWARD impulse
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    bool bullOB = false
    int bullOBIdx = 0
    float bullImpulseStrength = 0.0  // Normalized: body/atr
    
    // BEAR ORDER BLOCK: BULLISH candle before DOWNWARD impulse
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    bool bearOB = false
    int bearOBIdx = 0
    float bearImpulseStrength = 0.0  // Normalized: body/atr
    
    // 1. Find the most recent qualifying impulse candles (single pass)
    int bullImpulseIdx = -1
    int bearImpulseIdx = -1
    int maxIdx = math.min(tuning - 1, bar_index)
    
    for i = 0 to maxIdx
        float body = math.abs(close[i] - open[i])
        float range_c = high[i] - low[i]
        float atrAtIdx = atr[i]  // Use ATR at the historical candle (atr series already calculated)
        bool sizeOk = body > atrAtIdx * dispAtrBodyMult
        bool dominanceOk = range_c > 0 ? body / range_c > dispBodyToRangeMin : false
        if sizeOk and dominanceOk
            if bullImpulseIdx == -1 and close[i] > open[i]
                bullImpulseIdx := i
            if bearImpulseIdx == -1 and close[i] < open[i]
                bearImpulseIdx := i
            if bullImpulseIdx != -1 and bearImpulseIdx != -1
                break
    
    // 2. Scan 1-3 candles back from impulse to find nearest opposite (bearish) candle
    if bullImpulseIdx >= 0
        float impulseBody = close[bullImpulseIdx] - open[bullImpulseIdx]
        float atrAtImpulse = atr[bullImpulseIdx]  // Use ATR at impulse candle (from global atr series)
        bullImpulseStrength := atrAtImpulse > 0 ? impulseBody / atrAtImpulse : 0.0  // Normalized strength
        
        for j = 1 to obScanWindow
            int candidateIdx = bullImpulseIdx + j
            if candidateIdx > bar_index
                break
            // Stop if we hit another qualifying displacement candle (same full predicate)
            float body = math.abs(close[candidateIdx] - open[candidateIdx])
            float range_c = high[candidateIdx] - low[candidateIdx]
            float atrAtIdx = atr[candidateIdx]  // Use ATR at the historical candle (atr series already calculated)
            bool sizeOk = body > atrAtIdx * dispAtrBodyMult
            bool dominanceOk = range_c > 0 ? body / range_c > dispBodyToRangeMin : false
            bool dispBull = sizeOk and dominanceOk and close[candidateIdx] > open[candidateIdx]
            bool dispBear = sizeOk and dominanceOk and close[candidateIdx] < open[candidateIdx]
            if dispBull or dispBear
                break
            // Check if this candle is bearish (opposite to bullish impulse)
            if close[candidateIdx] < open[candidateIdx]
                bullOBIdx := candidateIdx
                bullOB := true
                break
    
    // 2. Scan 1-3 candles back from impulse to find nearest opposite (bullish) candle
    if bearImpulseIdx >= 0
        float bearImpBody = open[bearImpulseIdx] - close[bearImpulseIdx]
        float atrAtBearImpulse = atr[bearImpulseIdx]  // Use ATR at impulse candle (from global atr series)
        bearImpulseStrength := atrAtBearImpulse > 0 ? bearImpBody / atrAtBearImpulse : 0.0  // Normalized strength
        
        for j = 1 to obScanWindow
            int candidateIdx = bearImpulseIdx + j
            if candidateIdx > bar_index
                break
            // Stop if we hit another qualifying displacement candle
            float body = math.abs(close[candidateIdx] - open[candidateIdx])
            float range_c = high[candidateIdx] - low[candidateIdx]
            float atrAtIdx = atr[candidateIdx]  // Use ATR at the historical candle (atr series already calculated)
            bool sizeOk = body > atrAtIdx * dispAtrBodyMult
            bool dominanceOk = range_c > 0 ? body / range_c > dispBodyToRangeMin : false
            bool dispBull = sizeOk and dominanceOk and close[candidateIdx] > open[candidateIdx]
            bool dispBear = sizeOk and dominanceOk and close[candidateIdx] < open[candidateIdx]
            if dispBull or dispBear
                break
            // Check if this candle is bullish (opposite to bearish impulse)
            if close[candidateIdx] > open[candidateIdx]
                bearOBIdx := candidateIdx
                bearOB := true
                break
    
    [bearOB, bullOB, bearOBIdx, bullOBIdx, bearImpulseStrength, bullImpulseStrength]

// === VISUAL GENERATION ===
createVolumeGradient(OrderBlock block, int leftBar, int segments, string rMode) =>
    boxArray = array.new<box>()
    
    // Check render mode (uses effective settings)
    if rMode == "Gradient"
        // Create elegant gradient layers with edge-to-center fading
        float blockHeight = block.top - block.bot
        float segmentHeight = blockHeight / segments  // Pre-compute loop invariant
        int lastSegment = segments - 1                // Pre-compute loop invariant
        float invLastSegment = 1.0 / lastSegment          // Pre-compute for progress calculation
        bool isStrong = block.strength == "Strong" or block.strength == "Elite"

        // Base colors
        color baseCol = block.direction == DIR_BULL ? bullBorder : bearBorder

        // Use bar_index instead of time for boxes to avoid xloc issues
        int leftBarIdx = leftBar
        int rightBarIdx = bar_index

        // Create multiple gradient layers for smooth visual
        for i = 0 to lastSegment
            float topGrid = block.top - segmentHeight * i
            float botGrid = block.top - segmentHeight * (i + 1)

            // Edge-to-center gradient (strongest in middle)
            float progress = i * invLastSegment
            float centerWeight = 1.0 - math.abs(progress - 0.5) * 2.0  // Peak at center

            // Elegant transparency gradient
            int alpha = isStrong ?
                 int(70 + centerWeight * 25) :  // More visible for strong
                 int(80 + centerWeight * 15)     // More subtle for weak

            color layerCol = color.new(baseCol, alpha)

            // Full-width boxes using bar_index (default xloc)
            box newBox = box.new(leftBarIdx, topGrid, rightBarIdx, botGrid,
                 border_width=0, bgcolor=layerCol)
            array.push(boxArray, newBox)
    else if rMode == "Simple fill"
        // Simple mode: single fill box (much fewer objects)
        color baseCol = block.direction == DIR_BULL ? bullBorder : bearBorder
        color fillCol = color.new(baseCol, fillAlpha)
        int leftBarIdx = leftBar
        int rightBarIdx = bar_index
        
        box fillBox = box.new(leftBarIdx, block.top, rightBarIdx, block.bot, 
             border_width=0, bgcolor=fillCol)
        array.push(boxArray, fillBox)
    // else "Borders only" - no fill boxes created
    
    boxArray

createBorder(OrderBlock block, int leftTime, string rMode) =>
    color baseCol = block.direction == DIR_BULL ? bullBorder : bearBorder
    
    // Top line (full length, subtle)
    color mainLineCol = color.new(baseCol, 30)
    line topLine = line.new(x1=leftTime, y1=block.top, x2=time, y2=block.top, 
         xloc=xloc.bar_time, color=mainLineCol, width=1, style=line.style_dotted)
    
    // Bottom line (full length, subtle)
    line botLine = line.new(x1=leftTime, y1=block.bot, x2=time, y2=block.bot, 
         xloc=xloc.bar_time, color=mainLineCol, width=1, style=line.style_dotted)
    
    // Glow effect for strong blocks (multiple transparent fills) - only if not "Borders only"
    linefill fill = na
    
    if rMode != "Borders only"
        if block.strength == "Strong" or block.strength == "Elite"
            // Add glow with gradient fill
            color glowCol = color.new(baseCol, 85)
            fill := linefill.new(topLine, botLine, glowCol)
        else
            // Subtle fill for non-strong blocks
            color fillCol = color.new(baseCol, fillAlpha)
            fill := linefill.new(topLine, botLine, fillCol)
    
    [topLine, botLine, fill]

createCornerAccents(OrderBlock block, int leftBar, string rMode) =>
    // Create elegant corner markers
    corners = array.new<box>()
    
    // Only create corners if enabled, for Strong/Elite blocks, and not in Borders only mode
    if showCornerAccents and (block.strength == "Strong" or block.strength == "Elite") and rMode != "Borders only"
        color accentCol = block.direction == DIR_BULL ? bullBorder : bearBorder
        float blockHeight = block.top - block.bot
        float cornerHeight = blockHeight * 0.15  // 15% of block height
        int cornerWidth = 6  // 6 bars width
        
        // Use bar_index for corners
        int leftBarIdx = leftBar
        int rightBarIdx = leftBarIdx + cornerWidth
        
        // Top-left corner
        box tlCorner = box.new(leftBarIdx, block.top, 
             rightBarIdx, block.top - cornerHeight, 
             border_color=accentCol, border_width=2, bgcolor=color.new(accentCol, 70))
        array.push(corners, tlCorner)
        
        // Bottom-left corner
        box blCorner = box.new(leftBarIdx, block.bot + cornerHeight,
             rightBarIdx, block.bot,
             border_color=accentCol, border_width=2, bgcolor=color.new(accentCol, 70))
        array.push(corners, blCorner)
    
    corners

buildLabelText(OrderBlock block) =>
    string labelText = ""
    
    // Strength indicator (using elegant symbols)
    if showStrength
        if block.strength == "Elite"
            labelText += "â˜… "
        else if block.strength == "Strong"
            labelText += "â—† "
        else if block.strength == "Mid"
            labelText += "â—‡ "
        else
            labelText += "â—‹ "
    
    // Volume
    if showVolLabel
        labelText += formatVolume(block.totalVolume)
    
    // Retest count with elegant format
    if showRetests and block.retestCount > 0
        labelText += "\n" + str.tostring(block.retestCount) + "Ã— TEST"
    
    // Status indicator
    if block.rejected
        labelText += block.direction == DIR_BULL ? "\nâ†— BOUNCE" : "\nâ†˜ REJECT"
    else if block.touched
        labelText += "\nâ— ACTIVE"
    
    labelText

// === LIQUIDITY SWEEP VISUAL FUNCTIONS ===
// Create horizontal level line for liquidity pool
createLiquidityLevel(float level, int startBar, bool isBSL) =>
    color levelCol = isBSL ? bslColor : sslColor
    line levelLine = line.new(startBar, level, bar_index, level,
         xloc=xloc.bar_index, color=levelCol, width=1, style=line.style_dashed)
    levelLine

// Create sweep event highlight box
createSweepBox(float level, float wickExtent, int sweepBar, bool isBullish) =>
    color boxCol = isBullish ? sweepBullColor : sweepBearColor
    float top = isBullish ? level : level + wickExtent
    float bot = isBullish ? level - wickExtent : level
    box sweepBox = box.new(sweepBar - 1, top, sweepBar + 2, bot,
         border_color=boxCol, border_width=2, bgcolor=color.new(boxCol, 80))
    sweepBox

// Create sweep label
createSweepLabel(float level, float wickExtent, int sweepBar, bool isBullish, string quality) =>
    string txt = (isBullish ? "SWEEP â†—" : "SWEEP â†˜") + "\n" + quality
    color txtCol = isBullish ? sweepBullColor : sweepBearColor
    // Position label above (bearish) or below (bullish) the wick
    float labelPrice = isBullish ? level - wickExtent : level + wickExtent
    string labelStyle = isBullish ? label.style_label_up : label.style_label_down
    label lbl = label.new(sweepBar, labelPrice, txt, xloc=xloc.bar_index, yloc=yloc.price,
         color=color.new(#1a1a1a, 15), style=labelStyle, textcolor=txtCol, size=size.small)
    lbl

createVolumeLabel(OrderBlock block) =>
    // Create elegant side panel label
    float labelY = block.top - (block.top - block.bot) * 0.25  // Upper quarter position
    
    // Elegant label styling with dark background and colored accent
    color bgCol = color.new(#1a1a1a, 15)  // Dark semi-transparent background
    color textCol = block.direction == DIR_BULL ? bullBorder : bearBorder
    
    // Create elegant label with dark bg and vibrant text
    label lbl = label.new(time, labelY, buildLabelText(block), xloc.bar_time, yloc.price, bgCol, label.style_label_left, textCol, size.small)
    
    lbl

deleteBlock(OrderBlock block) =>
    if not na(block.topLine)
        line.delete(block.topLine)
    if not na(block.botLine)
        line.delete(block.botLine)
    if not na(block.bgFill)
        linefill.delete(block.bgFill)
    if not na(block.volLabel)
        label.delete(block.volLabel)
    
    int volBoxCount = array.size(block.volumeBoxes)
    if volBoxCount > 0
        for i = 0 to volBoxCount - 1
            box.delete(array.get(block.volumeBoxes, i))
    
    int cornerCount = array.size(block.cornerBoxes)
    if cornerCount > 0
        for i = 0 to cornerCount - 1
            box.delete(array.get(block.cornerBoxes, i))

processBlocks(array<OrderBlock> blocks, bool isBull) =>
    bool touched = false
    bool rejected = false
    
    int blockCount = array.size(blocks)
    if blockCount > 0
        for i = blockCount - 1 to 0
            OrderBlock block = array.get(blocks, i)
            
            if not block.mitigated
                // Check mitigation (user-configurable)
                bool mitigated = false
                float zoneHeight = block.top - block.bot
                float minPenetration = math.max(zoneHeight * minPenZonePct, atr * minPenAtrPct)
                
                if mitigationMethod == "Wick"
                    mitigated := isBull ? low < block.bot - minPenetration : high > block.top + minPenetration
                else if mitigationMethod == "Close"
                    mitigated := isBull ? close < block.bot : close > block.top
                else  // Mean
                    float mean = block.bot + (zoneHeight * meanMitigationLevel)
                    mitigated := isBull ? close < mean : close > mean
                
                if mitigated
                    block.mitigated := true
                    deleteBlock(block)
                    array.remove(blocks, i)
                    continue
                
                // Track touches (user-configurable)
                bool inZone = false
                if touchMode == "Wick"
                    inZone := low <= block.top and high >= block.bot
                else  // "Close inside zone"
                    inZone := close >= block.bot and close <= block.top
                
                if inZone
                    if retestDebounce == "Require exit before recount"
                        if not block.touched
                            block.touched := true
                            block.retestCount += 1
                            touched := true
                    else  // "Count each bar in zone"
                        block.retestCount += 1
                        touched := true
                        block.touched := true
                else
                    // Reset touched flag when price exits the zone
                    if block.touched
                        block.touched := false
                
                // Track rejections (user-configurable)
                if enableRejection
                    float rejectionLevel = 0.0
                    
                    if rejectionCloseLevel == "Mid"
                        rejectionLevel := (block.top + block.bot) / 2
                    else if rejectionCloseLevel == "Top/Bottom"
                        rejectionLevel := isBull ? block.top : block.bot
                    else  // "Percent into zone"
                        rejectionLevel := isBull ? (block.bot + (zoneHeight * rejectionPercent)) : (block.top - (zoneHeight * rejectionPercent))
                    
                    if isBull
                        if low <= block.bot and close >= rejectionLevel
                            if not block.rejected  // Only trigger once
                                block.rejected := true
                                rejected := true
                    else
                        if high >= block.top and close <= rejectionLevel
                            if not block.rejected  // Only trigger once
                                block.rejected := true
                                rejected := true
    
    [touched, rejected]

updateBlock(OrderBlock block, int currentTime, int segments) =>
    // Only extend visuals on new bars (not every tick)
    bool isNewBar = na(block.lastUpdateBar) or bar_index > block.lastUpdateBar

    if isNewBar
        // Update gradient boxes - extend to current bar (boxes use bar_index)
        int volBoxCount = array.size(block.volumeBoxes)
        if volBoxCount > 0
            int maxIdx = math.min(segments - 1, volBoxCount - 1)
            for i = 0 to maxIdx
                box.set_right(array.get(block.volumeBoxes, i), bar_index)

        // Update border lines (lines use time)
        if not na(block.topLine)
            line.set_x2(block.topLine, currentTime)
        if not na(block.botLine)
            line.set_x2(block.botLine, currentTime)

        // Update label position (labels use time)
        if not na(block.volLabel)
            label.set_x(block.volLabel, currentTime)

        block.lastUpdateBar := bar_index

    // Only rebuild label text on state change (not every bar)
    if showAnyLabel and not na(block.volLabel)
        bool stateChanged = block.retestCount != block.lastRetestCount or
                           block.touched != block.lastTouched or
                           block.rejected != block.lastRejected
        if stateChanged
            float labelY = block.top - (block.top - block.bot) * 0.25
            label.set_y(block.volLabel, labelY)
            label.set_text(block.volLabel, buildLabelText(block))
            block.lastRetestCount := block.retestCount
            block.lastTouched := block.touched
            block.lastRejected := block.rejected

updateBlocks(array<OrderBlock> blocks, int segments) =>
    int blockCount = array.size(blocks)
    if blockCount > 0
        for i = 0 to blockCount - 1
            updateBlock(array.get(blocks, i), time, segments)

trimBlocks(array<OrderBlock> blocks, int maxCount) =>
    if array.size(blocks) > maxCount
        deleteBlock(array.shift(blocks))

createOrderBlock(int idx, bool isBull, array<OrderBlock> blocks, bool shouldCreate) =>
    bool created = false
    if shouldCreate and idx > 0 and idx <= bar_index
        float top = high[idx]
        float bot = low[idx]
        
        // Smart sizing - now configurable with ICT-aligned anchoring
        bool applySmartSizing = blockSizing == "Smart" and (smartSizingAppliesTo == "All timeframes" or is_scalping)
        if applySmartSizing
            float minZoneHeight = syminfo.mintick
            float safeAtr = na(atr) ? math.max(high[idx] - low[idx], minZoneHeight) : atr
            if isBull
                // BULLISH OB: Anchor from BOTTOM (demand zone)
                // Zone sits near low/open where institutions accumulated
                float anchorBot = smartAnchor == "Wick" ? low[idx] : math.min(open[idx], close[idx])
                bot := anchorBot
                float maxTop = math.min(high[idx], anchorBot + safeAtr * smartSizeAtrMult)
                top := math.max(maxTop, bot + minZoneHeight)
            else
                // BEARISH OB: Anchor from TOP (supply zone)
                // Zone sits near high/open where institutions distributed
                float anchorTop = smartAnchor == "Wick" ? high[idx] : math.max(open[idx], close[idx])
                top := anchorTop
                float minBot = math.max(low[idx], anchorTop - safeAtr * smartSizeAtrMult)
                bot := math.min(minBot, top - minZoneHeight)
        else if blockSizing == "Body Only"
            top := math.max(open[idx], close[idx])
            bot := math.min(open[idx], close[idx])
        
        int leftTime = time[idx]
        float vol = volume[idx]
        bool aligned = isBull ? close[idx] > sma50[idx] : close[idx] < sma50[idx]
        float body = math.abs(close[idx] - open[idx])
        
        // Volume Profile analysis (Premium feature)
        float vpConcentration = useVolumeProfile ? analyzeVolumeProfile(top, bot, vpLookbackEff) : 0.0
        
        // Enhanced strength with VP
        string strength = useVolumeProfile ? 
             getEnhancedStrength(vol, body, aligned, vpConcentration) : 
             getStrength(vol, body, aligned)
        
        // Handle overlapping blocks - keep higher quality
        // Single-pass with deferred batch deletion (O(N) instead of O(NÂ²))
        bool skipNewBlock = false
        int newScore = strengthScore(strength)
        int[] indicesToRemove = array.new<int>()

        int blockCount = array.size(blocks)
        if blockCount > 0
            for i = 0 to blockCount - 1
                OrderBlock b = array.get(blocks, i)
                bool overlaps = math.max(b.bot, bot) <= math.min(b.top, top)
                if overlaps
                    if strengthScore(b.strength) >= newScore
                        skipNewBlock := true
                        break
                    else
                        array.push(indicesToRemove, i)

        // Batch removal in reverse order (preserves indices)
        if not skipNewBlock
            int removeCount = array.size(indicesToRemove)
            if removeCount > 0
                for j = removeCount - 1 to 0
                    int idx_to_remove = array.get(indicesToRemove, j)
                    deleteBlock(array.get(blocks, idx_to_remove))
                    array.remove(blocks, idx_to_remove)

            int leftBar = bar_index - idx

            // Guard against na/inf for relative volume
            float relVol = (not na(avgVol) and avgVol > 0) ? vol / avgVol : 1.0
            int direction = isBull ? DIR_BULL : DIR_BEAR

            // Create new block
            OrderBlock newBlock = OrderBlock.new(
                 array.new<box>(), na, na, na, na, array.new<box>(),
                 top, bot, direction,
                 vol, relVol, strength, false, 0, false, false,
                 na, 0, false, false)  // State tracking: lastUpdateBar, lastRetestCount, lastTouched, lastRejected
            
            box[] volBoxes = createVolumeGradient(newBlock, leftBar, effectiveGridSegments, effectiveRenderMode)
            newBlock.volumeBoxes := volBoxes
            
            [topLine, botLine, fill] = createBorder(newBlock, leftTime, effectiveRenderMode)
            newBlock.topLine := topLine
            newBlock.botLine := botLine
            newBlock.bgFill := fill
            
            // Add corner accents
            newBlock.cornerBoxes := createCornerAccents(newBlock, leftBar, effectiveRenderMode)
            
            // Create label if any label feature is enabled
            if showAnyLabel
                label lbl = createVolumeLabel(newBlock)
                newBlock.volLabel := lbl
            
            array.push(blocks, newBlock)
            created := true
    
    created

// === LIQUIDITY SWEEP HELPER FUNCTIONS ===
// Delete liquidity sweep visuals
deleteLiquiditySweep(LiquiditySweep sweep) =>
    if not na(sweep.levelLine)
        line.delete(sweep.levelLine)
    if not na(sweep.sweepBox)
        box.delete(sweep.sweepBox)
    if not na(sweep.sweepLabel)
        label.delete(sweep.sweepLabel)

// Update liquidity level line
updateLiquidityLevel(LiquiditySweep sweep) =>
    if not na(sweep.levelLine) and not sweep.swept and not sweep.ranThrough
        line.set_x2(sweep.levelLine, bar_index)

// Create liquidity level entry with equal H/L check
createLiquidityLevelEntry(float level, int levelBar, bool isBSL, array<LiquiditySweep> levels, bool createVisualLine) =>
    bool isEqual = false
    
    // Check existing levels for "equality" (clustered stops)
    int levelCount = array.size(levels)
    if markEqualHL and levelCount > 0
        for i = 0 to levelCount - 1
            LiquiditySweep existing = array.get(levels, i)
            if isEqualLevel(level, existing.level, equalHLThreshold)
                isEqual := true
                existing.isEqual := true  // Mark existing as equal too
                break
    
    // Create level line only if requested
    line levelLine = na
    if createVisualLine
        levelLine := createLiquidityLevel(level, levelBar, isBSL)
    
    // Create LiquiditySweep object
    int direction = isBSL ? DIR_BEAR : DIR_BULL  // BSL breaks bearish, SSL breaks bullish
    LiquiditySweep newLevel = LiquiditySweep.new(
         levelLine, na, na, level, levelBar, direction, isEqual,
         false, false, 0, 0.0, 0.0, "", false, 0, bar_index)
    
    array.push(levels, newLevel)

// Process sweeps and runs for liquidity levels
// Returns: [sweepDetected, runDetected, sweepBar]
// NOTE: Detection is decoupled from visuals - sweeps/runs are always detected when conditions met,
//       but visuals (boxes/labels) are only created when showSweepEvents is true.
//       This enables alerts-only mode (alerts fire without any visual clutter).
processSweepsAndRuns(array<LiquiditySweep> levels, bool isBSL) =>
    bool sweepDetected = false
    bool runDetected = false
    int sweepBar = 0
    
    int levelCount = array.size(levels)
    if levelCount > 0
        for i = levelCount - 1 to 0
            LiquiditySweep sweep = array.get(levels, i)
            
            // Skip if already swept or run
            if sweep.swept or sweep.ranThrough
                continue
            
            if isBSL
                // Check for bearish sweep (BSL taken, price reverses down)
                [detected, wickExt] = checkBearishSweep(sweep.level, sweepWickMin)
                if detected
                    // Always update state (detection decoupled from visuals)
                    sweep.swept := true
                    sweep.sweepBar := bar_index
                    sweep.sweepWick := wickExt
                    sweep.sweepClose := close
                    
                    // Check confluence with order blocks
                    bool nearOB = false
                    int bullBlockCount = array.size(bullBlocks)
                    if bullBlockCount > 0
                        for j = 0 to bullBlockCount - 1
                            OrderBlock b = array.get(bullBlocks, j)
                            if math.abs(sweep.level - b.top) / sweep.level * 100 < 0.5
                                nearOB := true
                                break
                    
                    // Calculate quality
                    bool volSpike = volume > avgVol
                    sweep.quality := getSweepQuality(wickExt, volSpike, nearOB, sweep.isEqual)
                    
                    // Only create visuals when showSweepEvents is enabled
                    if showSweepEvents
                        sweep.sweepBox := createSweepBox(sweep.level, wickExt, bar_index, false)
                        sweep.sweepLabel := createSweepLabel(sweep.level, wickExt, bar_index, false, sweep.quality)
                    
                    sweepDetected := true
                    sweepBar := bar_index
                else
                    // Check for bearish run (BSL taken, price continues up)
                    bool detected2 = checkBearishRun(sweep.level)
                    if detected2
                        // Always update state (detection decoupled from visuals)
                        sweep.ranThrough := true
                        sweep.sweepBar := bar_index
                        runDetected := true
            else
                // Check for bullish sweep (SSL taken, price reverses up)
                [detected, wickExt] = checkBullishSweep(sweep.level, sweepWickMin)
                if detected
                    // Always update state (detection decoupled from visuals)
                    sweep.swept := true
                    sweep.sweepBar := bar_index
                    sweep.sweepWick := wickExt
                    sweep.sweepClose := close
                    
                    // Check confluence with order blocks
                    bool nearOB = false
                    int bearBlockCount = array.size(bearBlocks)
                    if bearBlockCount > 0
                        for j = 0 to bearBlockCount - 1
                            OrderBlock b = array.get(bearBlocks, j)
                            if math.abs(sweep.level - b.bot) / sweep.level * 100 < 0.5
                                nearOB := true
                                break
                    
                    // Calculate quality
                    bool volSpike = volume > avgVol
                    sweep.quality := getSweepQuality(wickExt, volSpike, nearOB, sweep.isEqual)
                    
                    // Only create visuals when showSweepEvents is enabled
                    if showSweepEvents
                        sweep.sweepBox := createSweepBox(sweep.level, wickExt, bar_index, true)
                        sweep.sweepLabel := createSweepLabel(sweep.level, wickExt, bar_index, true, sweep.quality)
                    
                    sweepDetected := true
                    sweepBar := bar_index
                else
                    // Check for bullish run (SSL taken, price continues down)
                    bool detected2 = checkBullishRun(sweep.level)
                    if detected2
                        // Always update state (detection decoupled from visuals)
                        sweep.ranThrough := true
                        sweep.sweepBar := bar_index
                        runDetected := true
    
    [sweepDetected, runDetected, sweepBar]

// Update all liquidity levels
updateLiquidityLevels(array<LiquiditySweep> levels) =>
    int levelCount = array.size(levels)
    if levelCount > 0
        for i = 0 to levelCount - 1
            updateLiquidityLevel(array.get(levels, i))

// Trim old liquidity levels
trimLevels(array<LiquiditySweep> levels, int maxCount) =>
    int levelCount = array.size(levels)
    if levelCount > maxCount
        // Remove oldest swept/run levels first
        for i = levelCount - 1 to 0
            if levelCount <= maxCount
                break
            LiquiditySweep sweep = array.get(levels, i)
            if sweep.swept or sweep.ranThrough
                deleteLiquiditySweep(sweep)
                array.remove(levels, i)
                levelCount -= 1
        
        // If still too many, remove oldest
        while array.size(levels) > maxCount
            deleteLiquiditySweep(array.shift(levels))

// Check proximity to liquidity levels
checkLiquidityProximity(array<LiquiditySweep> levels, bool isBSL) =>
    bool isNear = false
    int levelCount = array.size(levels)
    if levelCount > 0
        for i = 0 to levelCount - 1
            LiquiditySweep sweep = array.get(levels, i)
            if sweep.swept or sweep.ranThrough
                continue
            
            float dist = 0.0
            if isBSL
                dist := sweep.level > close ? (sweep.level - close) / close * 100 : -1.0
            else
                dist := sweep.level < close ? (close - sweep.level) / close * 100 : -1.0
            
            if dist > 0 and dist <= liquidityProximityPct
                isNear := true
                break
    isNear

// === DETECTION LOGIC ===
bool validBull = false
bool validBear = false
int scalperBullIdx = 0
int scalperBearIdx = 0

// Pre-compute filter results only when needed (Institutional method + filter enabled)
// Scalper method doesn't use these filters, so skip computation entirely
bool hasDisplacement = false
bool hasBullFVG = false
bool hasBearFVG = false
bool hasBullMSB = false
bool hasBearMSB = false

if detectionMethod == "Institutional"
    if useDisplacement
        hasDisplacement := checkDisplacement(actualLookback - 1, dispMagnitude)
    if actualFVG
        hasBullFVG := checkFVG(actualLookback, "Bull")
        hasBearFVG := checkFVG(actualLookback, "Bear")
    if actualMSB
        hasBullMSB := checkMSB(actualLookback, actualLookback - 1, actualMsbPeriod, "Bull")
        hasBearMSB := checkMSB(actualLookback, actualLookback - 1, actualMsbPeriod, "Bear")

if detectionMethod == "Scalper"
    // === SCALPER DETECTION (ICT/SMC Method - Candle immediately before impulse) ===
    [scalperBear, scalperBull, bearIdx, bullIdx, bearImpStr, bullImpStr] = checkScalperCondition(scalperLookback)
    validBull := scalperBull
    validBear := scalperBear
    scalperBullIdx := bullIdx
    scalperBearIdx := bearIdx
    
    // Mutual exclusivity: if both trigger, pick the one with stronger IMPULSE candle
    if validBull and validBear
        // Compare impulse candle strength (not OB candle)
        if bullImpStr >= bearImpStr
            validBear := false
        else
            validBull := false
else
    // === INSTITUTIONAL DETECTION (Pivot-based with filters - stricter) ===
    bool isPivotLow = false
    bool isPivotHigh = false
    
    // Early-bars guard: need at least actualLookback * 2 bars of history
    if bar_index >= actualLookback * 2
        isPivotLow := true
        isPivotHigh := true
        
        for i = 1 to actualLookback
            if low[actualLookback] >= low[actualLookback + i] or low[actualLookback] >= low[actualLookback - i]
                isPivotLow := false
            if high[actualLookback] <= high[actualLookback + i] or high[actualLookback] <= high[actualLookback - i]
                isPivotHigh := false
    
    // Validation
    validBull := isPivotLow
    validBear := isPivotHigh
    
    // Filter: Displacement (use pre-computed values)
    if useDisplacement
        if validBull and close[actualLookback - 1] <= open[actualLookback - 1]
            validBull := false
        if validBear and close[actualLookback - 1] >= open[actualLookback - 1]
            validBear := false
        
        if validBull and not hasDisplacement
            validBull := false
        if validBear and not hasDisplacement
            validBear := false
    
    // Filter: FVG (use pre-computed values)
    if actualFVG
        if validBull and not hasBullFVG
            validBull := false
        if validBear and not hasBearFVG
            validBear := false
    
    // Filter: MSB (use pre-computed values)
    if actualMSB
        if validBull and not hasBullMSB
            validBull := false
        if validBear and not hasBearMSB
            validBear := false

// === CREATE ORDER BLOCKS ===
bool shouldCreateBull = barstate.isconfirmed and validBull
bool shouldCreateBear = barstate.isconfirmed and validBear
int bullIdx = detectionMethod == "Scalper" ? scalperBullIdx : actualLookback
int bearIdx = detectionMethod == "Scalper" ? scalperBearIdx : actualLookback
newBullOB := createOrderBlock(bullIdx, true, bullBlocks, shouldCreateBull)
newBearOB := createOrderBlock(bearIdx, false, bearBlocks, shouldCreateBear)

// === UPDATE & MITIGATION ===
// Update all blocks first (for proper anchoring)
updateBlocks(bullBlocks, effectiveGridSegments)
updateBlocks(bearBlocks, effectiveGridSegments)

// Then check mitigation and touches
[bullTouchTmp, bullRejectTmp] = processBlocks(bullBlocks, true)
bullTouch := bullTouchTmp
bullReject := bullRejectTmp
[bearTouchTmp, bearRejectTmp] = processBlocks(bearBlocks, false)
bearTouch := bearTouchTmp
bearReject := bearRejectTmp

// === OB TOUCH ANTI-SPAM LATCH ===
// Compute "in zone" state per side (must respect touchMode setting)
// This checks if price overlaps ANY active (non-mitigated) block of each side
isInAnyBlock(array<OrderBlock> blocks, string mode) =>
    bool inAny = false
    int blockCount = array.size(blocks)
    if blockCount > 0
        for i = 0 to blockCount - 1
            OrderBlock b = array.get(blocks, i)
            if not b.mitigated
                // Respect touchMode setting (same logic as retest detection)
                bool inZone = false
                if mode == "Wick"
                    inZone := low <= b.top and high >= b.bot
                else  // "Close inside zone"
                    inZone := close >= b.bot and close <= b.top
                if inZone
                    inAny := true
                    break
    inAny

bool inBullOBNow = isInAnyBlock(bullBlocks, touchMode)
bool inBearOBNow = isInAnyBlock(bearBlocks, touchMode)

// Edge-trigger: fire alert only on FIRST entry into any OB zone of that side
bool bullTouchTrigger = inBullOBNow and not wasInBullOB
bool bearTouchTrigger = inBearOBNow and not wasInBearOB

// Update latch state (must persist across bars, NOT reset each bar)
wasInBullOB := inBullOBNow
wasInBearOB := inBearOBNow

// === PROXIMITY ALERT DETECTION ===
if proximityAlertEnabled
    // Find nearest qualifying OB zones
    [nearBull, distBull] = findNearestOB(bullBlocks, true)
    [nearBear, distBear] = findNearestOB(bearBlocks, false)
    
    // Trigger alert only on state change (entering proximity range)
    // This prevents spam - only alerts once when first entering the zone
    nearBullOB := nearBull and not wasNearBullOB
    nearBearOB := nearBear and not wasNearBearOB
    
    // Update state for next bar
    wasNearBullOB := nearBull
    wasNearBearOB := nearBear

// Memory management (user-configurable)
int effectiveMaxBlocks = maxBlocks
if maxBlocksUser != "Auto"
    effectiveMaxBlocks := int(math.round(str.tonumber(maxBlocksUser)))

trimBlocks(bullBlocks, effectiveMaxBlocks)
trimBlocks(bearBlocks, effectiveMaxBlocks)

// === LIQUIDITY SWEEP DETECTION ===
// Gate all liquidity behavior behind enableLiquidity master toggle
// Run detection if ANY liquidity feature is enabled (visuals OR alerts)
bool liquidityVisualsEnabled = showLiquidityLevels or showSweepEvents or showLiquidityRuns
bool liquidityAlertsEnabled = alertLiquiditySweep or alertLiquidityRun or alertApproachingLiquidity
bool shouldRunLiquidity = enableLiquidity and (liquidityVisualsEnabled or liquidityAlertsEnabled)

if shouldRunLiquidity
    // 1. Detect new swing highs/lows (confirmed after rightBars)
    int confirmBars = math.round(sweepLookback / 2)
    [isNewSwingHigh, shLevel] = findSwingHigh(sweepLookback, confirmBars)
    [isNewSwingLow, slLevel] = findSwingLow(sweepLookback, confirmBars)

    // 2. Add new BSL levels (swing highs) - check for equal highs
    if isNewSwingHigh and barstate.isconfirmed
        createLiquidityLevelEntry(shLevel, bar_index - confirmBars, true, bslLevels, showLiquidityLevels)

    // 3. Add new SSL levels (swing lows) - check for equal lows
    if isNewSwingLow and barstate.isconfirmed
        createLiquidityLevelEntry(slLevel, bar_index - confirmBars, false, sslLevels, showLiquidityLevels)

    // 4. Check for sweeps AND runs on existing levels
    [bearSweep, bearRun, bearSweepBarTmp] = processSweepsAndRuns(bslLevels, true)   // Check BSL for bearish sweeps/runs
    [bullSweep, bullRun, bullSweepBarTmp] = processSweepsAndRuns(sslLevels, false)  // Check SSL for bullish sweeps/runs
    
    // Update global flags
    if bearSweep
        bearSweepDetected := true
        lastBearSweepBar := bearSweepBarTmp
    if bearRun
        bearRunDetected := true
    if bullSweep
        bullSweepDetected := true
        lastBullSweepBar := bullSweepBarTmp
    if bullRun
        bullRunDetected := true

    // 5. Update visuals (only if showing levels)
    if showLiquidityLevels
        updateLiquidityLevels(bslLevels)
        updateLiquidityLevels(sslLevels)

    // 6. Trim old levels (remove swept/run levels after N bars)
    trimLevels(bslLevels, maxLiquidityLevels)
    trimLevels(sslLevels, maxLiquidityLevels)
    
    // 7. Check proximity alerts (also gated by enableLiquidity)
    if alertApproachingLiquidity
        nearBSL := checkLiquidityProximity(bslLevels, true)
        nearSSL := checkLiquidityProximity(sslLevels, false)

// === LIQUIDITY PROXIMITY ANTI-SPAM LATCH ===
// Edge-trigger: fire alert only on FIRST entry into proximity zone
// Re-arm when price exits the zone
bool triggerNearBSL = nearBSL and not wasNearBSL
bool triggerNearSSL = nearSSL and not wasNearSSL

// Update latch state (must persist across bars, NOT reset each bar)
if nearBSL
    wasNearBSL := true
else
    wasNearBSL := false  // Re-arm when price exits proximity

if nearSSL
    wasNearSSL := true
else
    wasNearSSL := false  // Re-arm when price exits proximity

// === DASHBOARD ===
// Helper function to map location string to position enum
getDashboardPosition(string loc) =>
    loc == "Top Left" ? position.top_left : loc == "Bottom Right" ? position.bottom_right : loc == "Bottom Left" ? position.bottom_left : position.top_right

if showDashboard and barstate.islast
    // Check if location changed - need to recreate table
    if not na(lastDashboardLocation) and dashboardLocation != lastDashboardLocation
        if not na(dashboard)
            table.delete(dashboard)
            dashboard := na
    
    if na(dashboard)
        dashboard := table.new(getDashboardPosition(dashboardLocation), 7, 10, bgcolor=color.new(#000000, 10),
             border_color=color.new(color.white, 70), border_width=1)
        lastDashboardLocation := dashboardLocation
    
    table.clear(dashboard, 0, 0, 6, 9)
    
    // Header with mode tags
    table.merge_cells(dashboard, 0, 0, 6, 0)
    string presetDisplay = effectivePreset == "Scalping" ? "SCALPING" : effectivePreset == "Swing" ? "SWING" : "POSITION"
    string modeTag = settingsMode == "Auto" ? "MODE:AUTO" : "MODE:MANUAL"
    string confirmTag = signalTiming == "Confirmed (bar close)" ? " | CONFIRMED" : ""
    string headerText = presetDisplay + " | " + modeTag + confirmTag
    table.cell(dashboard, 0, 0, headerText, text_color=color.white, text_size=size.normal)
    
    // Column headers
    table.cell(dashboard, 0, 1, "Type", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 1, 1, "Volume", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 2, 1, "Dist%", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 3, 1, "Strength", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 4, 1, "Tests", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 5, 1, "Status", text_color=color.gray, text_size=size.small)
    table.cell(dashboard, 6, 1, "Vol", text_color=color.gray, text_size=size.small)
    
    int row = 2
    row := renderDashboardBlocks(dashboard, row, bearBlocks, false)
    row := renderDashboardBlocks(dashboard, row, bullBlocks, true)
    
    // Liquidity section (show if liquidity module is enabled with visuals OR any alerts)
    // Dashboard shows BSL/SSL info even in alerts-only mode (no visual lines)
    if enableLiquidity and (showLiquidityLevels or showSweepEvents or showLiquidityRuns or alertLiquiditySweep or alertLiquidityRun or alertApproachingLiquidity)
        int bslCount = array.size(bslLevels)
        int sslCount = array.size(sslLevels)
        if bslCount > 0 or sslCount > 0
            if row <= 7  // Leave rows 8-9 for Power
                table.cell(dashboard, 0, row, "â”€â”€â”€ LIQUIDITY â”€â”€â”€", text_color=color.gray, text_size=size.small)
                row += 1
            
            // Show nearest BSL
            if bslCount > 0 and row <= 7  // Leave rows 8-9 for Power
                LiquiditySweep nearestBSL = array.get(bslLevels, 0)
                float bslDist = (nearestBSL.level - close) / close * 100
                for i = 1 to bslCount - 1
                    LiquiditySweep sweep = array.get(bslLevels, i)
                    float dist = (sweep.level - close) / close * 100
                    if not sweep.swept and not sweep.ranThrough and dist < bslDist and dist > 0
                        nearestBSL := sweep
                        bslDist := dist
                
                if not nearestBSL.swept and not nearestBSL.ranThrough
                    string bslStatus = nearestBSL.isEqual ? "EQ BSL" : "BSL"
                    table.cell(dashboard, 0, row, bslStatus + " â–²", text_color=color.new(#00bfff, 0), text_size=size.small)
                    table.cell(dashboard, 1, row, str.tostring(round2(bslDist)) + "%", text_color=color.white, text_size=size.small)
                    row += 1
            
            // Show nearest SSL
            if sslCount > 0 and row <= 7  // Leave rows 8-9 for Power
                LiquiditySweep nearestSSL = array.get(sslLevels, 0)
                float sslDist = (close - nearestSSL.level) / close * 100
                for i = 1 to sslCount - 1
                    LiquiditySweep sweep = array.get(sslLevels, i)
                    float dist = (close - sweep.level) / close * 100
                    if not sweep.swept and not sweep.ranThrough and dist < sslDist and dist > 0
                        nearestSSL := sweep
                        sslDist := dist
                
                if not nearestSSL.swept and not nearestSSL.ranThrough
                    string sslStatus = nearestSSL.isEqual ? "EQ SSL" : "SSL"
                    table.cell(dashboard, 0, row, sslStatus + " â–¼", text_color=color.new(#ff6600, 0), text_size=size.small)
                    table.cell(dashboard, 1, row, str.tostring(round2(sslDist)) + "%", text_color=color.white, text_size=size.small)
                    row += 1
    
    // === POWER ROW (Intrabar Volume Dominance) - Always at bottom ===
    if showPowerRow
        // Use fixed rows at bottom of table (rows 8 and 9)
        int powerSepRow = 8
        int powerDataRow = 9
        
        // Format LTF indicator for display
        string ltfDisplay = effectivePowerLtf == "1" ? "@1m" : effectivePowerLtf == "5" ? "@5m" : 
             effectivePowerLtf == "15" ? "@15m" : effectivePowerLtf == "60" ? "@1h" : 
             effectivePowerLtf == "240" ? "@4h" : "@" + effectivePowerLtf
        
        // Separator line with LTF indicator
        string powerHeader = "â”€â”€â”€ POWER " + ltfDisplay + " â”€â”€â”€"
        table.cell(dashboard, 0, powerSepRow, powerHeader, text_color=color.gray, text_size=size.small)
        table.cell(dashboard, 1, powerSepRow, "", text_size=size.small)
        table.cell(dashboard, 2, powerSepRow, "", text_size=size.small)
        table.cell(dashboard, 3, powerSepRow, "", text_size=size.small)
        table.cell(dashboard, 4, powerSepRow, "", text_size=size.small)
        table.cell(dashboard, 5, powerSepRow, "", text_size=size.small)
        table.cell(dashboard, 6, powerSepRow, "", text_size=size.small)
        
        // Select display values based on signal timing mode
        // Confirmed mode uses latched values (stable, no intrabar flicker)
        // Realtime mode uses live values (updates every tick)
        int displaySide = signalTiming == "Confirmed (bar close)" ? latchedPowerSide : powerSide
        float displayPctRaw = signalTiming == "Confirmed (bar close)" ? latchedPowerPct : (na(smoothedPowerPct) ? 0.0 : smoothedPowerPct)
        int displayIntrabarCount = signalTiming == "Confirmed (bar close)" ? latchedIntrabarCount : intrabarCount
        // Include na(smoothedPowerPct) check so "â€”" is shown instead of "0%" when data is invalid
        bool displayLowConf = signalTiming == "Confirmed (bar close)" ? latchedPowerLowConf : (powerLowConf or na(smoothedPowerPct))
        
        // Determine display values
        string sideText = displaySide == 1 ? "BUY" : (displaySide == -1 ? "SELL" : "NEUTRAL")
        color sideCol = displaySide == 1 ? bullBorder : (displaySide == -1 ? bearBorder : color.gray)
        
        // Use smoothed value for display, handle low confidence
        float displayPct = displayLowConf ? 0.0 : math.min(displayPctRaw, 100.0)
        color pctCol = displayLowConf ? color.gray : sideCol
        
        // Column 0: "Power" label with mode indicator
        string modeIndicator = powerMode == "Auto" ? "Power" : "Power*"
        table.cell(dashboard, 0, powerDataRow, modeIndicator, text_color=color.white, text_size=size.small)
        // Column 1: BUY/SELL/NEUTRAL (colored)
        table.cell(dashboard, 1, powerDataRow, sideText, text_color=sideCol, text_size=size.small)
        // Column 2: Percentage (colored to match side)
        string pctText = displayLowConf ? "â€”" : (str.tostring(round1(displayPct)) + "%")
        table.cell(dashboard, 2, powerDataRow, pctText, text_color=pctCol, text_size=size.small)
        // Column 3: Intrabar count (confidence indicator)
        string confText = str.tostring(displayIntrabarCount) + " bars"
        color confCol = displayLowConf ? color.orange : color.gray
        table.cell(dashboard, 3, powerDataRow, confText, text_color=confCol, text_size=size.small)
        // Column 4: Show confirmation status (optional debug info)
        string confirmStatus = flipConfirmCount > 0 ? "(" + str.tostring(flipConfirmCount) + ")" : ""
        table.cell(dashboard, 4, powerDataRow, confirmStatus, text_color=color.gray, text_size=size.small)
        // Columns 5-6: blank
        table.cell(dashboard, 5, powerDataRow, "", text_size=size.small)
        table.cell(dashboard, 6, powerDataRow, "", text_size=size.small)

// === ALERTS ===
// Note: alertcondition must be at global scope
// Gate conditions with granular alert flags
alertcondition(alertNewOB and newBullOB, "New Bullish Order Block", "ğŸŸ¢ New Bull OB detected on {{ticker}} {{interval}}")
alertcondition(alertNewOB and newBearOB, "New Bearish Order Block", "ğŸ”´ New Bear OB detected on {{ticker}} {{interval}}")
// Touch alerts are edge-triggered: fires once per entry, re-arms when price exits all zones of that side
alertcondition(alertTouch and bullTouchTrigger, "Price in Bull Zone", "ğŸ’š Price testing Bull OB on {{ticker}} {{interval}}")
alertcondition(alertTouch and bearTouchTrigger, "Price in Bear Zone", "â¤ï¸ Price testing Bear OB on {{ticker}} {{interval}}")
alertcondition(alertReject and bullReject, "Bull Zone Rejection", "ğŸš€ Rejection from Bull OB on {{ticker}} {{interval}} - Potential LONG")
alertcondition(alertReject and bearReject, "Bear Zone Rejection", "ğŸ’¥ Rejection from Bear OB on {{ticker}} {{interval}} - Potential SHORT")

// Proximity Alerts (New - gives advance warning before price reaches zones)
alertcondition(proximityAlertEnabled and nearBullOB, "Approaching Bull OB", "âš ï¸ Price approaching BULLISH Order Block on {{ticker}} {{interval}} - Prepare LONG setup")
alertcondition(proximityAlertEnabled and nearBearOB, "Approaching Bear OB", "âš ï¸ Price approaching BEARISH Order Block on {{ticker}} {{interval}} - Prepare SHORT setup")

// === LIQUIDITY SWEEP ALERTS ===
// All liquidity alerts gated by enableLiquidity master toggle
// Liquidity Sweep Alerts
alertcondition(enableLiquidity and alertLiquiditySweep and bullSweepDetected, "Bullish Liquidity Sweep", "Bullish sweep on {{ticker}} {{interval}} - SSL taken, potential LONG")
alertcondition(enableLiquidity and alertLiquiditySweep and bearSweepDetected, "Bearish Liquidity Sweep", "Bearish sweep on {{ticker}} {{interval}} - BSL taken, potential SHORT")

// Liquidity Run Alerts (continuation after taking liquidity)
// BSL Run = price took buy-side liquidity (highs) and continued UP
// SSL Run = price took sell-side liquidity (lows) and continued DOWN
alertcondition(enableLiquidity and alertLiquidityRun and bearRunDetected, "BSL Run (Upside Continuation)", "Price took buy-side liquidity (BSL) on {{ticker}} {{interval}} and continued higher")
alertcondition(enableLiquidity and alertLiquidityRun and bullRunDetected, "SSL Run (Downside Continuation)", "Price took sell-side liquidity (SSL) on {{ticker}} {{interval}} and continued lower")

// Liquidity Proximity Alerts (edge-triggered: fires once per approach, re-arms when price exits)
alertcondition(enableLiquidity and alertApproachingLiquidity and triggerNearBSL, "Approaching BSL", "Price approaching buy-side liquidity on {{ticker}} {{interval}}")
alertcondition(enableLiquidity and alertApproachingLiquidity and triggerNearSSL, "Approaching SSL", "Price approaching sell-side liquidity on {{ticker}} {{interval}}")
