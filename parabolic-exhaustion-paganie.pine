//@version=6
indicator("Parabolic Exhaustion [Paganie] v4.0 SCALPER", overlay=true, max_labels_count=100)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CORE CONCEPT: Catch parabolic tops/bottoms - OPTIMIZED FOR CRYPTO ALTCOINS
// 1. Extreme price velocity (parabolic acceleration)
// 2. Reversal candle patterns (wicks, body ratio)
// 3. Volume climax + market activity filters
// 4. Immediate momentum deceleration
// 5. Minimum price movement filter (prevents low-volatility signals)
//
// CONFIDENCE SYSTEM (STRICTER):
// L3/S3 = Highest confidence (6+ points) - Premium setups
// L2/S2 = Medium confidence (5 points) - Quality setups
// L1/S1 = Lower confidence (4 points) - Minimum viable
//
// IMMEDIATE ENTRY: No BOS confirmation - signals fire instantly on candle close
// CRYPTO-OPTIMIZED: Built for volatile altcoin scalping and swing trading
//
// v4.0 IMPROVEMENTS (Scalper Edition):
// - ğŸš€ INSTANT ENTRY: Removed BOS/Retest delays - signals fire immediately
// - ğŸ“Š PRICE MOVEMENT FILTER: Adaptive % requirement (2% @ 1m to 30% @ 1D)
// - ğŸ’ CRYPTO ACTIVITY FILTERS: 1% ATR minimum + volume activity check
// - ğŸ¯ STRICTER SCORING: Raised to 4/5/6 points for L1/L2/L3 confidence
// - âš¡ OPTIMIZED FOR ALTCOINS: Volatile asset parameters, no more false signals in ranging markets
// - ğŸ“ˆ 10-BAR MOVEMENT CHECK: Ensures genuine momentum before triggering
// - ğŸ”¥ DUAL ACTIVITY GATES: Both ATR% and volume must confirm active market
//
// v3.3 IMPROVEMENTS:
// - FULL 1m to 1D support with automatic adaptation
// - Square root-based scaling for natural progression across all timeframes
// - Timeframe-specific threshold adjustments (stricter on low TF, lenient on high TF)
// - Volume multiplier adjusts by timeframe (higher on scalp, lower on swing)
// - Enhanced info table with timeframe classification
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TIMEFRAME DETECTION & SMART SCALING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Convert current timeframe to minutes
int tfMinutes = timeframe.in_seconds() / 60

// Multi-timeframe adaptive scaling (1m to 1D optimized)
// Uses logarithmic progression for natural scaling across all timeframes
// Reference point: 15m is baseline (1.0x)
float tfMultiplier = math.sqrt(tfMinutes / 15.0)

// Threshold adjustments - stricter on lower TFs (more noise), looser on higher TFs
// Lower TF = higher threshold (harder to trigger), Higher TF = lower threshold (easier to trigger)
float thresholdMultiplier = 
     tfMinutes <= 1 ? 1.8 :      // 1m: Very strict
     tfMinutes <= 3 ? 1.5 :      // 3m: Strict
     tfMinutes <= 5 ? 1.3 :      // 5m: Moderately strict
     tfMinutes <= 15 ? 1.0 :     // 15m: Baseline
     tfMinutes <= 60 ? 0.85 :    // 1h: More lenient
     tfMinutes <= 240 ? 0.75 :   // 4h: Lenient
     0.65                         // 1D: Most lenient

// Volume multiplier adjustment - lower TFs need higher volume confirmation
float volMultiplierAdjust = 
     tfMinutes <= 5 ? 1.3 :      // Very low TFs: need strong volume
     tfMinutes <= 15 ? 1.0 :     // 15m: baseline
     tfMinutes <= 240 ? 0.9 :    // Higher TFs: slightly lower
     0.85                         // 1D: lower volume requirement

// CRYPTO ALTCOIN FILTERS: 10% minimum price change in last 1 hour
// Ensures genuine momentum before triggering signals
float minPriceMovementPercent = 
     tfMinutes <= 60 ? 10.0 :     // 1m-1h: 10% minimum in last 1 hour
     tfMinutes <= 240 ? 20.0 :    // 4h: 20% minimum (proportional)
     30.0                          // 1D: 30% minimum (proportional)

// Calculate lookback bars to cover ~1 hour of price action
int movementLookback = tfMinutes <= 60 ? int(60 / math.max(1, tfMinutes)) : 10

// Market activity filter: ATR must be meaningful (1% baseline for crypto)
float minAtrPercent = 
     tfMinutes <= 5 ? 0.15 :      // Scalping: 0.15% minimum ATR
     tfMinutes <= 60 ? 0.25 :     // Intraday: 0.25%
     tfMinutes <= 240 ? 0.40 :    // 4h: 0.40%
     0.60                          // Daily: 0.60%

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USER SETTINGS (v4.0 - Simplified & Essential Only)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“Š MAIN CONTROLS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string groupMain = "âš™ï¸ Main Settings"

bool autoAdaptive = input.bool(true, "Auto-Adapt to Timeframe", group=groupMain,
     tooltip="ğŸ”¥ LEAVE ON (Recommended)\n\nAutomatically adjusts ALL parameters for your timeframe:\n\n" +
             "â€¢ 1m-5m: Scalping mode (2-4% moves, strict filters)\n" +
             "â€¢ 15m-1h: Intraday (8-12% moves, balanced)\n" +
             "â€¢ 4h-1D: Swing trading (20-30% moves, lenient)\n\n" +
             "Turn OFF only if you want manual parameter control")

string minConfidenceLevel = input.string("L2 (Balanced)", "Signal Quality", 
     options=["L3 (Best Only)", "L2 (Balanced)", "L1 (All Signals)"], 
     group=groupMain,
     tooltip="ğŸ¯ Controls how many signals you get:\n\n" +
             "L3 (6+ pts) = 1-3 signals/day - Only premium setups\n" +
             "L2 (5 pts)  = 3-8 signals/day - Quality + quantity â­\n" +
             "L1 (4 pts)  = 8-15 signals/day - More aggressive\n\n" +
             "âš¡ All signals fire INSTANTLY on candle close")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ¨ DISPLAY
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string groupDisplay = "ğŸ¨ Display"

string signalStyle = input.string("Labels", "Signal Style", 
     options=["Labels", "Arrows", "Both"], 
     group=groupDisplay,
     tooltip="Choose how signals appear:\n\n" +
             "â€¢ Labels: Shows L1/L2/L3 confidence level â­\n" +
             "â€¢ Arrows: Clean triangles only\n" +
             "â€¢ Both: Maximum visibility")

bool showConfidenceColors = input.bool(true, "Color Code by Quality", group=groupDisplay,
     tooltip="Uses different shades for L1/L2/L3\n\n" +
             "ON  = Darker = higher confidence â­\n" +
             "OFF = All signals same color")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ”§ ADVANCED (Optional)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string groupAdvanced = "ğŸ”§ Advanced (Optional)"

bool useRegimeFilter = input.bool(false, "Trend Filter", group=groupAdvanced,
     tooltip="Blocks counter-trend signals based on 1H trend\n\n" +
             "OFF = Trade both directions (scalping) â­\n" +
             "ON  = Only with-trend (swing trading)\n\n" +
             "Most crypto scalpers keep this OFF")

bool debugMode = input.bool(false, "Debug Table", group=groupAdvanced,
     tooltip="Shows detailed scoring breakdown\n\nUseful for optimization and learning")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTERNAL PARAMETERS (Auto-optimized)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTERNAL PARAMETERS (Auto-optimized, no user control needed)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Hardcoded filters for v4.0 (always active for crypto scalping)
bool useVolatilityFilter = true   // Always check market activity
string confirmationMode = "Off"    // No structure confirmation (instant entry)

// Detection parameters (optimized for crypto altcoins 1m-1D)
int velocityPeriod = autoAdaptive ? int(math.max(2, math.round(4 * tfMultiplier))) : 4
float velocityThreshold = autoAdaptive ? 1.8 * thresholdMultiplier : 1.8
int atrPeriod = autoAdaptive ? int(math.max(7, math.round(14 * tfMultiplier))) : 14
float minWickRatio = autoAdaptive ? 0.4 * thresholdMultiplier : 0.4
float minCandleSize = autoAdaptive ? 0.6 * thresholdMultiplier : 0.6
int rocPeriod = autoAdaptive ? int(math.max(2, math.round(6 * tfMultiplier))) : 6
int rocLookback = autoAdaptive ? int(math.max(30, math.round(100 * tfMultiplier))) : 100
float rocExtreme = autoAdaptive ? math.min(95.0, 85.0 + (tfMinutes < 15 ? (15 - tfMinutes) * 0.5 : 0)) : 85.0
float volMultiplier = autoAdaptive ? 1.3 * volMultiplierAdjust : 1.3
int volPeriod = autoAdaptive ? int(math.max(8, math.round(20 * tfMultiplier))) : 20
int cooldownBars = autoAdaptive ? int(math.max(0, math.round(5 * tfMultiplier))) : 5
int priceExtremeLookback = autoAdaptive ? int(math.max(20, math.round(35 * tfMultiplier))) : 35
float extremeTolAtr = autoAdaptive ? 0.7 / thresholdMultiplier : 0.7

// Hardcoded settings for v4.0
bool requireRocExtreme = false
bool requireBothCore = true
string regimeTf = "60"
int regimeEmaLen = 200
int regimeSlopeLookback = 20
int regimeAtrLen = 14
float maxRegimeSlopeAtr = 1.0

// Active values (for backward compatibility with existing code)
float velThreshold = velocityThreshold
float wickRatio = minWickRatio
float candleSize = minCandleSize
float volMult = volMultiplier
float rocExtremeAdj = rocExtreme

// Display info table if auto mode is on
var table infoTable = table.new(position.bottom_right, 2, 11, border_width=1)
if barstate.islast and autoAdaptive
    // Header - format timeframe name
    string tfName = tfMinutes < 60 ? str.tostring(tfMinutes) + "m" : tfMinutes < 1440 ? str.tostring(tfMinutes/60) + "h" : str.tostring(tfMinutes/1440) + "D"
    table.cell(infoTable, 0, 0, "ğŸ”„ AUTO", text_color=color.white, bgcolor=color.blue, text_size=size.tiny)
    table.cell(infoTable, 1, 0, tfName, text_color=color.white, bgcolor=color.blue, text_size=size.tiny, tooltip="Current timeframe")
    
    // Scaling info
    table.cell(infoTable, 0, 1, "Period:", text_color=color.white, text_size=size.tiny)
    table.cell(infoTable, 1, 1, str.tostring(tfMultiplier, "#.##") + "x", text_color=color.yellow, text_size=size.tiny, tooltip="Lookback multiplier")
    table.cell(infoTable, 0, 2, "Strict:", text_color=color.white, text_size=size.tiny)
    table.cell(infoTable, 1, 2, str.tostring(thresholdMultiplier, "#.##") + "x", text_color=color.orange, text_size=size.tiny, tooltip="Threshold strictness")
    
    // Active parameters
    table.cell(infoTable, 0, 3, "Vel:", text_color=color.white, text_size=size.tiny)
    table.cell(infoTable, 1, 3, str.tostring(velocityPeriod), text_color=color.lime, text_size=size.tiny, tooltip="Velocity period")
    table.cell(infoTable, 0, 4, "VelTh:", text_color=color.white, text_size=size.tiny)
    table.cell(infoTable, 1, 4, str.tostring(velThreshold, "#.##"), text_color=color.lime, text_size=size.tiny, tooltip="Velocity threshold")
    table.cell(infoTable, 0, 5, "ATR:", text_color=color.white, text_size=size.tiny)
    table.cell(infoTable, 1, 5, str.tostring(atrPeriod), text_color=color.lime, text_size=size.tiny, tooltip="ATR period")
    table.cell(infoTable, 0, 6, "Cool:", text_color=color.white, text_size=size.tiny)
    table.cell(infoTable, 1, 6, str.tostring(cooldownBars), text_color=color.lime, text_size=size.tiny, tooltip="Cooldown bars")
    table.cell(infoTable, 0, 7, "VolMx:", text_color=color.white, text_size=size.tiny)
    table.cell(infoTable, 1, 7, str.tostring(volMult, "#.##"), text_color=color.lime, text_size=size.tiny, tooltip="Volume multiplier")
    table.cell(infoTable, 0, 8, "ROC:", text_color=color.white, text_size=size.tiny)
    table.cell(infoTable, 1, 8, str.tostring(rocPeriod), text_color=color.lime, text_size=size.tiny, tooltip="ROC period")
    
    // Status and version
    string status = tfMinutes <= 5 ? "âš¡ SCALP" : tfMinutes <= 60 ? "ğŸ“ˆ INTRADAY" : tfMinutes <= 240 ? "ğŸ¯ SWING" : "ğŸ“Š POSITION"
    table.cell(infoTable, 0, 9, "Mode:", text_color=color.white, bgcolor=color.navy, text_size=size.tiny)
    table.cell(infoTable, 1, 9, status, text_color=color.yellow, bgcolor=color.navy, text_size=size.tiny)
    
    table.cell(infoTable, 0, 10, "v4.0:", text_color=color.white, bgcolor=color.new(color.purple, 70), text_size=size.tiny)
    table.cell(infoTable, 1, 10, "INSTANT", text_color=color.fuchsia, bgcolor=color.new(color.purple, 70), text_size=size.tiny, tooltip="Immediate entry, no BOS delay")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 1. PRICE VELOCITY (Parabolic Acceleration Detection)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

atr = ta.atr(atrPeriod)

// Calculate price velocity over short period
priceChange = close - close[velocityPeriod]
priceVelocity = atr > 0 ? math.abs(priceChange) / atr : 0

// Detect parabolic upward/downward acceleration
bool parabolicUp = priceChange > 0 and priceVelocity >= velThreshold
bool parabolicDown = priceChange < 0 and priceVelocity >= velThreshold

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 2. REVERSAL CANDLE PATTERNS (Real-time)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float bodySize = math.abs(close - open)
float upperWick = high - math.max(close, open)
float lowerWick = math.min(close, open) - low
float candleRange = high - low

bool isBullishCandle = close > open
bool isBearishCandle = close < open

// Bearish reversal patterns (at tops)
bool shootingStar = isBearishCandle and upperWick >= bodySize * wickRatio and candleRange >= candleSize * atr
bool bearishEngulfing = isBearishCandle and bodySize >= candleSize * atr and close < open[1] and open > close[1]
bool longUpperWick = upperWick >= lowerWick * 2 and upperWick >= bodySize and candleRange >= candleSize * atr

bool bearishReversalCandle = shootingStar or bearishEngulfing or longUpperWick

// Bullish reversal patterns (at bottoms)
bool hammer = isBullishCandle and lowerWick >= bodySize * wickRatio and candleRange >= candleSize * atr
bool bullishEngulfing = isBullishCandle and bodySize >= candleSize * atr and close > open[1] and open < close[1]
bool longLowerWick = lowerWick >= upperWick * 2 and lowerWick >= bodySize and candleRange >= candleSize * atr

bool bullishReversalCandle = hammer or bullishEngulfing or longLowerWick

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 3. ROC EXTREME (Momentum at extreme levels)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

roc = 100 * (close - close[rocPeriod]) / close[rocPeriod]
rocPercentile = ta.percentrank(roc, rocLookback)

bool rocExtremeBullish = rocPercentile <= (100 - rocExtremeAdj)  // Bottom percentile (oversold)
bool rocExtremeBearish = rocPercentile >= rocExtremeAdj           // Top percentile (overbought)

bool rocGateLong = not requireRocExtreme or rocExtremeBullish
bool rocGateShort = not requireRocExtreme or rocExtremeBearish

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 4. VOLUME CLIMAX
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

volMa = ta.sma(volume, volPeriod)
bool volumeClimax = volume >= volMa * volMult

// Volume declining after spike (exhaustion pattern) - compare to longer-term average
// Check if recent bars had high volume and current volume is declining
bool volExhaustionStrong = (volume[1] >= volMa[1] * volMult or volume[2] >= volMa[2] * volMult) and volume < ta.sma(volume, 10)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 5. MOMENTUM DECELERATION (Price slowing down)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Check if velocity is decreasing (deceleration) - multi-bar confirmation
float prevVelocity1 = atr[1] > 0 ? math.abs(close[1] - close[1 + velocityPeriod]) / atr[1] : 0
float prevVelocity2 = atr[2] > 0 ? math.abs(close[2] - close[2 + velocityPeriod]) / atr[2] : 0
// Velocity is decreasing if current is less than previous AND average of last 2 bars
bool velocityDecreasing = priceVelocity < prevVelocity1 and priceVelocity < ((prevVelocity1 + prevVelocity2) / 2)

// Check if we're at a significant price extreme
float priceHigh = ta.highest(high, priceExtremeLookback)
float priceLow = ta.lowest(low, priceExtremeLookback)
bool nearHighExtreme = atr > 0 and high >= (priceHigh - (extremeTolAtr * atr))
bool nearLowExtreme = atr > 0 and low <= (priceLow + (extremeTolAtr * atr))

// v4.0: Structure confirmation removed (instant entry mode only)

int idxHighTF = barstate.isrealtime ? 1 : 0
int idxCurrTF = barstate.isrealtime ? 0 : 1

[regimeEma0, regimeEmaPrev0, regimeAtr0] = request.security(syminfo.tickerid, regimeTf,
     [ta.ema(close, regimeEmaLen)[idxHighTF], ta.ema(close, regimeEmaLen)[idxHighTF + regimeSlopeLookback], ta.atr(regimeAtrLen)[idxHighTF]],
     gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

float regimeEma = regimeEma0[idxCurrTF]
float regimeEmaPrev = regimeEmaPrev0[idxCurrTF]
float regimeAtr = regimeAtr0[idxCurrTF]
float regimeSlopeSignedAtr = (not na(regimeAtr) and regimeAtr != 0.0) ? (regimeEma - regimeEmaPrev) / regimeAtr : na

bool regimeOkLong = not useRegimeFilter or na(regimeSlopeSignedAtr) or regimeSlopeSignedAtr >= -maxRegimeSlopeAtr
bool regimeOkShort = not useRegimeFilter or na(regimeSlopeSignedAtr) or regimeSlopeSignedAtr <= maxRegimeSlopeAtr

float regimeSlopeAtr = na(regimeSlopeSignedAtr) ? na : math.abs(regimeSlopeSignedAtr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRYPTO ALTCOIN ACTIVITY FILTERS (v4.0)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// FILTER 1: ATR % Check - Market must have meaningful volatility
// For crypto: ATR must be at least 0.15-0.60% of price (adaptive by TF)
int atrLookback = math.min(100, int(1440 / math.max(1, tfMinutes)))  // ~24h of bars
float atr100 = ta.atr(math.min(atrPeriod, atrLookback))
float atrPercent = close > 0 ? (atr100 / close) * 100 : 0
bool atrActivityOk = atrPercent >= minAtrPercent  // ATR must be >= threshold

// FILTER 2: Volume Activity Check - Volume must be >= 50% of 24h average
int volLookback24h = math.min(100, int(1440 / math.max(1, tfMinutes)))
float vol24hAvg = ta.sma(volume, volLookback24h)
float volCurrent = ta.sma(volume, 20)
bool volumeActivityOk = vol24hAvg > 0 and volCurrent >= (vol24hAvg * 0.5)

// FILTER 3: Price Movement Check - Price must have moved enough in last 10 bars
float priceMovement10 = math.abs(close - close[movementLookback])
float priceMovementPercent = close[movementLookback] > 0 ? (priceMovement10 / close[movementLookback]) * 100 : 0
bool sufficientMovement = priceMovementPercent >= minPriceMovementPercent

// Combined activity filter - ALL must pass
bool marketActive = atrActivityOk and volumeActivityOk and sufficientMovement

// Legacy volatility filter (optional, but overridden by marketActive)
float atrSma = ta.sma(atr, 50)
float atrRatio = atrSma > 0 ? atr / atrSma : 0
bool volatilityOk = not useVolatilityFilter or (atrRatio >= 0.7 and marketActive)

// v4.0: Pivot detection removed (no longer needed for BOS-free instant entry)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 6. COMPOSITE SIGNAL GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// LONG Signal: After parabolic down move, see reversal signs
int longScore = 0
bool longHasVelocity = parabolicDown
bool longHasCandle = bullishReversalCandle

if longHasVelocity
    longScore += 2  // Strong weight for velocity
if longHasCandle
    longScore += 2  // Strong weight for reversal candle
if longHasVelocity and longHasCandle
    longScore += 1  // Bonus for having BOTH core conditions
if rocExtremeBullish
    longScore += 1
if volumeClimax or volExhaustionStrong
    longScore += 1
if velocityDecreasing
    longScore += 1
if nearLowExtreme
    longScore += 1  // Bonus point for being at price extreme

// SHORT Signal: After parabolic up move, see reversal signs  
int shortScore = 0
bool shortHasVelocity = parabolicUp
bool shortHasCandle = bearishReversalCandle

if shortHasVelocity
    shortScore += 2  // Strong weight for velocity
if shortHasCandle
    shortScore += 2  // Strong weight for reversal candle
if shortHasVelocity and shortHasCandle
    shortScore += 1  // Bonus for having BOTH core conditions
if rocExtremeBearish
    shortScore += 1
if volumeClimax or volExhaustionStrong
    shortScore += 1
if velocityDecreasing
    shortScore += 1
if nearHighExtreme
    shortScore += 1  // Bonus point for being at price extreme

// CONFIDENCE LEVEL SYSTEM (v4.0 - STRICTER FOR CRYPTO)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// L3/S3 = 6+ points (Premium - highest confidence)
// L2/S2 = 5 points (Quality - good confidence)
// L1/S1 = 4 points (Minimum viable - acceptable)

int minScoreRequired = minConfidenceLevel == "L3 (Best Only)" ? 6 : 
     minConfidenceLevel == "L2 (Balanced)" ? 5 : 4

// Determine confidence levels (stricter thresholds)
int longConfidence = longScore >= 6 ? 3 : longScore == 5 ? 2 : longScore == 4 ? 1 : 0
int shortConfidence = shortScore >= 6 ? 3 : shortScore == 5 ? 2 : shortScore == 4 ? 1 : 0

// Core requirements check
bool longCoreOk = not requireBothCore or (longHasVelocity and longHasCandle)
bool shortCoreOk = not requireBothCore or (shortHasVelocity and shortHasCandle)

// v4.0: Structure confirmation always off (instant entry mode)
bool spikeConfirmLongOk = true
bool spikeConfirmShortOk = true

bool longSetupRaw = longScore >= minScoreRequired and longCoreOk and rocGateLong and volatilityOk and longConfidence > 0
bool shortSetupRaw = shortScore >= minScoreRequired and shortCoreOk and rocGateShort and volatilityOk and shortConfidence > 0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// v4.0 INSTANT ENTRY - No BOS/Retest delays
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Signals fire IMMEDIATELY when exhaustion setup is detected and confirmed
// This is optimal for crypto scalping where speed is critical

bool longSignalRaw = longSetupRaw and barstate.isconfirmed and regimeOkLong
bool shortSignalRaw = shortSetupRaw and barstate.isconfirmed and regimeOkShort

// Score and confidence are taken directly from current bar (no setup tracking needed)
int longScoreUsed = longScore
int shortScoreUsed = shortScore
int longConfidenceUsed = longConfidence
int shortConfidenceUsed = shortConfidence

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 7. FILTERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var int lastSignalBar = na
bool cooldownOk = cooldownBars == 0 or na(lastSignalBar) or (bar_index - lastSignalBar) > cooldownBars

// Fixed: Use >= for one direction to allow signals when scores are equal
// Priority to the direction that actually triggered (longSignalRaw/shortSignalRaw)
bool longSignal = longSignalRaw and cooldownOk and longScoreUsed >= shortScoreUsed
bool shortSignal = shortSignalRaw and cooldownOk and shortScoreUsed > longScoreUsed

// Update last signal bar for cooldown tracking
if longSignal or shortSignal
    lastSignalBar := bar_index

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VISUAL SIGNALS WITH CONFIDENCE LEVELS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool showTriangles = signalStyle == "Arrows" or signalStyle == "Both"
bool showLabels = signalStyle == "Labels" or signalStyle == "Both"

// Confidence-based colors
color longColorBase = #00A855
color longColorL3 = longColorBase
color longColorL2 = showConfidenceColors ? #008544 : longColorBase
color longColorL1 = showConfidenceColors ? #006633 : longColorBase

color shortColorBase = #CC0000
color shortColorS3 = shortColorBase
color shortColorS2 = showConfidenceColors ? #AA0000 : shortColorBase
color shortColorS1 = showConfidenceColors ? #880000 : shortColorBase

// v4.0: Setup markers removed (instant entry makes them redundant)

// Text colors (readable on dark backgrounds)
color longTextColor = color.new(#FFFFFF, 0)   // White on dark green
color shortTextColor = color.new(#FFFFFF, 0)  // White on dark red

// Determine which confidence level triggered
bool longL3 = longSignal and longConfidenceUsed == 3
bool longL2 = longSignal and longConfidenceUsed == 2
bool longL1 = longSignal and longConfidenceUsed == 1

bool shortS3 = shortSignal and shortConfidenceUsed == 3
bool shortS2 = shortSignal and shortConfidenceUsed == 2
bool shortS1 = shortSignal and shortConfidenceUsed == 1

// Triangles with confidence colors
plotshape(showTriangles and longL3, title="L3 â–²", style=shape.triangleup, location=location.belowbar,
     color=color.new(longColorL3, 0), size=size.small)
plotshape(showTriangles and longL2, title="L2 â–²", style=shape.triangleup, location=location.belowbar,
     color=color.new(longColorL2, 0), size=size.small)
plotshape(showTriangles and longL1, title="L1 â–²", style=shape.triangleup, location=location.belowbar,
     color=color.new(longColorL1, 0), size=size.small)

plotshape(showTriangles and shortS3, title="S3 â–¼", style=shape.triangledown, location=location.abovebar,
     color=color.new(shortColorS3, 0), size=size.small)
plotshape(showTriangles and shortS2, title="S2 â–¼", style=shape.triangledown, location=location.abovebar,
     color=color.new(shortColorS2, 0), size=size.small)
plotshape(showTriangles and shortS1, title="S1 â–¼", style=shape.triangledown, location=location.abovebar,
     color=color.new(shortColorS1, 0), size=size.small)

// Confidence-based text labels
if showLabels
    if longSignal
        color longLabelColor = longConfidenceUsed == 3 ? longColorL3 : longConfidenceUsed == 2 ? longColorL2 : longColorL1
        label.new(bar_index, low, text="L" + str.tostring(longConfidenceUsed), style=label.style_label_up,
             color=longLabelColor, textcolor=longTextColor, size=size.small)
    if shortSignal
        color shortLabelColor = shortConfidenceUsed == 3 ? shortColorS3 : shortConfidenceUsed == 2 ? shortColorS2 : shortColorS1
        label.new(bar_index, high, text="S" + str.tostring(shortConfidenceUsed), style=label.style_label_down,
             color=shortLabelColor, textcolor=shortTextColor, size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DEBUG TABLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if debugMode
    var table debugTable = table.new(position.top_right, 3, 21, border_width=1)
    
    if barstate.islast
        table.cell(debugTable, 0, 0, "Condition", text_color=color.white, bgcolor=color.gray)
        table.cell(debugTable, 1, 0, "Bullish", text_color=color.white, bgcolor=color.gray)
        table.cell(debugTable, 2, 0, "Bearish", text_color=color.white, bgcolor=color.gray)
        
        table.cell(debugTable, 0, 1, "Parabolic Move", text_color=color.white)
        table.cell(debugTable, 1, 1, parabolicDown ? "âœ“ (2pts)" : "âœ—", 
             text_color=parabolicDown ? color.lime : color.red)
        table.cell(debugTable, 2, 1, parabolicUp ? "âœ“ (2pts)" : "âœ—", 
             text_color=parabolicUp ? color.lime : color.red)
        
        table.cell(debugTable, 0, 2, "Reversal Candle", text_color=color.white)
        table.cell(debugTable, 1, 2, bullishReversalCandle ? "âœ“ (2pts)" : "âœ—", 
             text_color=bullishReversalCandle ? color.lime : color.red)
        table.cell(debugTable, 2, 2, bearishReversalCandle ? "âœ“ (2pts)" : "âœ—", 
             text_color=bearishReversalCandle ? color.lime : color.red)
        
        table.cell(debugTable, 0, 3, "ROC Extreme", text_color=color.white)
        table.cell(debugTable, 1, 3, rocExtremeBullish ? "âœ“ (1pt)" : "âœ—", 
             text_color=rocExtremeBullish ? color.lime : color.red)
        table.cell(debugTable, 2, 3, rocExtremeBearish ? "âœ“ (1pt)" : "âœ—", 
             text_color=rocExtremeBearish ? color.lime : color.red)
        
        table.cell(debugTable, 0, 4, "Volume Climax", text_color=color.white)
        table.cell(debugTable, 1, 4, volumeClimax ? "âœ“ (1pt)" : "âœ—", 
             text_color=volumeClimax ? color.lime : color.red)
        table.cell(debugTable, 2, 4, volumeClimax ? "âœ“ (1pt)" : "âœ—", 
             text_color=volumeClimax ? color.lime : color.red)
        
        table.cell(debugTable, 0, 5, "Deceleration", text_color=color.white)
        table.cell(debugTable, 1, 5, velocityDecreasing ? "âœ“ (1pt)" : "âœ—", 
             text_color=velocityDecreasing ? color.lime : color.red)
        table.cell(debugTable, 2, 5, velocityDecreasing ? "âœ“ (1pt)" : "âœ—", 
             text_color=velocityDecreasing ? color.lime : color.red)
        
        table.cell(debugTable, 0, 6, "Price Extreme", text_color=color.white)
        table.cell(debugTable, 1, 6, nearLowExtreme ? "âœ“ (1pt)" : "âœ—", 
             text_color=nearLowExtreme ? color.lime : color.red)
        table.cell(debugTable, 2, 6, nearHighExtreme ? "âœ“ (1pt)" : "âœ—", 
             text_color=nearHighExtreme ? color.lime : color.red)
        
        table.cell(debugTable, 0, 7, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray)
        table.cell(debugTable, 1, 7, "â”€â”€â”€â”€â”€", text_color=color.gray)
        table.cell(debugTable, 2, 7, "â”€â”€â”€â”€â”€", text_color=color.gray)
        
        table.cell(debugTable, 0, 8, "SCORE / Required", text_color=color.white)
        table.cell(debugTable, 1, 8, str.tostring(longScore) + " / " + str.tostring(minScoreRequired), 
             text_color=longScore >= minScoreRequired ? color.lime : color.orange)
        table.cell(debugTable, 2, 8, str.tostring(shortScore) + " / " + str.tostring(minScoreRequired), 
             text_color=shortScore >= minScoreRequired ? color.lime : color.orange)
        
        table.cell(debugTable, 0, 9, "Core (Vel+Candle)", text_color=color.white)
        table.cell(debugTable, 1, 9, longCoreOk ? "âœ“" : "âœ— BLOCKING", 
             text_color=longCoreOk ? color.lime : color.red)
        table.cell(debugTable, 2, 9, shortCoreOk ? "âœ“" : "âœ— BLOCKING", 
             text_color=shortCoreOk ? color.lime : color.red)
        
        table.cell(debugTable, 0, 10, "Cooldown", text_color=color.white)
        table.cell(debugTable, 1, 10, cooldownOk ? "âœ“" : "âœ— BLOCKING", 
             text_color=cooldownOk ? color.lime : color.red)
        table.cell(debugTable, 2, 10, cooldownOk ? "âœ“" : "âœ— BLOCKING", 
             text_color=cooldownOk ? color.lime : color.red)
        
        table.cell(debugTable, 0, 11, "ATR % Activity", text_color=color.white)
        table.cell(debugTable, 1, 11, atrActivityOk ? ("âœ“ " + str.tostring(atrPercent, "#.##") + "%") : ("âœ— " + str.tostring(atrPercent, "#.##") + "%"), 
             text_color=atrActivityOk ? color.lime : color.red)
        table.cell(debugTable, 2, 11, atrActivityOk ? "âœ“" : "âœ—", 
             text_color=atrActivityOk ? color.lime : color.red)
        
        table.cell(debugTable, 0, 12, "Volume Activity", text_color=color.white)
        table.cell(debugTable, 1, 12, volumeActivityOk ? "âœ“" : "âœ— BLOCKING", 
             text_color=volumeActivityOk ? color.lime : color.red)
        table.cell(debugTable, 2, 12, volumeActivityOk ? "âœ“" : "âœ— BLOCKING", 
             text_color=volumeActivityOk ? color.lime : color.red)
        
        table.cell(debugTable, 0, 13, "Price Movement", text_color=color.white)
        table.cell(debugTable, 1, 13, sufficientMovement ? ("âœ“ " + str.tostring(priceMovementPercent, "#.#") + "%") : ("âœ— " + str.tostring(priceMovementPercent, "#.#") + "%"), 
             text_color=sufficientMovement ? color.lime : color.red)
        table.cell(debugTable, 2, 13, sufficientMovement ? "âœ“" : "âœ—", 
             text_color=sufficientMovement ? color.lime : color.red)
        
        table.cell(debugTable, 0, 14, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray)
        table.cell(debugTable, 1, 14, "â”€â”€â”€â”€â”€", text_color=color.gray)
        table.cell(debugTable, 2, 14, "â”€â”€â”€â”€â”€", text_color=color.gray)
        
        table.cell(debugTable, 0, 15, "CONFIDENCE LEVEL", text_color=color.white, bgcolor=color.navy)
        string longText = longL3 ? "ğŸš€ L3 (6+)" : longL2 ? "ğŸš€ L2 (5)" : longL1 ? "ğŸš€ L1 (4)" : "â€”"
        string shortText = shortS3 ? "ğŸ”» S3 (6+)" : shortS2 ? "ğŸ”» S2 (5)" : shortS1 ? "ğŸ”» S1 (4)" : "â€”"
        table.cell(debugTable, 1, 15, longText, 
             text_color=color.white, bgcolor=longSignal ? color.green : color.navy)
        table.cell(debugTable, 2, 15, shortText, 
             text_color=color.white, bgcolor=shortSignal ? color.red : color.navy)
        
        table.cell(debugTable, 0, 16, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray)
        table.cell(debugTable, 1, 16, "â”€â”€â”€â”€â”€", text_color=color.gray)
        table.cell(debugTable, 2, 16, "â”€â”€â”€â”€â”€", text_color=color.gray)
        
        table.cell(debugTable, 0, 17, "Price Velocity", text_color=color.white)
        table.cell(debugTable, 1, 17, str.tostring(priceVelocity, "#.##") + "x ATR", text_color=color.orange)
        table.cell(debugTable, 2, 17, "", text_color=color.white)
        
        table.cell(debugTable, 0, 18, "ROC Percentile", text_color=color.white)
        table.cell(debugTable, 1, 18, str.tostring(rocPercentile, "#.##") + "%", text_color=color.orange)
        table.cell(debugTable, 2, 18, "", text_color=color.white)
        
        table.cell(debugTable, 0, 19, "Volume Ratio", text_color=color.white)
        table.cell(debugTable, 1, 19, volMa > 0 ? str.tostring(volume/volMa, "#.##") + "x" : "â€”", text_color=color.orange)
        table.cell(debugTable, 2, 19, "", text_color=color.white)
        
        table.cell(debugTable, 0, 20, "Candle Type", text_color=color.white)
        string candleType = shootingStar ? "Shooting Star" : 
             bearishEngulfing ? "Bear Engulf" : 
             longUpperWick ? "Long U-Wick" :
             hammer ? "Hammer" :
             bullishEngulfing ? "Bull Engulf" :
             longLowerWick ? "Long L-Wick" : "Regular"
        table.cell(debugTable, 1, 20, candleType, text_color=color.orange)
        table.cell(debugTable, 2, 20, "", text_color=color.white)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

alertcondition(longL3, title="L3 - High Confidence Long", message="L3 (High Confidence): Parabolic bottom on {{ticker}} {{interval}}")
alertcondition(longL2, title="L2 - Medium Confidence Long", message="L2 (Medium Confidence): Parabolic bottom on {{ticker}} {{interval}}")
alertcondition(longL1, title="L1 - Low Confidence Long", message="L1 (Lower Confidence): Parabolic bottom on {{ticker}} {{interval}}")

alertcondition(shortS3, title="S3 - High Confidence Short", message="S3 (High Confidence): Parabolic top on {{ticker}} {{interval}}")
alertcondition(shortS2, title="S2 - Medium Confidence Short", message="S2 (Medium Confidence): Parabolic top on {{ticker}} {{interval}}")
alertcondition(shortS1, title="S1 - Low Confidence Short", message="S1 (Lower Confidence): Parabolic top on {{ticker}} {{interval}}")
