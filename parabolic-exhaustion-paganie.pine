//@version=6
indicator("Parabolic Exhaustion [Paganie] v3.3", overlay=true, max_labels_count=100)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CORE CONCEPT: Catch parabolic tops/bottoms with CONFIDENCE LEVELS
// 1. Extreme price velocity (parabolic acceleration)
// 2. Reversal candle patterns (wicks, body ratio)
// 3. Volume climax
// 4. Immediate momentum deceleration
//
// CONFIDENCE SYSTEM:
// L3/S3 = Highest confidence (5-7+ points) - Best risk/reward
// L2/S2 = Medium confidence (4 points) - Good setups
// L1/S1 = Lower confidence (3 points) - Aggressive only
//
// MULTI-TIMEFRAME ADAPTIVE: Automatically adjusts to any chart timeframe
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TIMEFRAME DETECTION & SMART SCALING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Convert current timeframe to minutes
int tfMinutes = timeframe.in_seconds() / 60

// Timeframe category for logic branching
string tfCategory = 
     tfMinutes <= 1 ? "scalp" :       // 1m
     tfMinutes <= 5 ? "micro" :       // 2-5m
     tfMinutes <= 15 ? "intraday" :   // 6-15m
     tfMinutes <= 60 ? "swing" :      // 16m-1h
     tfMinutes <= 240 ? "position" :  // 2h-4h
     tfMinutes <= 1440 ? "daily" :    // 6h-1D
     "macro"                           // Weekly+

// Smart scaling based on timeframe characteristics (not linear)
// Lower TFs need tighter parameters due to noise
// Higher TFs need longer lookbacks but similar sensitivity
float tfMultiplier = 
     tfMinutes <= 1 ? 0.3 :       // 1m: Very tight, reduce noise
     tfMinutes <= 2 ? 0.4 :       // 2m: Tight
     tfMinutes <= 3 ? 0.5 :       // 3m: Tighter than baseline
     tfMinutes <= 5 ? 0.7 :       // 5m: Moderately tight
     tfMinutes <= 10 ? 0.85 :     // 10m: Approaching baseline
     tfMinutes <= 15 ? 1.0 :      // 15m: Baseline (optimal)
     tfMinutes <= 30 ? 1.3 :      // 30m: Slightly longer
     tfMinutes <= 60 ? 1.8 :      // 1h: Longer periods
     tfMinutes <= 120 ? 2.5 :     // 2h: Extended
     tfMinutes <= 240 ? 4.0 :     // 4h: Much longer
     tfMinutes <= 480 ? 8.0 :     // 8h: Very long
     tfMinutes <= 1440 ? 14.0 :   // Daily: Daily scale
     tfMinutes <= 10080 ? 50.0 :  // Weekly: Weekly scale
     100.0                         // Monthly+: Extra long

// Threshold adjustments - lower TFs need stricter thresholds to filter noise
// Higher TFs can be more lenient as moves are more meaningful
float thresholdMultiplier = 
     tfMinutes <= 1 ? 1.4 :       // 1m: Very strict to filter noise
     tfMinutes <= 3 ? 1.25 :      // 3m: Strict
     tfMinutes <= 5 ? 1.15 :      // 5m: Moderately strict
     tfMinutes <= 10 ? 1.05 :     // 10m: Slightly strict
     tfMinutes <= 15 ? 1.0 :      // 15m: Baseline
     tfMinutes <= 30 ? 0.95 :     // 30m: Slightly lenient
     tfMinutes <= 60 ? 0.9 :      // 1h: Lenient
     tfMinutes <= 240 ? 0.85 :    // 4h: More lenient
     tfMinutes <= 1440 ? 0.8 :    // Daily: Very lenient
     0.75                          // Weekly+: Most lenient

// Candle pattern sensitivity - higher TFs have more meaningful candle patterns
float candleMultiplier = 
     tfMinutes <= 1 ? 1.5 :       // 1m: Require larger relative candles
     tfMinutes <= 5 ? 1.3 :       // 5m: Larger candles needed
     tfMinutes <= 15 ? 1.0 :      // 15m: Baseline
     tfMinutes <= 60 ? 0.85 :     // 1h: Smaller relative requirement
     tfMinutes <= 240 ? 0.7 :     // 4h: Even smaller
     0.6                           // Daily+: Most flexible

// Volume spike sensitivity - lower TFs have more volume noise
float volumeMultiplier = 
     tfMinutes <= 1 ? 1.6 :       // 1m: Require much higher volume spikes
     tfMinutes <= 5 ? 1.4 :       // 5m: Higher spikes needed
     tfMinutes <= 15 ? 1.0 :      // 15m: Baseline
     tfMinutes <= 60 ? 0.9 :      // 1h: Lower requirement
     0.8                           // 4h+: Lowest requirement

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// USER SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SIGNAL SETTINGS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string GROUP_SIGNAL = "âš¡ Signal Settings"

string minConfidenceLevel = input.string("Medium (L2/S2)", "Signal Quality", 
     options=["High Only (L3/S3)", "Medium (L2/S2)", "All Signals (L1/S1)"], 
     group=GROUP_SIGNAL,
     tooltip="HIGH = Fewest signals, best quality (5+ score)\nMEDIUM = Balanced (4+ score) - Recommended\nALL = Most signals, includes lower quality (3+ score)")

string entryModel = input.string("Immediate", "Entry Mode",
     options=["Immediate", "Break Confirmed", "Break + Retest"],
     group=GROUP_SIGNAL,
     tooltip="IMMEDIATE = Signal on pattern detection (fastest entry)\nBREAK CONFIRMED = Wait for close above/below setup level\nBREAK + RETEST = Wait for break and pullback to level (highest precision)")

int cooldownBarsInput = input.int(8, "Cooldown Bars", minval=0, maxval=50, 
     group=GROUP_SIGNAL,
     tooltip="Minimum bars between signals to prevent clustering")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FILTERS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string GROUP_FILTER = "ğŸ¯ Filters"

string confirmationMode = input.string("Off", "Sweep Confirmation",
     options=["Off", "Require Sweep"],
     group=GROUP_FILTER,
     tooltip="OFF = Signal on pattern alone\nREQUIRE SWEEP = Price must sweep recent high/low and close back (reduces false signals)")

bool useVolatilityFilter = input.bool(true, "Volatility Filter", group=GROUP_FILTER,
     tooltip="Blocks signals during low-volatility / ranging markets where reversals are less reliable")

bool useRegimeFilter = input.bool(false, "Higher TF Trend Filter", group=GROUP_FILTER,
     tooltip="Blocks counter-trend signals when higher timeframe shows strong trend (uses 1H for <30m charts, 4H for 30m-1H, Daily for 4H)")

bool requireBothCore = input.bool(true, "Require Velocity + Candle", group=GROUP_FILTER,
     tooltip="When ON: Requires BOTH parabolic velocity AND reversal candle pattern\nWhen OFF: Either condition alone can trigger (more signals, lower quality)")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SENSITIVITY
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string GROUP_SENS = "ğŸšï¸ Sensitivity"

bool autoAdaptive = input.bool(true, "Auto-Adapt to Timeframe", group=GROUP_SENS,
     tooltip="Automatically adjusts all detection parameters based on chart timeframe. Recommended ON for most users.")

float velocityThresholdInput = input.float(2.0, "Velocity Threshold", minval=0.5, maxval=5.0, step=0.1,
     group=GROUP_SENS,
     tooltip="Minimum price velocity (in ATR units) to detect parabolic move. Higher = stricter, fewer signals. Default: 2.0")

float minPriceMoveInput = input.float(2.2, "Min Price Move (ATR)", minval=0.5, maxval=5.0, step=0.1,
     group=GROUP_SENS,
     tooltip="Minimum price range required before reversal signal. Higher = needs bigger moves. Default: 2.2")

float volMultiplierInput = input.float(1.4, "Volume Spike Multiplier", minval=1.0, maxval=3.0, step=0.1,
     group=GROUP_SENS,
     tooltip="Volume must be this multiple of average to count as climax. Higher = stricter. Default: 1.4")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DISPLAY
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string GROUP_DISPLAY = "ğŸ¨ Display"

string signalStyle = input.string("Labels", "Signal Style", 
     options=["Labels", "Triangles", "Both"], 
     group=GROUP_DISPLAY,
     tooltip="LABELS = Show L1/L2/L3 or S1/S2/S3 text\nTRIANGLES = Simple arrows\nBOTH = Labels and triangles")

bool showConfidenceColors = input.bool(true, "Color by Confidence", group=GROUP_DISPLAY,
     tooltip="Use different color shades for L3/L2/L1 signal quality levels")

bool showSetupMarkers = input.bool(false, "Show Setup Detection", group=GROUP_DISPLAY,
     tooltip="Shows small circles where exhaustion pattern is first detected (before confirmation)")

bool debugMode = input.bool(false, "Debug Panel", group=GROUP_DISPLAY,
     tooltip="Shows detailed scoring breakdown and all detection conditions in a table")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ADVANCED (Optional Fine-Tuning)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string GROUP_ADV = "âš™ï¸ Advanced"

int velocityPeriodInput = input.int(5, "Velocity Lookback", minval=2, maxval=20,
     group=GROUP_ADV,
     tooltip="Bars to measure price acceleration. Lower = more reactive, higher = smoother. Default: 5")

int atrPeriodInput = input.int(14, "ATR Period", minval=5, maxval=50,
     group=GROUP_ADV,
     tooltip="Period for ATR calculation used in all volatility-based thresholds. Default: 14")

float minWickRatioInput = input.float(1.5, "Min Wick Ratio", minval=0.5, maxval=3.0, step=0.1,
     group=GROUP_ADV,
     tooltip="Wick must be this multiple of body size for hammer/shooting star patterns. Default: 1.5")

float minCandleSizeInput = input.float(0.7, "Min Candle Size (ATR)", minval=0.3, maxval=2.0, step=0.1,
     group=GROUP_ADV,
     tooltip="Minimum candle range in ATR units for valid reversal pattern. Default: 0.7")

int priceExtremeLookbackInput = input.int(40, "Price Extreme Lookback", minval=10, maxval=200,
     group=GROUP_ADV,
     tooltip="Bars to look back for determining if price is at a significant high/low. Default: 40")

int sweepLookbackInput = input.int(20, "Sweep Lookback", minval=5, maxval=100,
     group=GROUP_ADV,
     tooltip="Bars to look back for sweep confirmation (when enabled). Default: 20")

int maxWaitBarsInput = input.int(20, "Max Wait for Confirmation", minval=5, maxval=100,
     group=GROUP_ADV,
     tooltip="Maximum bars to wait for break/retest confirmation before setup expires. Default: 20")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTERNAL TUNING (Exposed for Power Users)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string GROUP_INT = "ğŸ› ï¸ Internal Tuning"

// ROC (Rate of Change) parameters
int rocPeriodInput = input.int(8, "ROC Period", minval=1, group=GROUP_INT, tooltip="Period for Rate of Change calculation.")
float rocExtremeInput = input.float(80.0, "ROC Extreme %", minval=50.0, maxval=99.9, group=GROUP_INT, tooltip="Percentile threshold for extreme momentum.")
int rocLookbackInput = input.int(120, "ROC Percentile Lookback", minval=50, group=GROUP_INT, tooltip="Lookback window for calculating ROC percentile.")
bool requireRocExtreme = input.bool(false, "Require ROC Extreme", group=GROUP_INT, tooltip="If true, signal only fires if ROC is also at an extreme.")

// Volume parameters  
int volPeriodInput = input.int(20, "Volume MA Period", minval=5, group=GROUP_INT)

// Tolerance parameters
float extremeTolAtrInput = input.float(0.6, "Extreme Tolerance (ATR)", step=0.1, group=GROUP_INT, tooltip="Distance from High/Low to be considered 'At Extreme'.")
float retestTolAtrInput = input.float(0.25, "Retest Tolerance (ATR)", step=0.05, group=GROUP_INT, tooltip="Allowed deviation for retest entries.")

// Structure parameters
bool requireNoNewExtreme = input.bool(true, "Structure Integrity", group=GROUP_INT, tooltip="If true, pattern is invalid if price makes a new extreme before confirmation.")
int pivotLeft = input.int(3, "Pivot Left Bars", minval=1, group=GROUP_INT)
int pivotRight = input.int(3, "Pivot Right Bars", minval=1, group=GROUP_INT)
bool bosUsePivots = input.bool(true, "Use Swing Points for BOS", group=GROUP_INT, tooltip="Use Pivot Points for Break of Structure levels (more precise) instead of just candle highs/lows.")
float maxBosLevelDistAtrInput = input.float(6.0, "Max BOS Distance (ATR)", step=0.5, group=GROUP_INT, tooltip="Max distance to look back for a relevant swing point.")

// Adaptive regime timeframe - always use a higher TF for trend context
string regimeTf = 
     tfMinutes <= 5 ? "60" :       // 1-5m charts use 1H for regime
     tfMinutes <= 15 ? "60" :      // 15m uses 1H
     tfMinutes <= 30 ? "240" :     // 30m uses 4H
     tfMinutes <= 60 ? "240" :     // 1H uses 4H
     tfMinutes <= 240 ? "D" :      // 4H uses Daily
     tfMinutes <= 1440 ? "W" :     // Daily uses Weekly
     "M"                            // Weekly+ uses Monthly

// Regime filter parameters
int regimeEmaLen = input.int(200, "Regime EMA Length", group=GROUP_INT)
int regimeSlopeLookback = 20
int regimeAtrLen = 14
float maxRegimeSlopeAtr = 1.0

// Auto-adjusted values with smart scaling
// Velocity period - how many bars to measure price acceleration
int velocityPeriod = autoAdaptive ? int(math.max(2, math.round(velocityPeriodInput * math.pow(tfMultiplier, 0.7)))) : velocityPeriodInput

// Velocity threshold - lower TFs need higher thresholds to filter noise
float velocityThreshold = autoAdaptive ? velocityThresholdInput * thresholdMultiplier : velocityThresholdInput

// ATR period - scales with timeframe but caps reasonably
int atrPeriod = autoAdaptive ? int(math.max(5, math.min(50, math.round(atrPeriodInput * math.pow(tfMultiplier, 0.6))))) : atrPeriodInput

// Candle pattern requirements - use candle multiplier
float minWickRatio = autoAdaptive ? minWickRatioInput * candleMultiplier : minWickRatioInput
float minCandleSize = autoAdaptive ? minCandleSizeInput * candleMultiplier : minCandleSizeInput

// ROC period and lookback - momentum measurement
int rocPeriod = autoAdaptive ? int(math.max(3, math.min(30, math.round(rocPeriodInput * math.pow(tfMultiplier, 0.6))))) : rocPeriodInput
int rocLookback = autoAdaptive ? int(math.max(50, math.min(500, math.round(rocLookbackInput * math.pow(tfMultiplier, 0.8))))) : rocLookbackInput

// ROC extreme percentile - stricter on lower TFs
float rocExtreme = autoAdaptive ? math.min(95.0, math.max(70.0, rocExtremeInput + (tfMinutes < 15 ? (15 - tfMinutes) * 0.8 : (tfMinutes > 60 ? -5 : 0)))) : rocExtremeInput

// Volume requirements - use volume multiplier
float volMultiplier = autoAdaptive ? volMultiplierInput * volumeMultiplier : volMultiplierInput
int volPeriod = autoAdaptive ? int(math.max(10, math.min(100, math.round(volPeriodInput * math.pow(tfMultiplier, 0.7))))) : volPeriodInput

// Cooldown between signals - scales with TF
int cooldownBars = autoAdaptive ? int(math.max(3, math.min(50, math.round(cooldownBarsInput * math.pow(tfMultiplier, 0.5))))) : cooldownBarsInput

// Minimum price move requirement - less strict on higher TFs
float minPriceMove = autoAdaptive ? minPriceMoveInput * thresholdMultiplier : minPriceMoveInput

// Price extreme lookback - how far back to check for highs/lows
int priceExtremeLookback = autoAdaptive ? int(math.max(15, math.min(200, math.round(priceExtremeLookbackInput * math.pow(tfMultiplier, 0.75))))) : priceExtremeLookbackInput

// Sweep lookback for structure confirmation
int sweepLookback = autoAdaptive ? int(math.max(8, math.min(100, math.round(sweepLookbackInput * math.pow(tfMultiplier, 0.7))))) : sweepLookbackInput

// Tolerance levels - inverse relationship with threshold
float retestTolAtr = autoAdaptive ? retestTolAtrInput / thresholdMultiplier : retestTolAtrInput
float extremeTolAtr = autoAdaptive ? extremeTolAtrInput / thresholdMultiplier : extremeTolAtrInput
float maxBosLevelDistAtr = autoAdaptive ? maxBosLevelDistAtrInput / thresholdMultiplier : maxBosLevelDistAtrInput

// Max wait bars - inversely proportional to TF (lower TF = more bars to wait)
float waitMultiplier = tfMinutes > 0 ? math.max(0.1, 15.0 / tfMinutes) : 1.0
int maxWaitBars = autoAdaptive ? int(math.min(500, math.max(5, math.round(maxWaitBarsInput * math.pow(waitMultiplier, 0.8))))) : maxWaitBarsInput

// Pivot lookback for swing detection - scales with TF
int pivotLeftAdj = autoAdaptive ? int(math.max(2, math.min(10, math.round(pivotLeft * math.pow(tfMultiplier, 0.4))))) : pivotLeft
int pivotRightAdj = autoAdaptive ? int(math.max(2, math.min(10, math.round(pivotRight * math.pow(tfMultiplier, 0.4))))) : pivotRight

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 1. PRICE VELOCITY (Parabolic Acceleration Detection)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float atr = ta.atr(atrPeriod)
bool atrValid = not na(atr) and atr > 0  // Cache ATR validity check

// Calculate price velocity over short period
float priceChange = close - close[velocityPeriod]
float priceVelocity = atrValid ? math.abs(priceChange) / atr : 0

// Detect parabolic upward/downward acceleration
bool parabolicUp = priceChange > 0 and priceVelocity >= velocityThreshold
bool parabolicDown = priceChange < 0 and priceVelocity >= velocityThreshold

// Check if we've moved far enough to have a reversal
int velocityPeriod2 = velocityPeriod * 2
float priceRange = math.abs(close - close[velocityPeriod2])
bool sufficientMove = atrValid and priceRange >= minPriceMove * atr

// Pre-calculate ATR-based thresholds (used multiple times)
float minCandleSizeAtr = minCandleSize * atr
float extremeTolAtrVal = extremeTolAtr * atr

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 2. REVERSAL CANDLE PATTERNS (Real-time)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float bodySize = math.abs(close - open)
float upperWick = high - math.max(close, open)
float lowerWick = math.min(close, open) - low
float candleRange = high - low

bool isBullishCandle = close > open
bool isBearishCandle = close < open

// Previous candle direction (needed for engulfing validation)
bool prevWasBullish = close[1] > open[1]
bool prevWasBearish = close[1] < open[1]

// Bearish reversal patterns (at tops)
// Shooting star: small body at bottom, long upper wick (wick >= body * ratio)
bool shootingStar = isBearishCandle and upperWick >= bodySize * minWickRatio and lowerWick < bodySize * 0.5 and candleRange >= minCandleSizeAtr
// Bearish engulfing: current bearish body engulfs previous bullish body
bool bearishEngulfing = isBearishCandle and prevWasBullish and bodySize >= minCandleSizeAtr and close < open[1] and open > close[1]
// Long upper wick: significant rejection from highs
bool longUpperWick = upperWick >= lowerWick * 2 and upperWick >= bodySize and candleRange >= minCandleSizeAtr

bool bearishReversalCandle = shootingStar or bearishEngulfing or longUpperWick

// Bullish reversal patterns (at bottoms)
// Hammer: small body at top, long lower wick
bool hammer = isBullishCandle and lowerWick >= bodySize * minWickRatio and upperWick < bodySize * 0.5 and candleRange >= minCandleSizeAtr
// Bullish engulfing: current bullish body engulfs previous bearish body
bool bullishEngulfing = isBullishCandle and prevWasBearish and bodySize >= minCandleSizeAtr and close > open[1] and open < close[1]
// Long lower wick: significant rejection from lows
bool longLowerWick = lowerWick >= upperWick * 2 and lowerWick >= bodySize and candleRange >= minCandleSizeAtr

bool bullishReversalCandle = hammer or bullishEngulfing or longLowerWick

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 3. ROC EXTREME (Momentum at extreme levels)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float roc = close[rocPeriod] != 0 ? 100 * (close - close[rocPeriod]) / close[rocPeriod] : 0
float rocPercentile = ta.percentrank(roc, rocLookback)

bool rocExtremeBullish = rocPercentile <= (100 - rocExtreme)  // Bottom percentile (oversold)
bool rocExtremeBearish = rocPercentile >= rocExtreme           // Top percentile (overbought)

bool rocGateLong = not requireRocExtreme or rocExtremeBullish
bool rocGateShort = not requireRocExtreme or rocExtremeBearish

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 4. VOLUME CLIMAX
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float volMa = ta.sma(volume, volPeriod)
float volMaShort = ta.sma(volume, 3)
bool volumeClimax = volume >= volMa * volMultiplier

// Volume declining after spike (exhaustion pattern) - improved logic
bool volExhaustionStrong = (volume[1] >= volMa[1] * volMultiplier or volume[2] >= volMa[2] * volMultiplier) and volume < volMaShort[1]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 5. MOMENTUM DECELERATION (Price slowing down)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Check if velocity is decreasing (deceleration)
float prevVelocity = atr[1] > 0 ? math.abs(close[1] - close[1 + velocityPeriod]) / atr[1] : 0
bool velocityDecreasing = priceVelocity < prevVelocity

// Check if we're at a significant price extreme
float priceHigh = ta.highest(high, priceExtremeLookback)
float priceLow = ta.lowest(low, priceExtremeLookback)
bool nearHighExtreme = atrValid and high >= (priceHigh - extremeTolAtrVal)
bool nearLowExtreme = atrValid and low <= (priceLow + extremeTolAtrVal)

// Structure confirmation: sweep a recent extreme and close back inside.
float sweepHigh = ta.highest(high, sweepLookback)[1]
float sweepLow = ta.lowest(low, sweepLookback)[1]
bool sweepShort = not na(sweepHigh) and high > sweepHigh and close < sweepHigh
bool sweepLong = not na(sweepLow) and low < sweepLow and close > sweepLow
bool spikeConfirmLongOk = confirmationMode == "Off" or sweepLong
bool spikeConfirmShortOk = confirmationMode == "Off" or sweepShort
// Note: "Require Sweep" mode uses sweepLong/sweepShort conditions

// Request higher timeframe data for regime filter
// Use [1] offset to avoid repainting on realtime bars
[regimeEma, regimeEmaPrev, regimeAtr] = request.security(syminfo.tickerid, regimeTf,
     [ta.ema(close, regimeEmaLen)[1], ta.ema(close, regimeEmaLen)[1 + regimeSlopeLookback], ta.atr(regimeAtrLen)[1]],
     gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

// Calculate regime slope normalized by ATR
float regimeSlopeSignedAtr = (not na(regimeAtr) and regimeAtr > 0) ? (regimeEma - regimeEmaPrev) / regimeAtr : na

bool regimeOkLong = not useRegimeFilter or na(regimeSlopeSignedAtr) or regimeSlopeSignedAtr >= -maxRegimeSlopeAtr
bool regimeOkShort = not useRegimeFilter or na(regimeSlopeSignedAtr) or regimeSlopeSignedAtr <= maxRegimeSlopeAtr

// Volatility filter - check if we're in an active market (adaptive lookback)
int volFilterLookback = autoAdaptive ? int(math.max(20, math.min(200, math.round(50 * math.pow(tfMultiplier, 0.6))))) : 50
float atrSma = ta.sma(atr, volFilterLookback)
float atrRatio = atrSma > 0 ? atr / atrSma : 0  // Current ATR vs long-term average
// Higher TFs need less volatility threshold as moves are more meaningful
float volThreshold = autoAdaptive ? (tfMinutes <= 15 ? 0.7 : tfMinutes <= 60 ? 0.6 : 0.5) : 0.7
bool volatilityOk = not useVolatilityFilter or atrRatio >= volThreshold

float ph = ta.pivothigh(high, pivotLeftAdj, pivotRightAdj)
float pl = ta.pivotlow(low, pivotLeftAdj, pivotRightAdj)
var float lastSwingHigh = na
var float lastSwingLow = na
if not na(ph)
    lastSwingHigh := ph
if not na(pl)
    lastSwingLow := pl

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 6. COMPOSITE SIGNAL GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// LONG Signal: After parabolic down move, see reversal signs
int longScore = 0
bool longHasVelocity = parabolicDown and sufficientMove
bool longHasCandle = bullishReversalCandle

if longHasVelocity
    longScore += 2  // Strong weight for velocity
if longHasCandle
    longScore += 2  // Strong weight for reversal candle
if longHasVelocity and longHasCandle
    longScore += 1  // Bonus for having BOTH core conditions
if rocExtremeBullish
    longScore += 1
if volumeClimax or volExhaustionStrong
    longScore += 1
if velocityDecreasing
    longScore += 1
if nearLowExtreme
    longScore += 1  // Bonus point for being at price extreme

// SHORT Signal: After parabolic up move, see reversal signs  
int shortScore = 0
bool shortHasVelocity = parabolicUp and sufficientMove
bool shortHasCandle = bearishReversalCandle

if shortHasVelocity
    shortScore += 2  // Strong weight for velocity
if shortHasCandle
    shortScore += 2  // Strong weight for reversal candle
if shortHasVelocity and shortHasCandle
    shortScore += 1  // Bonus for having BOTH core conditions
if rocExtremeBearish
    shortScore += 1
if volumeClimax or volExhaustionStrong
    shortScore += 1
if velocityDecreasing
    shortScore += 1
if nearHighExtreme
    shortScore += 1  // Bonus point for being at price extreme

// CONFIDENCE LEVEL SYSTEM (Multi-TF Adaptive)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// L3/S3 = Highest confidence (5+ points on lower TFs, 4+ on higher TFs)
// L2/S2 = Medium confidence 
// L1/S1 = Lower confidence - aggressive only
//
// Higher timeframes get slightly lower thresholds because their signals are more reliable

// Base score requirements - adjusted by timeframe
int baseL3Score = autoAdaptive ? (tfMinutes >= 240 ? 4 : 5) : 5
int baseL2Score = autoAdaptive ? (tfMinutes >= 240 ? 3 : 4) : 4
int baseL1Score = autoAdaptive ? (tfMinutes >= 240 ? 2 : 3) : 3

int minScoreRequired = minConfidenceLevel == "High Only (L3/S3)" ? baseL3Score : 
     minConfidenceLevel == "Medium (L2/S2)" ? baseL2Score : baseL1Score

// Determine confidence levels with adaptive thresholds
int longConfidence = longScore >= baseL3Score ? 3 : longScore >= baseL2Score ? 2 : longScore >= baseL1Score ? 1 : 0
int shortConfidence = shortScore >= baseL3Score ? 3 : shortScore >= baseL2Score ? 2 : shortScore >= baseL1Score ? 1 : 0

// Core requirements check
bool longCoreOk = not requireBothCore or (longHasVelocity and longHasCandle)
bool shortCoreOk = not requireBothCore or (shortHasVelocity and shortHasCandle)

bool longSetupRaw = longScore >= minScoreRequired and longCoreOk and rocGateLong and volatilityOk and longConfidence > 0 and spikeConfirmLongOk
bool shortSetupRaw = shortScore >= minScoreRequired and shortCoreOk and rocGateShort and volatilityOk and shortConfidence > 0 and spikeConfirmShortOk

bool longSetupMarker = longSetupRaw and barstate.isconfirmed
bool shortSetupMarker = shortSetupRaw and barstate.isconfirmed

var int setupLongBar = na
var float setupLongHigh = na
var float setupLongLow = na
var float setupLongBosLevel = na
var int setupLongScore = na
var int setupLongConfidence = na
var bool setupLongBos = false

var int setupShortBar = na
var float setupShortHigh = na
var float setupShortLow = na
var float setupShortBosLevel = na
var int setupShortScore = na
var int setupShortConfidence = na
var bool setupShortBos = false

if not na(setupLongBar) and (bar_index - setupLongBar) > maxWaitBars
    setupLongBar := na
    setupLongHigh := na
    setupLongLow := na
    setupLongBosLevel := na
    setupLongScore := na
    setupLongConfidence := na
    setupLongBos := false

if not na(setupShortBar) and (bar_index - setupShortBar) > maxWaitBars
    setupShortBar := na
    setupShortHigh := na
    setupShortLow := na
    setupShortBosLevel := na
    setupShortScore := na
    setupShortConfidence := na
    setupShortBos := false

// Pre-calculate max BOS level distance
float maxBosDistVal = maxBosLevelDistAtr * atr

if longSetupMarker
    setupLongBar := bar_index
    setupLongHigh := high
    setupLongLow := low
    setupLongBosLevel := (bosUsePivots and not na(lastSwingHigh) and atrValid and lastSwingHigh > close and (lastSwingHigh - close) <= maxBosDistVal) ? lastSwingHigh : na
    setupLongScore := longScore
    setupLongConfidence := longConfidence
    setupLongBos := false

if shortSetupMarker
    setupShortBar := bar_index
    setupShortHigh := high
    setupShortLow := low
    setupShortBosLevel := (bosUsePivots and not na(lastSwingLow) and atrValid and lastSwingLow < close and (close - lastSwingLow) <= maxBosDistVal) ? lastSwingLow : na
    setupShortScore := shortScore
    setupShortConfidence := shortConfidence
    setupShortBos := false

bool longSignalRaw = false
bool shortSignalRaw = false

if entryModel == "Immediate"
    longSignalRaw := longSetupMarker and regimeOkLong
    shortSignalRaw := shortSetupMarker and regimeOkShort
else
    bool longSetupActive = not na(setupLongBar)
    bool shortSetupActive = not na(setupShortBar)

    float longBosLevel = not na(setupLongBosLevel) ? setupLongBosLevel : setupLongHigh
    float shortBosLevel = not na(setupShortBosLevel) ? setupShortBosLevel : setupShortLow

    bool longBos = longSetupActive and barstate.isconfirmed and close > longBosLevel and (not requireNoNewExtreme or low >= setupLongLow)
    bool shortBos = shortSetupActive and barstate.isconfirmed and close < shortBosLevel and (not requireNoNewExtreme or high <= setupShortHigh)

    if longBos
        setupLongBos := true
    if shortBos
        setupShortBos := true

    if entryModel == "Break Confirmed"
        longSignalRaw := longBos and regimeOkLong
        shortSignalRaw := shortBos and regimeOkShort
    else  // "Break + Retest"
        bool longRetest = setupLongBos and barstate.isconfirmed and low <= longBosLevel + (retestTolAtr * atr) and close > longBosLevel and close > open and (not requireNoNewExtreme or low >= setupLongLow)
        bool shortRetest = setupShortBos and barstate.isconfirmed and high >= shortBosLevel - (retestTolAtr * atr) and close < shortBosLevel and close < open and (not requireNoNewExtreme or high <= setupShortHigh)

        longSignalRaw := longRetest and regimeOkLong
        shortSignalRaw := shortRetest and regimeOkShort

// Retrieve stored score/confidence for BOS modes, with null safety fallback to current values
int longScoreUsed = (longSignalRaw and entryModel != "Immediate" and not na(setupLongScore)) ? setupLongScore : longScore
int shortScoreUsed = (shortSignalRaw and entryModel != "Immediate" and not na(setupShortScore)) ? setupShortScore : shortScore
int longConfidenceUsed = (longSignalRaw and entryModel != "Immediate" and not na(setupLongConfidence)) ? setupLongConfidence : longConfidence
int shortConfidenceUsed = (shortSignalRaw and entryModel != "Immediate" and not na(setupShortConfidence)) ? setupShortConfidence : shortConfidence

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 7. FILTERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var int lastSignalBar = na
bool cooldownOk = cooldownBars == 0 or na(lastSignalBar) or (bar_index - lastSignalBar) > cooldownBars

// Conflict resolution: if both signals fire simultaneously, use higher score
// If equal scores, prefer the signal matching price position (at high = short, at low = long)
bool bothRaw = longSignalRaw and shortSignalRaw
bool equalScores = longScoreUsed == shortScoreUsed
bool preferLongOnTie = nearLowExtreme and not nearHighExtreme
bool preferShortOnTie = nearHighExtreme and not nearLowExtreme
bool longSignal = longSignalRaw and cooldownOk and (not bothRaw or longScoreUsed > shortScoreUsed or (equalScores and preferLongOnTie))
bool shortSignal = shortSignalRaw and cooldownOk and (not bothRaw or shortScoreUsed > longScoreUsed or (equalScores and preferShortOnTie))

if longSignal or shortSignal
    lastSignalBar := bar_index

if longSignal
    setupLongBar := na
    setupLongHigh := na
    setupLongLow := na
    setupLongBosLevel := na
    setupLongScore := na
    setupLongConfidence := na
    setupLongBos := false

if shortSignal
    setupShortBar := na
    setupShortHigh := na
    setupShortLow := na
    setupShortBosLevel := na
    setupShortScore := na
    setupShortConfidence := na
    setupShortBos := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VISUAL SIGNALS WITH CONFIDENCE LEVELS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool showTriangles = signalStyle == "Triangles" or signalStyle == "Both"
bool showLabels = signalStyle == "Labels" or signalStyle == "Both"

// Confidence-based colors
color longColorBase = #00A855
color longColorL3 = longColorBase
color longColorL2 = showConfidenceColors ? #008544 : longColorBase
color longColorL1 = showConfidenceColors ? #006633 : longColorBase

color shortColorBase = #CC0000
color shortColorS3 = shortColorBase
color shortColorS2 = showConfidenceColors ? #AA0000 : shortColorBase
color shortColorS1 = showConfidenceColors ? #880000 : shortColorBase

plotshape(showSetupMarkers and longSetupMarker, title="LONG Setup", style=shape.circle, location=location.belowbar,
     color=color.new(longColorBase, 75), size=size.tiny)
plotshape(showSetupMarkers and shortSetupMarker, title="SHORT Setup", style=shape.circle, location=location.abovebar,
     color=color.new(shortColorBase, 75), size=size.tiny)

// Text colors (readable on dark backgrounds)
color longTextColor = color.new(#FFFFFF, 0)   // White on dark green
color shortTextColor = color.new(#FFFFFF, 0)  // White on dark red

// Determine which confidence level triggered
bool longL3 = longSignal and longConfidenceUsed == 3
bool longL2 = longSignal and longConfidenceUsed == 2
bool longL1 = longSignal and longConfidenceUsed == 1

bool shortS3 = shortSignal and shortConfidenceUsed == 3
bool shortS2 = shortSignal and shortConfidenceUsed == 2
bool shortS1 = shortSignal and shortConfidenceUsed == 1

// Triangles with confidence colors
plotshape(showTriangles and longL3, title="L3 â–²", style=shape.triangleup, location=location.belowbar,
     color=color.new(longColorL3, 0), size=size.small)
plotshape(showTriangles and longL2, title="L2 â–²", style=shape.triangleup, location=location.belowbar,
     color=color.new(longColorL2, 0), size=size.small)
plotshape(showTriangles and longL1, title="L1 â–²", style=shape.triangleup, location=location.belowbar,
     color=color.new(longColorL1, 0), size=size.small)

plotshape(showTriangles and shortS3, title="S3 â–¼", style=shape.triangledown, location=location.abovebar,
     color=color.new(shortColorS3, 0), size=size.small)
plotshape(showTriangles and shortS2, title="S2 â–¼", style=shape.triangledown, location=location.abovebar,
     color=color.new(shortColorS2, 0), size=size.small)
plotshape(showTriangles and shortS1, title="S1 â–¼", style=shape.triangledown, location=location.abovebar,
     color=color.new(shortColorS1, 0), size=size.small)

// Confidence-based text labels
if showLabels
    if longSignal
        color longLabelColor = longConfidenceUsed == 3 ? longColorL3 : longConfidenceUsed == 2 ? longColorL2 : longColorL1
        label.new(bar_index, low, text="L" + str.tostring(longConfidenceUsed), style=label.style_label_up,
             color=longLabelColor, textcolor=longTextColor, size=size.small)
    if shortSignal
        color shortLabelColor = shortConfidenceUsed == 3 ? shortColorS3 : shortConfidenceUsed == 2 ? shortColorS2 : shortColorS1
        label.new(bar_index, high, text="S" + str.tostring(shortConfidenceUsed), style=label.style_label_down,
             color=shortLabelColor, textcolor=shortTextColor, size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DEBUG TABLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var table debugTable = table.new(position.top_right, 3, 24, border_width=1)

if debugMode and barstate.islast
    table.cell(debugTable, 0, 0, "Condition", text_color=color.white, bgcolor=color.gray)
    table.cell(debugTable, 1, 0, "Bullish", text_color=color.white, bgcolor=color.gray)
    table.cell(debugTable, 2, 0, "Bearish", text_color=color.white, bgcolor=color.gray)
    
    table.cell(debugTable, 0, 1, "Parabolic Move", text_color=color.white)
    table.cell(debugTable, 1, 1, parabolicDown ? "âœ“ (2pts)" : "âœ—", text_color=parabolicDown ? color.lime : color.red)
    table.cell(debugTable, 2, 1, parabolicUp ? "âœ“ (2pts)" : "âœ—", text_color=parabolicUp ? color.lime : color.red)
    
    table.cell(debugTable, 0, 2, "Reversal Candle", text_color=color.white)
    table.cell(debugTable, 1, 2, bullishReversalCandle ? "âœ“ (2pts)" : "âœ—", text_color=bullishReversalCandle ? color.lime : color.red)
    table.cell(debugTable, 2, 2, bearishReversalCandle ? "âœ“ (2pts)" : "âœ—", text_color=bearishReversalCandle ? color.lime : color.red)
    
    table.cell(debugTable, 0, 3, "ROC Extreme", text_color=color.white)
    table.cell(debugTable, 1, 3, rocExtremeBullish ? "âœ“ (1pt)" : "âœ—", text_color=rocExtremeBullish ? color.lime : color.red)
    table.cell(debugTable, 2, 3, rocExtremeBearish ? "âœ“ (1pt)" : "âœ—", text_color=rocExtremeBearish ? color.lime : color.red)
    
    table.cell(debugTable, 0, 4, "Volume Climax", text_color=color.white)
    table.cell(debugTable, 1, 4, volumeClimax ? "âœ“ (1pt)" : "âœ—", text_color=volumeClimax ? color.lime : color.red)
    table.cell(debugTable, 2, 4, volumeClimax ? "âœ“ (1pt)" : "âœ—", text_color=volumeClimax ? color.lime : color.red)
    
    table.cell(debugTable, 0, 5, "Deceleration", text_color=color.white)
    table.cell(debugTable, 1, 5, velocityDecreasing ? "âœ“ (1pt)" : "âœ—", text_color=velocityDecreasing ? color.lime : color.red)
    table.cell(debugTable, 2, 5, velocityDecreasing ? "âœ“ (1pt)" : "âœ—", text_color=velocityDecreasing ? color.lime : color.red)
    
    table.cell(debugTable, 0, 6, "Price Extreme", text_color=color.white)
    table.cell(debugTable, 1, 6, nearLowExtreme ? "âœ“ (1pt)" : "âœ—", text_color=nearLowExtreme ? color.lime : color.red)
    table.cell(debugTable, 2, 6, nearHighExtreme ? "âœ“ (1pt)" : "âœ—", text_color=nearHighExtreme ? color.lime : color.red)
    
    table.cell(debugTable, 0, 7, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray)
    table.cell(debugTable, 1, 7, "â”€â”€â”€â”€â”€", text_color=color.gray)
    table.cell(debugTable, 2, 7, "â”€â”€â”€â”€â”€", text_color=color.gray)
    
    table.cell(debugTable, 0, 8, "SCORE / Required", text_color=color.white)
    table.cell(debugTable, 1, 8, str.tostring(longScore) + " / " + str.tostring(minScoreRequired), text_color=longScore >= minScoreRequired ? color.lime : color.orange)
    table.cell(debugTable, 2, 8, str.tostring(shortScore) + " / " + str.tostring(minScoreRequired), text_color=shortScore >= minScoreRequired ? color.lime : color.orange)
    
    table.cell(debugTable, 0, 9, "Core (Vel+Candle)", text_color=color.white)
    table.cell(debugTable, 1, 9, longCoreOk ? "âœ“" : "âœ— BLOCKING", text_color=longCoreOk ? color.lime : color.red)
    table.cell(debugTable, 2, 9, shortCoreOk ? "âœ“" : "âœ— BLOCKING", text_color=shortCoreOk ? color.lime : color.red)
    
    table.cell(debugTable, 0, 10, "Cooldown", text_color=color.white)
    table.cell(debugTable, 1, 10, cooldownOk ? "âœ“" : "âœ— BLOCKING", text_color=cooldownOk ? color.lime : color.red)
    table.cell(debugTable, 2, 10, cooldownOk ? "âœ“" : "âœ— BLOCKING", text_color=cooldownOk ? color.lime : color.red)
    
    table.cell(debugTable, 0, 11, "Volatility Filter", text_color=color.white)
    table.cell(debugTable, 1, 11, volatilityOk ? "âœ“" : "âœ— BLOCKING", text_color=volatilityOk ? color.lime : color.red)
    table.cell(debugTable, 2, 11, volatilityOk ? "âœ“" : "âœ— BLOCKING", text_color=volatilityOk ? color.lime : color.red)
    
    table.cell(debugTable, 0, 12, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray)
    table.cell(debugTable, 1, 12, "â”€â”€â”€â”€â”€", text_color=color.gray)
    table.cell(debugTable, 2, 12, "â”€â”€â”€â”€â”€", text_color=color.gray)
    
    table.cell(debugTable, 0, 13, "CONFIDENCE LEVEL", text_color=color.white, bgcolor=color.navy)
    string longText = longL3 ? "ğŸš€ L3" : longL2 ? "ğŸš€ L2" : longL1 ? "ğŸš€ L1" : "â€”"
    string shortText = shortS3 ? "ğŸ”» S3" : shortS2 ? "ğŸ”» S2" : shortS1 ? "ğŸ”» S1" : "â€”"
    table.cell(debugTable, 1, 13, longText, text_color=color.white, bgcolor=longSignal ? color.green : color.navy)
    table.cell(debugTable, 2, 13, shortText, text_color=color.white, bgcolor=shortSignal ? color.red : color.navy)
    
    table.cell(debugTable, 0, 14, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray)
    table.cell(debugTable, 1, 14, "â”€â”€â”€â”€â”€", text_color=color.gray)
    table.cell(debugTable, 2, 14, "â”€â”€â”€â”€â”€", text_color=color.gray)
    
    table.cell(debugTable, 0, 15, "Price Velocity", text_color=color.white)
    table.cell(debugTable, 1, 15, str.tostring(priceVelocity, "#.##") + "x ATR", text_color=color.orange)
    table.cell(debugTable, 2, 15, "", text_color=color.white)
    
    table.cell(debugTable, 0, 16, "ROC Percentile", text_color=color.white)
    table.cell(debugTable, 1, 16, str.tostring(rocPercentile, "#.##") + "%", text_color=color.orange)
    table.cell(debugTable, 2, 16, "", text_color=color.white)
    
    table.cell(debugTable, 0, 17, "Volume Ratio", text_color=color.white)
    table.cell(debugTable, 1, 17, volMa > 0 ? str.tostring(volume/volMa, "#.##") + "x" : "â€”", text_color=color.orange)
    table.cell(debugTable, 2, 17, "", text_color=color.white)
    
    table.cell(debugTable, 0, 18, "ATR Ratio", text_color=color.white)
    table.cell(debugTable, 1, 18, str.tostring(atrRatio, "#.##") + "x", text_color=color.orange)
    table.cell(debugTable, 2, 18, "", text_color=color.white)
    
    table.cell(debugTable, 0, 19, "Candle Type", text_color=color.white)
    string candleType = shootingStar ? "Shooting Star" : bearishEngulfing ? "Bear Engulf" : longUpperWick ? "Long U-Wick" : hammer ? "Hammer" : bullishEngulfing ? "Bull Engulf" : longLowerWick ? "Long L-Wick" : "Regular"
    table.cell(debugTable, 1, 19, candleType, text_color=color.orange)
    table.cell(debugTable, 2, 19, "", text_color=color.white)
    
    table.cell(debugTable, 0, 20, "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€", text_color=color.gray)
    table.cell(debugTable, 1, 20, "â”€â”€â”€â”€â”€", text_color=color.gray)
    table.cell(debugTable, 2, 20, "â”€â”€â”€â”€â”€", text_color=color.gray)
    
    table.cell(debugTable, 0, 21, "TF Category", text_color=color.white, bgcolor=color.teal)
    table.cell(debugTable, 1, 21, tfCategory, text_color=color.white, bgcolor=color.teal)
    table.cell(debugTable, 2, 21, str.tostring(tfMinutes) + "m", text_color=color.white, bgcolor=color.teal)
    
    table.cell(debugTable, 0, 22, "TF Multiplier", text_color=color.white)
    table.cell(debugTable, 1, 22, str.tostring(tfMultiplier, "#.##") + "x", text_color=color.aqua)
    table.cell(debugTable, 2, 22, "Thresh: " + str.tostring(thresholdMultiplier, "#.##"), text_color=color.aqua)
    
    table.cell(debugTable, 0, 23, "Velocity Period", text_color=color.white)
    table.cell(debugTable, 1, 23, str.tostring(velocityPeriod) + " bars", text_color=color.aqua)
    table.cell(debugTable, 2, 23, "ATR: " + str.tostring(atrPeriod), text_color=color.aqua)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

alertcondition(longL3, title="L3 - High Confidence Long", message="L3 (High Confidence): Parabolic bottom on {{ticker}} {{interval}}")
alertcondition(longL2, title="L2 - Medium Confidence Long", message="L2 (Medium Confidence): Parabolic bottom on {{ticker}} {{interval}}")
alertcondition(longL1, title="L1 - Low Confidence Long", message="L1 (Lower Confidence): Parabolic bottom on {{ticker}} {{interval}}")

alertcondition(shortS3, title="S3 - High Confidence Short", message="S3 (High Confidence): Parabolic top on {{ticker}} {{interval}}")
alertcondition(shortS2, title="S2 - Medium Confidence Short", message="S2 (Medium Confidence): Parabolic top on {{ticker}} {{interval}}")
alertcondition(shortS1, title="S1 - Low Confidence Short", message="S1 (Lower Confidence): Parabolic top on {{ticker}} {{interval}}")
