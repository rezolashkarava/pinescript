//@version=6
indicator("BTC Volume Analysis [Paganie]", overlay=true)

// ============================================================================
// BTC VOLUME ANALYSIS [PAGANIE] V2.0
// Multi-timeframe volume sentiment + intrabar buy/sell analysis
// Designed to complement ICT Order Block Pro [Paganie]
//
// V2.0 - Enhanced Volume Classification + Stability Features:
// â€¢ NEW: Buying/Selling Pressure method (more accurate than Polarity)
// â€¢ Neutral Band filter (reduces noise around 50%)
// â€¢ Flip Confirmation (prevents whipsaws)
// â€¢ Signal Timing modes (Realtime vs Confirmed)
// â€¢ Multiple Doji handling options
// ============================================================================

// === INPUTS ===

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// SYMBOL & SETTINGS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string G1 = "â‚¿ Symbol & Settings"
useCurrentChart = input.bool(false, "Use Current Chart", group=G1,
     tooltip="When enabled, analyzes the current chart symbol instead of the specified symbol below")
btcSymbol = input.string("BINANCE:BTCUSDT", "Symbol", group=G1,
     tooltip="Symbol to analyze volume (ignored when 'Use Current Chart' is enabled)\nExamples: BINANCE:BTCUSDT, COINBASE:BTCUSD, BYBIT:BTCUSDT.P")
avgVolumePeriod = input.int(10, "Average Volume Period", minval=1, maxval=100, group=G1,
     tooltip="Number of bars to calculate average volume")
signalTiming = input.string("Realtime (intrabar)", "Signal Timing", options=["Realtime (intrabar)", "Confirmed (bar close)"], group=G1,
     tooltip="REALTIME: Updates signals on every tick (faster but may flicker)\nCONFIRMED: Updates signals only on bar close (more stable, no repainting)")

// Determine effective symbol
string effectiveSymbol = useCurrentChart ? syminfo.tickerid : btcSymbol

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// TIMEFRAMES
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string G2 = "â±ï¸ Timeframes"
showTf1 = input.bool(true, "TF 1", inline="tf1", group=G2)
tf1 = input.timeframe("1", "", inline="tf1", group=G2)
showTf2 = input.bool(true, "TF 2", inline="tf2", group=G2)
tf2 = input.timeframe("5", "", inline="tf2", group=G2)
showTf3 = input.bool(true, "TF 3", inline="tf3", group=G2)
tf3 = input.timeframe("15", "", inline="tf3", group=G2)
showTf4 = input.bool(true, "TF 4", inline="tf4", group=G2)
tf4 = input.timeframe("30", "", inline="tf4", group=G2)

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// STYLE
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string G3 = "ðŸŽ¨ Style"
color bullishColor = input.color(color.new(#00ff88, 0), "Bullish", inline="colors", group=G3)
color bearishColor = input.color(color.new(#ff3366, 0), "Bearish", inline="colors", group=G3)
widgetPosition = input.string("Top Right", "Position", 
     options=["Top Right", "Top Left", "Bottom Right", "Bottom Left", "Middle Right", "Middle Left"], group=G3)
tableSize = input.string("normal", "Text Size", options=["tiny", "small", "normal", "large"], group=G3)
tableWidth = input.string("Normal", "Widget Width", options=["Compact", "Normal", "Wide", "Extra Wide"], group=G3,
     tooltip="Adjusts the horizontal size of the widget")
tableTransparency = input.int(10, "Table Transparency", minval=0, maxval=90, step=5, group=G3,
     tooltip="Overall transparency of the widget (0 = solid, 90 = very transparent)")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// DISPLAY OPTIONS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string G4 = "ðŸ“‹ Display Options"
showVolumeTable = input.bool(true, "Show Volume Table", group=G4)
showMtfSection = input.bool(true, "Show MTF Section", group=G4)
showCurrentVolSection = input.bool(true, "Show Current Volume Section", group=G4)
showNetFlow = input.bool(true, "Show Net Flow", group=G4)
showAvgSection = input.bool(true, "Show Average Section", group=G4)

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// INTRABAR SETTINGS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string G5 = "ðŸ“Š Intrabar Analysis"
volumeMethod = input.string("Pressure", "Volume Method", options=["Pressure", "Polarity"], group=G5,
     tooltip="PRESSURE: Uses (close-low)/(high-low) to assign proportional buy/sell volume within each candle's range. More accurate and nuanced.\nPOLARITY: Classic method - all volume goes to buy if close>open, sell if close<open. Binary classification.")
ltfMode = input.string("Auto", "LTF Mode", options=["Auto", "Manual"], group=G5,
     tooltip="Auto: Optimizes lower timeframe based on chart TF\nManual: Use your selected timeframe")
manualLtf = input.timeframe("1", "Manual Lower TF", group=G5,
     tooltip="Only used when LTF Mode is Manual")
dojiHandling = input.string("Carry last direction", "Doji Handling", 
     options=["Carry last direction", "Use prev intrabar close", "Ignore dojis"], group=G5, 
     tooltip="How to classify intrabar candles where close == open (only applies to Polarity method)\nâ€¢ Carry last: Use previous candle's direction\nâ€¢ Prev close: Compare to prior intrabar's close\nâ€¢ Ignore: Skip doji candles entirely")
smoothingLen = input.int(3, "Smoothing Length", minval=1, maxval=10, group=G5)
smoothingType = input.string("EMA", "Smoothing Type", options=["EMA", "SMA"], group=G5)
minIntrabars = input.int(4, "Min Intrabars", minval=1, maxval=20, group=G5,
     tooltip="Minimum intrabar candles required for confident reading\nBelow this, shows as low-confidence (grey)")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// STABILITY CONTROLS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string G6 = "ðŸ›¡ï¸ Stability Controls"
neutralBandPct = input.float(10.0, "Neutral Band %", minval=0.0, maxval=30.0, step=1.0, group=G6,
     tooltip="Creates a neutral zone around 50% dominance\nDefault 10% = neutral range [45%..55%]\nHigher = more NEUTRAL readings, less flipping")
flipConfirmBars = input.int(2, "Flip Confirm Bars", minval=0, maxval=10, group=G6,
     tooltip="Bars required to confirm side change\n0 = instant flip\nHigher = more stable but slower to react")

// === HELPER FUNCTIONS ===
formatVolume(float vol) =>
    string s = ""
    if na(vol) or vol == 0
        s := "0"
    else
        float k = vol / 1000.0
        float m = vol / 1000000.0
        if m >= 1.0 or k >= 999.5
            s := str.tostring(math.round(m * 100) / 100) + "M"
        else if k >= 1.0
            s := str.tostring(math.round(k * 10) / 10) + "k"
        else
            s := str.tostring(math.round(vol))
    s

formatTf(string tf) =>
    int tfMins = timeframe.in_seconds(tf) / 60
    string result = ""
    if tfMins < 60
        result := str.tostring(tfMins)
    else if tfMins < 1440
        result := str.tostring(tfMins / 60) + "H"
    else if tfMins == 1440
        result := "D"
    else if tfMins == 10080
        result := "W"
    else
        result := tf
    result

round2(float x) =>
    math.round(x * 100) / 100

getWidgetPosition(string loc) =>
    switch loc
        "Top Left" => position.top_left
        "Top Right" => position.top_right
        "Bottom Left" => position.bottom_left
        "Bottom Right" => position.bottom_right
        "Middle Left" => position.middle_left
        "Middle Right" => position.middle_right
        => position.top_right

getTextSize(string sz) =>
    switch sz
        "tiny" => size.tiny
        "small" => size.small
        "normal" => size.normal
        "large" => size.large
        => size.normal

// Padding for widget width
getPadding() =>
    switch tableWidth
        "Compact" => ""
        "Normal" => " "
        "Wide" => "  "
        "Extra Wide" => "    "
        => " "

padText(string txt) =>
    string pad = getPadding()
    pad + txt + pad

// === TIMEFRAME LOGIC FOR INTRABAR ===
tf_in_minutes = timeframe.in_seconds() / 60

getPowerLtf() =>
    string ltf = "1"
    if tf_in_minutes <= 5
        ltf := "1"
    else if tf_in_minutes <= 15
        ltf := "1"
    else if tf_in_minutes <= 60
        ltf := "5"
    else if tf_in_minutes <= 240
        ltf := "15"
    else if tf_in_minutes <= 1440
        ltf := "60"
    else
        ltf := "240"
    ltf

getAutoSmoothingLen() =>
    tf_in_minutes <= 5 ? 2 : tf_in_minutes <= 15 ? 3 : tf_in_minutes <= 60 ? 4 : 5

string effectiveLtf = ltfMode == "Auto" ? getPowerLtf() : manualLtf
int effectiveSmoothing = ltfMode == "Auto" ? getAutoSmoothingLen() : smoothingLen

int chartTfSec = timeframe.in_seconds()
int powerTfSec = timeframe.in_seconds(effectiveLtf)
string powerLtfSafe = powerTfSec <= chartTfSec ? effectiveLtf : timeframe.period

// === MULTI-TIMEFRAME VOLUME DATA ===
// TF1 data
[tf1Vol, tf1Open, tf1Close] = request.security(effectiveSymbol, tf1, [volume, open, close], lookahead=barmerge.lookahead_off)
float tf1AvgVol = request.security(effectiveSymbol, tf1, ta.sma(volume, avgVolumePeriod), lookahead=barmerge.lookahead_off)
bool tf1Bullish = tf1Close > tf1Open

// TF2 data
[tf2Vol, tf2Open, tf2Close] = request.security(effectiveSymbol, tf2, [volume, open, close], lookahead=barmerge.lookahead_off)
float tf2AvgVol = request.security(effectiveSymbol, tf2, ta.sma(volume, avgVolumePeriod), lookahead=barmerge.lookahead_off)
bool tf2Bullish = tf2Close > tf2Open

// TF3 data
[tf3Vol, tf3Open, tf3Close] = request.security(effectiveSymbol, tf3, [volume, open, close], lookahead=barmerge.lookahead_off)
float tf3AvgVol = request.security(effectiveSymbol, tf3, ta.sma(volume, avgVolumePeriod), lookahead=barmerge.lookahead_off)
bool tf3Bullish = tf3Close > tf3Open

// TF4 data
[tf4Vol, tf4Open, tf4Close] = request.security(effectiveSymbol, tf4, [volume, open, close], lookahead=barmerge.lookahead_off)
float tf4AvgVol = request.security(effectiveSymbol, tf4, ta.sma(volume, avgVolumePeriod), lookahead=barmerge.lookahead_off)
bool tf4Bullish = tf4Close > tf4Open

// === INTRABAR DATA FOR BUY/SELL ANALYSIS ===
arrOpen = request.security_lower_tf(effectiveSymbol, powerLtfSafe, open, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)
arrHigh = request.security_lower_tf(effectiveSymbol, powerLtfSafe, high, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)
arrLow = request.security_lower_tf(effectiveSymbol, powerLtfSafe, low, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)
arrClose = request.security_lower_tf(effectiveSymbol, powerLtfSafe, close, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)
arrVol = request.security_lower_tf(effectiveSymbol, powerLtfSafe, volume, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)

// Calculate buy/sell volume from intrabars
// Supports both Polarity (binary) and Pressure (proportional) methods
calcVolume(string method, string tieBreakRule) =>
    float buyVol = 0.0
    float sellVol = 0.0
    int sizeVol = array.size(arrVol)
    int sizeOpen = array.size(arrOpen)
    int sizeHigh = array.size(arrHigh)
    int sizeLow = array.size(arrLow)
    int sizeClose = array.size(arrClose)
    int intrabarCount = math.min(sizeVol, math.min(sizeOpen, math.min(sizeHigh, math.min(sizeLow, sizeClose))))
    int lastDir = 0
    
    if intrabarCount > 0
        float prevClose = na
        for i = 0 to intrabarCount - 1
            float o = array.get(arrOpen, i)
            float h = array.get(arrHigh, i)
            float l = array.get(arrLow, i)
            float c = array.get(arrClose, i)
            float v = array.get(arrVol, i)
            
            if method == "Pressure"
                // === BUYING/SELLING PRESSURE METHOD ===
                // Proportionally assigns volume based on where price closed within the range
                // (close - low) = buying pressure, (high - close) = selling pressure
                float candleRange = h - l
                if candleRange > 0
                    float buyRatio = (c - l) / candleRange
                    float sellRatio = (h - c) / candleRange
                    buyVol += v * buyRatio
                    sellVol += v * sellRatio
                else
                    // No range (h == l), use direction from open to close
                    if c > o
                        buyVol += v
                    else if c < o
                        sellVol += v
                    else
                        // True doji - split evenly
                        buyVol += v * 0.5
                        sellVol += v * 0.5
            else
                // === POLARITY METHOD ===
                // Binary classification: all volume goes to buy or sell
                int dir = 0
                if c > o
                    dir := 1   // Bullish intrabar
                else if c < o
                    dir := -1  // Bearish intrabar
                else
                    // Doji (close == open) - apply tie-break rule
                    if tieBreakRule == "Carry last direction"
                        dir := lastDir
                    else if tieBreakRule == "Use prev intrabar close"
                        if not na(prevClose)
                            dir := c > prevClose ? 1 : (c < prevClose ? -1 : 0)
                    // else "Ignore dojis" - dir stays 0, volume not counted
                
                // Accumulate volume by direction
                if dir == 1
                    buyVol += v
                else if dir == -1
                    sellVol += v
                
                // Update state for next iteration
                if dir != 0
                    lastDir := dir
                prevClose := c
    
    [buyVol, sellVol, intrabarCount]

[rawBuyVol, rawSellVol, intrabarCount] = calcVolume(volumeMethod, dojiHandling)

// Compute delta and percentages
float rawDelta = rawBuyVol - rawSellVol
float rawTotal = rawBuyVol + rawSellVol
float rawBuyPct = rawTotal > 0 ? (rawBuyVol / rawTotal) * 100 : 50.0
float rawSellPct = rawTotal > 0 ? (rawSellVol / rawTotal) * 100 : 50.0
float rawNetFlow = rawDelta

// Apply smoothing for display stability
float smoothedBuyPct = smoothingType == "EMA" ? ta.ema(rawBuyPct, smoothingLen) : ta.sma(rawBuyPct, smoothingLen)
float smoothedSellPct = smoothingType == "EMA" ? ta.ema(rawSellPct, smoothingLen) : ta.sma(rawSellPct, smoothingLen)

// Compute raw power percentage (how dominant is the winning side)
float rawPowerPct = rawTotal > 0 ? 100.0 * math.abs(rawDelta) / rawTotal : na
float smoothedPowerPct = smoothingType == "EMA" ? ta.ema(rawPowerPct, smoothingLen) : ta.sma(rawPowerPct, smoothingLen)

float avgTotal = ta.sma(rawTotal, avgVolumePeriod)
float avgBuyVol = ta.sma(rawBuyVol, avgVolumePeriod)
float avgSellVol = ta.sma(rawSellVol, avgVolumePeriod)

// Determine RAW side from delta (before stability filters)
int rawPowerSide = rawDelta > 0 ? 1 : (rawDelta < 0 ? -1 : 0)  // 1=BUY, -1=SELL, 0=NEUTRAL

// === STABILITY FILTERS ===
// 1) Neutral band: if powerPct is in the neutral zone, force NEUTRAL
bool inNeutralZone = na(smoothedPowerPct) or smoothedPowerPct < neutralBandPct

// 2) Flip confirmation: require N consecutive bars supporting new side before switching
var int confirmedPowerSide = 0  // Persisted displayed side
var int flipConfirmCount = 0    // Counter for confirmation

// Get the candidate side (after neutral zone filter)
int candidateSide = inNeutralZone ? 0 : rawPowerSide

// Signal timing: only update stateful counters when appropriate
bool shouldUpdatePowerState = signalTiming == "Realtime (intrabar)" or barstate.isconfirmed

// Apply flip confirmation logic (respects signal timing)
if shouldUpdatePowerState
    if candidateSide == confirmedPowerSide
        // Same side - reset confirmation counter
        flipConfirmCount := 0
    else if candidateSide == 0
        // Moving to NEUTRAL - confirm immediately (no delay for de-escalation)
        confirmedPowerSide := 0
        flipConfirmCount := 0
    else
        // Different non-neutral side - require confirmation
        flipConfirmCount += 1
        if flipConfirmCount >= flipConfirmBars
            confirmedPowerSide := candidateSide
            flipConfirmCount := 0

// Final displayed side (uses confirmed side for stability)
int powerSide = confirmedPowerSide

// Low confidence check
bool powerLowConf = intrabarCount < minIntrabars or rawTotal == 0 or na(rawPowerPct)

// === LATCHED POWER VALUES FOR CONFIRMED MODE ===
// When signalTiming="Confirmed (bar close)", dashboard should show stable values
var float latchedPowerPct = 0.0
var float latchedBuyPct = 50.0
var float latchedSellPct = 50.0
var float latchedBuyVol = 0.0
var float latchedSellVol = 0.0
var float latchedNetFlow = 0.0
var int latchedIntrabarCount = 0
var bool latchedLowConf = true
var int latchedPowerSide = 0

if signalTiming == "Confirmed (bar close)"
    if barstate.isconfirmed
        latchedPowerPct := na(smoothedPowerPct) ? 0.0 : smoothedPowerPct
        latchedBuyPct := smoothedBuyPct
        latchedSellPct := smoothedSellPct
        latchedBuyVol := rawBuyVol
        latchedSellVol := rawSellVol
        latchedNetFlow := rawNetFlow
        latchedIntrabarCount := intrabarCount
        latchedLowConf := powerLowConf or na(smoothedPowerPct)
        latchedPowerSide := powerSide
else
    // Realtime mode: keep latched values in sync
    latchedPowerPct := na(smoothedPowerPct) ? 0.0 : smoothedPowerPct
    latchedBuyPct := smoothedBuyPct
    latchedSellPct := smoothedSellPct
    latchedBuyVol := rawBuyVol
    latchedSellVol := rawSellVol
    latchedNetFlow := rawNetFlow
    latchedIntrabarCount := intrabarCount
    latchedLowConf := powerLowConf or na(smoothedPowerPct)
    latchedPowerSide := powerSide

// Select display values based on signal timing mode
int displaySide = signalTiming == "Confirmed (bar close)" ? latchedPowerSide : powerSide
float displayPowerPct = signalTiming == "Confirmed (bar close)" ? latchedPowerPct : (na(smoothedPowerPct) ? 0.0 : smoothedPowerPct)
float displayBuyPct = signalTiming == "Confirmed (bar close)" ? latchedBuyPct : smoothedBuyPct
float displaySellPct = signalTiming == "Confirmed (bar close)" ? latchedSellPct : smoothedSellPct
float displayBuyVol = signalTiming == "Confirmed (bar close)" ? latchedBuyVol : rawBuyVol
float displaySellVol = signalTiming == "Confirmed (bar close)" ? latchedSellVol : rawSellVol
float displayNetFlow = signalTiming == "Confirmed (bar close)" ? latchedNetFlow : rawNetFlow
int displayIntrabarCount = signalTiming == "Confirmed (bar close)" ? latchedIntrabarCount : intrabarCount
bool displayLowConf = signalTiming == "Confirmed (bar close)" ? latchedLowConf : (powerLowConf or na(smoothedPowerPct))

// === UNIFIED WIDGET TABLE ===
var table widget = na
var string lastWidgetLocation = na
var string lastTableSize = na

if barstate.islast and showVolumeTable
    // Count rows needed
    int tfCount = showMtfSection ? ((showTf1 ? 1 : 0) + (showTf2 ? 1 : 0) + (showTf3 ? 1 : 0) + (showTf4 ? 1 : 0)) : 0
    int mtfHeaderRows = showMtfSection ? 1 : 0
    int separatorRows = (showMtfSection and showCurrentVolSection) ? 1 : 0
    int currentVolRows = showCurrentVolSection ? 3 : 0  // Power, Buy, Sell rows
    int netFlowRows = (showCurrentVolSection and showNetFlow) ? 1 : 0
    int avgRows = (showCurrentVolSection and showAvgSection) ? 3 : 0  // Separator, Avg Buy, Avg Sell
    
    int totalRows = mtfHeaderRows + tfCount + separatorRows + currentVolRows + netFlowRows + avgRows
    
    // Check if settings changed
    bool settingsChanged = (not na(lastWidgetLocation) and widgetPosition != lastWidgetLocation) or
                           (not na(lastTableSize) and tableSize != lastTableSize)
    
    if settingsChanged
        if not na(widget)
            table.delete(widget)
            widget := na
    
    if na(widget)
        widget := table.new(getWidgetPosition(widgetPosition), 4, totalRows + 1, 
             bgcolor=color.new(#000000, tableTransparency),
             border_color=color.new(color.white, 70), 
             border_width=1)
        lastWidgetLocation := widgetPosition
        lastTableSize := tableSize
    
    table.clear(widget, 0, 0, 3, totalRows)
    
    // Text size - match ICT Order Block Pro (size.small for dashboard)
    txtSize = getTextSize(tableSize)
    
    int row = 0
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MTF SECTION (matching ICT Order Block Pro style)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if showMtfSection
        // Header row - gray text like ICT OB Pro column headers (with padding for width)
        table.cell(widget, 0, row, padText("TF"), text_color=color.gray, text_size=txtSize)
        table.cell(widget, 1, row, padText("Volume"), text_color=color.gray, text_size=txtSize)
        table.cell(widget, 2, row, padText("Avg"), text_color=color.gray, text_size=txtSize)
        table.cell(widget, 3, row, padText("Sentiment"), text_color=color.gray, text_size=txtSize)
        row += 1
        
        // TF1 row
        if showTf1
            color sentimentCol = tf1Bullish ? bullishColor : bearishColor
            string sentiment = tf1Bullish ? "Bullish â–²" : "Bearish â–¼"
            table.cell(widget, 0, row, padText(formatTf(tf1)), text_color=color.white, text_size=txtSize)
            table.cell(widget, 1, row, padText(formatVolume(tf1Vol)), text_color=color.white, text_size=txtSize)
            table.cell(widget, 2, row, padText(formatVolume(tf1AvgVol)), text_color=color.white, text_size=txtSize)
            table.cell(widget, 3, row, padText(sentiment), text_color=sentimentCol, text_size=txtSize)
            row += 1
        
        // TF2 row
        if showTf2
            color sentimentCol = tf2Bullish ? bullishColor : bearishColor
            string sentiment = tf2Bullish ? "Bullish â–²" : "Bearish â–¼"
            table.cell(widget, 0, row, padText(formatTf(tf2)), text_color=color.white, text_size=txtSize)
            table.cell(widget, 1, row, padText(formatVolume(tf2Vol)), text_color=color.white, text_size=txtSize)
            table.cell(widget, 2, row, padText(formatVolume(tf2AvgVol)), text_color=color.white, text_size=txtSize)
            table.cell(widget, 3, row, padText(sentiment), text_color=sentimentCol, text_size=txtSize)
            row += 1
        
        // TF3 row
        if showTf3
            color sentimentCol = tf3Bullish ? bullishColor : bearishColor
            string sentiment = tf3Bullish ? "Bullish â–²" : "Bearish â–¼"
            table.cell(widget, 0, row, padText(formatTf(tf3)), text_color=color.white, text_size=txtSize)
            table.cell(widget, 1, row, padText(formatVolume(tf3Vol)), text_color=color.white, text_size=txtSize)
            table.cell(widget, 2, row, padText(formatVolume(tf3AvgVol)), text_color=color.white, text_size=txtSize)
            table.cell(widget, 3, row, padText(sentiment), text_color=sentimentCol, text_size=txtSize)
            row += 1
        
        // TF4 row
        if showTf4
            color sentimentCol = tf4Bullish ? bullishColor : bearishColor
            string sentiment = tf4Bullish ? "Bullish â–²" : "Bearish â–¼"
            table.cell(widget, 0, row, padText(formatTf(tf4)), text_color=color.white, text_size=txtSize)
            table.cell(widget, 1, row, padText(formatVolume(tf4Vol)), text_color=color.white, text_size=txtSize)
            table.cell(widget, 2, row, padText(formatVolume(tf4AvgVol)), text_color=color.white, text_size=txtSize)
            table.cell(widget, 3, row, padText(sentiment), text_color=sentimentCol, text_size=txtSize)
            row += 1
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SEPARATOR (ICT OB Pro style)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if showMtfSection and showCurrentVolSection
        table.merge_cells(widget, 0, row, 3, row)
        table.cell(widget, 0, row, padText("â”€â”€â”€ INTRABAR â”€â”€â”€"), text_color=color.gray, text_size=txtSize)
        row += 1
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CURRENT VOLUME SECTION (Buy/Sell Analysis)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if showCurrentVolSection
        // Power-style row: Label | Side | Pct | Info
        string sideText = displaySide == 1 ? "BUY" : (displaySide == -1 ? "SELL" : "NEUTRAL")
        color sideCol = displaySide == 1 ? bullishColor : (displaySide == -1 ? bearishColor : color.gray)
        float dominantPct = displaySide == 1 ? displayBuyPct : displaySellPct
        string pctText = displayLowConf ? "â€”" : str.tostring(round2(dominantPct)) + "%"
        
        table.cell(widget, 0, row, padText("Power"), text_color=color.white, text_size=txtSize)
        table.cell(widget, 1, row, padText(sideText), text_color=sideCol, text_size=txtSize)
        table.cell(widget, 2, row, padText(pctText), text_color=sideCol, text_size=txtSize)
        table.cell(widget, 3, row, padText(str.tostring(displayIntrabarCount) + " bars"), text_color=displayLowConf ? color.orange : color.gray, text_size=txtSize)
        row += 1
        
        // Buy row
        string buyVolText = displayLowConf ? "â€”" : formatVolume(displayBuyVol)
        string buyPctText = displayLowConf ? "â€”" : str.tostring(round2(displayBuyPct)) + "%"
        table.cell(widget, 0, row, padText("Buy"), text_color=bullishColor, text_size=txtSize)
        table.cell(widget, 1, row, padText(buyVolText), text_color=bullishColor, text_size=txtSize)
        table.cell(widget, 2, row, padText(buyPctText), text_color=bullishColor, text_size=txtSize)
        table.cell(widget, 3, row, "", text_size=txtSize)
        row += 1
        
        // Sell row
        string sellVolText = displayLowConf ? "â€”" : formatVolume(displaySellVol)
        string sellPctText = displayLowConf ? "â€”" : str.tostring(round2(displaySellPct)) + "%"
        table.cell(widget, 0, row, padText("Sell"), text_color=bearishColor, text_size=txtSize)
        table.cell(widget, 1, row, padText(sellVolText), text_color=bearishColor, text_size=txtSize)
        table.cell(widget, 2, row, padText(sellPctText), text_color=bearishColor, text_size=txtSize)
        table.cell(widget, 3, row, "", text_size=txtSize)
        row += 1
        
        // Net Flow
        if showNetFlow
            color netCol = displayNetFlow > 0 ? bullishColor : (displayNetFlow < 0 ? bearishColor : color.gray)
            string netPrefix = displayNetFlow > 0 ? "+" : (displayNetFlow < 0 ? "-" : "")
            string netDisplay = displayLowConf ? "â€”" : netPrefix + formatVolume(math.abs(displayNetFlow))
            table.cell(widget, 0, row, padText("Net"), text_color=color.gray, text_size=txtSize)
            table.cell(widget, 1, row, padText(netDisplay), text_color=netCol, text_size=txtSize)
            table.cell(widget, 2, row, "", text_size=txtSize)
            table.cell(widget, 3, row, "", text_size=txtSize)
            row += 1
        
        // Average Section
        if showAvgSection
            // Avg separator
            table.merge_cells(widget, 0, row, 3, row)
            table.cell(widget, 0, row, padText("â”€â”€â”€ AVG â”€â”€â”€"), text_color=color.gray, text_size=txtSize)
            row += 1
            
            // Avg Buy row
            table.cell(widget, 0, row, padText("Avg Buy"), text_color=bullishColor, text_size=txtSize)
            table.cell(widget, 1, row, padText(formatVolume(avgBuyVol)), text_color=bullishColor, text_size=txtSize)
            table.cell(widget, 2, row, "", text_size=txtSize)
            table.cell(widget, 3, row, "", text_size=txtSize)
            row += 1
            
            // Avg Sell row
            table.cell(widget, 0, row, padText("Avg Sell"), text_color=bearishColor, text_size=txtSize)
            table.cell(widget, 1, row, padText(formatVolume(avgSellVol)), text_color=bearishColor, text_size=txtSize)
            table.cell(widget, 2, row, "", text_size=txtSize)
            table.cell(widget, 3, row, "", text_size=txtSize)
            row += 1

// === PLOT INVISIBLE (required for overlay indicator) ===
plot(na, display=display.none)
