//@version=6
indicator("BTC Volume Analysis [Paganie]", overlay=true)

// ============================================================================
// BTC VOLUME ANALYSIS [PAGANIE] V2.2
// Multi-timeframe volume sentiment + intrabar buy/sell analysis
// Designed to complement ICT Order Block Pro [Paganie]
//
// V2.2 - Settings UX Overhaul:
// â€¢ Reorganized settings into 6 logical groups
// â€¢ Most common settings at top, advanced at bottom
// â€¢ Improved tooltips with examples and explanations
// â€¢ Visual hierarchy with tree-style labels
//
// V2.1 - Consistency & Context Improvements:
// â€¢ MTF sentiment now uses Pressure method (consistent with intrabar)
// â€¢ Added "vs Avg" ratio display (shows volume relative to average)
// â€¢ Color-coded volume ratios (green â‰¥1.5x, red â‰¤0.5x)
//
// V2.0 - Enhanced Volume Classification + Stability Features:
// â€¢ Buying/Selling Pressure method (more accurate than Polarity)
// â€¢ Neutral Band filter (reduces noise around 50%)
// â€¢ Flip Confirmation (prevents whipsaws)
// â€¢ Signal Timing modes (Realtime vs Confirmed)
// ============================================================================

// === INPUTS ===
// Organized for ease of use: Most common settings first, advanced settings last

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 1. DASHBOARD - Master Controls
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string G1 = "ğŸ“Š Dashboard"
showVolumeTable = input.bool(true, "Show Widget", group=G1,
     tooltip="Master toggle to show/hide the entire volume analysis widget")
showCurrentVolSection = input.bool(true, "â”œâ”€ Intrabar Analysis", group=G1,
     tooltip="Real-time buy/sell pressure breakdown from lower timeframe data")
showNetFlow = input.bool(true, "â”‚   â””â”€ Net Flow", group=G1,
     tooltip="Shows the difference between buy and sell volume")
showAvgSection = input.bool(true, "â”œâ”€ Averages", group=G1,
     tooltip="Shows average buy/sell volume over the specified period")
showMtfSection = input.bool(true, "â””â”€ Multi-Timeframe", group=G1,
     tooltip="Volume sentiment across multiple timeframes")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 2. SYMBOL - What to Analyze
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string G2 = "â‚¿ Symbol"
useCurrentChart = input.bool(false, "Use Current Chart Symbol", group=G2,
     tooltip="ON: Analyze the symbol you're viewing\nOFF: Analyze the specified symbol below (useful for BTC dominance on any chart)")
btcSymbol = input.string("BINANCE:BTCUSDT.P", "Symbol to Analyze", group=G2,
     tooltip="The symbol to analyze (only used when 'Use Current Chart' is OFF)\n\nExamples:\nâ€¢ BINANCE:BTCUSDT\nâ€¢ COINBASE:BTCUSD\nâ€¢ BYBIT:BTCUSDT.P\nâ€¢ INDEX:BTCUSD")

// Determine effective symbol
string effectiveSymbol = useCurrentChart ? syminfo.tickerid : btcSymbol

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 3. TIMEFRAMES - MTF Settings
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string G3 = "â±ï¸ Multi-Timeframe"
showTf1 = input.bool(true, "Timeframe 1", inline="tf1", group=G3)
tf1 = input.timeframe("1", "", inline="tf1", group=G3)
showTf2 = input.bool(true, "Timeframe 2", inline="tf2", group=G3)
tf2 = input.timeframe("5", "", inline="tf2", group=G3)
showTf3 = input.bool(true, "Timeframe 3", inline="tf3", group=G3)
tf3 = input.timeframe("15", "", inline="tf3", group=G3)
showTf4 = input.bool(true, "Timeframe 4", inline="tf4", group=G3)
tf4 = input.timeframe("30", "", inline="tf4", group=G3)

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 4. APPEARANCE - Visual Settings
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string G4 = "ğŸ¨ Appearance"
widgetPosition = input.string("Bottom Right", "Position", 
     options=["Bottom Right", "Bottom Left", "Top Right", "Top Left", "Middle Right", "Middle Left"], group=G4,
     tooltip="Where to place the widget on the chart")
tableSize = input.string("small", "Text Size", options=["tiny", "small", "normal", "large"], group=G4)
tableWidth = input.string("Wide", "Widget Width", options=["Compact", "Normal", "Wide", "Extra Wide"], group=G4,
     tooltip="Horizontal size of the widget")
tableTransparency = input.int(90, "Transparency", minval=0, maxval=90, step=5, group=G4,
     tooltip="Widget background transparency\n0 = Solid black\n90 = Almost invisible")
color bullishColor = input.color(color.new(#00ff88, 0), "Bullish Color", inline="colors", group=G4)
color bearishColor = input.color(color.new(#ff3366, 0), "Bearish Color", inline="colors", group=G4)

// Detect light/dark mode - use chart background color
color chartBg = chart.bg_color
float bgR = color.r(chartBg) / 255.0
float bgG = color.g(chartBg) / 255.0
float bgB = color.b(chartBg) / 255.0
float luminance = 0.299 * bgR + 0.587 * bgG + 0.114 * bgB
bool isLightMode = luminance > 0.5
color textColor = isLightMode ? color.black : color.white
color dimTextColor = isLightMode ? color.new(color.black, 40) : color.gray

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 5. ANALYSIS - How Volume is Calculated
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string G5 = "âš™ï¸ Analysis"
volumeMethod = input.string("Pressure", "Volume Classification", options=["Pressure", "Polarity"], group=G5,
     tooltip="How to classify volume as buying or selling:\n\nPRESSURE (Recommended):\nProportionally assigns volume based on where price closed within the candle's range.\nExample: Close at 75% of range = 75% buy, 25% sell\n\nPOLARITY (Classic):\nBinary method - all volume goes to buy if green candle, sell if red candle.")
signalTiming = input.string("Realtime (intrabar)", "Signal Updates", options=["Realtime (intrabar)", "Confirmed (bar close)"], group=G5,
     tooltip="When to update the display:\n\nREALTIME: Updates every tick (faster, may flicker)\nCONFIRMED: Updates only on bar close (stable, no repainting)")
avgVolumePeriod = input.int(10, "Average Period", minval=1, maxval=100, group=G5,
     tooltip="Number of bars used to calculate average volume\nUsed for 'vs Avg' ratio and Average section")

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// 6. ADVANCED - Fine-tuning (Most users won't need to change)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
string G6 = "ğŸ”§ Advanced"
ltfMode = input.string("Auto", "Lower TF Mode", options=["Auto", "Manual"], group=G6,
     tooltip="AUTO: Automatically selects optimal lower timeframe based on chart:\nâ€¢ Chart â‰¤15m â†’ 1m intrabars\nâ€¢ Chart â‰¤1h â†’ 5m intrabars\nâ€¢ Chart â‰¤4h â†’ 15m intrabars\nâ€¢ Chart â‰¤1D â†’ 1h intrabars\n\nMANUAL: Use your specified timeframe")
manualLtf = input.timeframe("1", "â””â”€ Manual Lower TF", group=G6,
     tooltip="Only used when 'Lower TF Mode' is set to Manual")
smoothingLen = input.int(3, "Smoothing Length", minval=1, maxval=10, group=G6,
     tooltip="EMA/SMA period for smoothing buy/sell percentages\nHigher = smoother but laggier")
smoothingType = input.string("EMA", "Smoothing Type", options=["EMA", "SMA"], group=G6,
     tooltip="EMA: More responsive to recent data\nSMA: Equal weight to all data")
minIntrabars = input.int(4, "Min Intrabars for Confidence", minval=1, maxval=20, group=G6,
     tooltip="Minimum number of intrabar candles required before showing data\nBelow this threshold, displays 'â€”' instead of potentially unreliable data")
neutralBandPct = input.float(5.0, "Neutral Zone %", minval=0.0, maxval=30.0, step=1.0, group=G6,
     tooltip="When buy/sell are close to 50/50, show NEUTRAL instead of flipping between BUY/SELL\n\n5% = Neutral when difference < 5%\n0% = Disable neutral zone (always show BUY or SELL)")
flipConfirmBars = input.int(1, "Flip Confirmation Bars", minval=0, maxval=10, group=G6,
     tooltip="Number of bars the signal must persist before switching sides\nPrevents rapid flipping between BUY and SELL\n\n0 = Instant switching\n1+ = Requires confirmation")
dojiHandling = input.string("Carry last direction", "Doji Handling (Polarity only)", 
     options=["Carry last direction", "Use prev intrabar close", "Ignore dojis"], group=G6, 
     tooltip="How to handle candles where close = open (only applies to Polarity method):\n\nâ€¢ Carry last: Use previous candle's direction\nâ€¢ Prev close: Compare to prior candle's close\nâ€¢ Ignore: Don't count doji volume")

// === HELPER FUNCTIONS ===
formatVolume(float vol) =>
    string s = ""
    if na(vol) or vol == 0
        s := "0"
    else
        float k = vol / 1000.0
        float m = vol / 1000000.0
        if m >= 1.0 or k >= 999.5
            s := str.tostring(math.round(m * 100) / 100) + "M"
        else if k >= 1.0
            s := str.tostring(math.round(k * 10) / 10) + "k"
        else
            s := str.tostring(math.round(vol))
    s

formatTf(string tf) =>
    int tfMins = timeframe.in_seconds(tf) / 60
    string result = ""
    if tfMins < 60
        result := str.tostring(tfMins)
    else if tfMins < 1440
        result := str.tostring(tfMins / 60) + "H"
    else if tfMins == 1440
        result := "D"
    else if tfMins == 10080
        result := "W"
    else
        result := tf
    result

round2(float x) =>
    math.round(x * 100) / 100

// Format volume vs average ratio (e.g., "1.5x", "0.8x")
formatVsAvg(float ratio) =>
    string s = ""
    if na(ratio) or ratio == 0
        s := "â€”"
    else
        s := str.tostring(math.round(ratio * 10) / 10, "#.#") + "x"
    s

getWidgetPosition(string loc) =>
    switch loc
        "Top Left" => position.top_left
        "Top Right" => position.top_right
        "Bottom Left" => position.bottom_left
        "Bottom Right" => position.bottom_right
        "Middle Left" => position.middle_left
        "Middle Right" => position.middle_right
        => position.bottom_right

getTextSize(string sz) =>
    switch sz
        "tiny" => size.tiny
        "small" => size.small
        "normal" => size.normal
        "large" => size.large
        => size.normal

// Padding for widget width - cached for performance
string _padding = switch tableWidth
    "Compact" => ""
    "Normal" => " "
    "Wide" => "  "
    "Extra Wide" => "    "
    => " "

padText(string txt) =>
    _padding + txt + _padding

// === TIMEFRAME LOGIC FOR INTRABAR ===
tf_in_minutes = timeframe.in_seconds() / 60

getPowerLtf() =>
    string ltf = "1"
    if tf_in_minutes <= 5
        ltf := "1"
    else if tf_in_minutes <= 15
        ltf := "1"
    else if tf_in_minutes <= 60
        ltf := "5"
    else if tf_in_minutes <= 240
        ltf := "15"
    else if tf_in_minutes <= 1440
        ltf := "60"
    else
        ltf := "240"
    ltf

string effectiveLtf = ltfMode == "Auto" ? getPowerLtf() : manualLtf

int chartTfSec = timeframe.in_seconds()
int powerTfSec = timeframe.in_seconds(effectiveLtf)
string powerLtfSafe = powerTfSec <= chartTfSec ? effectiveLtf : timeframe.period

// === MULTI-TIMEFRAME VOLUME DATA ===
// Helper function to calculate buy pressure ratio using Pressure method
calcBuyPressure(float h, float l, float c, float o) =>
    float candleRange = h - l
    float buyPressure = 0.5  // Default neutral
    if candleRange > 0
        buyPressure := (c - l) / candleRange
    else
        // No range - use polarity as fallback
        buyPressure := c > o ? 1.0 : (c < o ? 0.0 : 0.5)
    buyPressure

// TF1 data - fetch OHLCV for Pressure-based sentiment
[tf1Vol, tf1Open, tf1High, tf1Low, tf1Close] = request.security(effectiveSymbol, tf1, [volume, open, high, low, close], lookahead=barmerge.lookahead_off)
float tf1AvgVol = request.security(effectiveSymbol, tf1, ta.sma(volume, avgVolumePeriod), lookahead=barmerge.lookahead_off)
float tf1BuyPressure = calcBuyPressure(tf1High, tf1Low, tf1Close, tf1Open)
bool tf1Bullish = tf1BuyPressure > 0.5
float tf1VsAvg = tf1AvgVol > 0 ? tf1Vol / tf1AvgVol : 1.0

// TF2 data
[tf2Vol, tf2Open, tf2High, tf2Low, tf2Close] = request.security(effectiveSymbol, tf2, [volume, open, high, low, close], lookahead=barmerge.lookahead_off)
float tf2AvgVol = request.security(effectiveSymbol, tf2, ta.sma(volume, avgVolumePeriod), lookahead=barmerge.lookahead_off)
float tf2BuyPressure = calcBuyPressure(tf2High, tf2Low, tf2Close, tf2Open)
bool tf2Bullish = tf2BuyPressure > 0.5
float tf2VsAvg = tf2AvgVol > 0 ? tf2Vol / tf2AvgVol : 1.0

// TF3 data
[tf3Vol, tf3Open, tf3High, tf3Low, tf3Close] = request.security(effectiveSymbol, tf3, [volume, open, high, low, close], lookahead=barmerge.lookahead_off)
float tf3AvgVol = request.security(effectiveSymbol, tf3, ta.sma(volume, avgVolumePeriod), lookahead=barmerge.lookahead_off)
float tf3BuyPressure = calcBuyPressure(tf3High, tf3Low, tf3Close, tf3Open)
bool tf3Bullish = tf3BuyPressure > 0.5
float tf3VsAvg = tf3AvgVol > 0 ? tf3Vol / tf3AvgVol : 1.0

// TF4 data
[tf4Vol, tf4Open, tf4High, tf4Low, tf4Close] = request.security(effectiveSymbol, tf4, [volume, open, high, low, close], lookahead=barmerge.lookahead_off)
float tf4AvgVol = request.security(effectiveSymbol, tf4, ta.sma(volume, avgVolumePeriod), lookahead=barmerge.lookahead_off)
float tf4BuyPressure = calcBuyPressure(tf4High, tf4Low, tf4Close, tf4Open)
bool tf4Bullish = tf4BuyPressure > 0.5
float tf4VsAvg = tf4AvgVol > 0 ? tf4Vol / tf4AvgVol : 1.0

// === LIVE PRICE DATA ===
[livePrice, livePriceOpen] = request.security(effectiveSymbol, timeframe.period, [close, open], lookahead=barmerge.lookahead_off)
bool priceUp = livePrice >= livePriceOpen
color priceColor = priceUp ? bullishColor : bearishColor

// Format price with appropriate decimal places
formatPrice(float price) =>
    string s = ""
    if na(price)
        s := "â€”"
    else if price >= 10000
        s := str.tostring(price, "#.##")
    else if price >= 1000
        s := str.tostring(price, "#.##")
    else if price >= 100
        s := str.tostring(price, "#.###")
    else if price >= 1
        s := str.tostring(price, "#.####")
    else
        s := str.tostring(price, "#.######")
    s

// Extract short symbol name for display
getShortSymbol(string sym) =>
    string result = sym
    int colonPos = str.pos(sym, ":")
    if colonPos >= 0
        result := str.substring(sym, colonPos + 1)
    result

// === INTRABAR DATA FOR BUY/SELL ANALYSIS ===
arrOpen = request.security_lower_tf(effectiveSymbol, powerLtfSafe, open, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)
arrHigh = request.security_lower_tf(effectiveSymbol, powerLtfSafe, high, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)
arrLow = request.security_lower_tf(effectiveSymbol, powerLtfSafe, low, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)
arrClose = request.security_lower_tf(effectiveSymbol, powerLtfSafe, close, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)
arrVol = request.security_lower_tf(effectiveSymbol, powerLtfSafe, volume, ignore_invalid_timeframe=true, ignore_invalid_symbol=true)

// Calculate buy/sell volume from intrabars
// Pre-compute method flags outside function for performance (avoid string comparisons in loop)
bool _usePressure = volumeMethod == "Pressure"
bool _carryLast = dojiHandling == "Carry last direction"
bool _usePrevClose = dojiHandling == "Use prev intrabar close"

calcVolume() =>
    float buyVol = 0.0
    float sellVol = 0.0
    int sizeVol = array.size(arrVol)
    int sizeOpen = array.size(arrOpen)
    int sizeHigh = array.size(arrHigh)
    int sizeLow = array.size(arrLow)
    int sizeClose = array.size(arrClose)
    int intrabarCount = math.min(sizeVol, math.min(sizeOpen, math.min(sizeHigh, math.min(sizeLow, sizeClose))))
    int lastDir = 0
    float prevClose = na
    
    if intrabarCount > 0
        for i = 0 to intrabarCount - 1
            float o = array.get(arrOpen, i)
            float h = array.get(arrHigh, i)
            float l = array.get(arrLow, i)
            float c = array.get(arrClose, i)
            float v = array.get(arrVol, i)
            
            if _usePressure
                // PRESSURE METHOD: Proportional volume assignment
                float candleRange = h - l
                if candleRange > 0
                    float buyRatio = (c - l) / candleRange
                    buyVol += v * buyRatio
                    sellVol += v * (1.0 - buyRatio)
                else
                    // No range - use polarity fallback
                    if c > o
                        buyVol += v
                    else if c < o
                        sellVol += v
                    else
                        buyVol += v * 0.5
                        sellVol += v * 0.5
            else
                // POLARITY METHOD: Binary classification
                int dir = 0
                if c > o
                    dir := 1
                else if c < o
                    dir := -1
                else if _carryLast
                    dir := lastDir
                else if _usePrevClose and not na(prevClose)
                    dir := c > prevClose ? 1 : (c < prevClose ? -1 : 0)
                
                if dir == 1
                    buyVol += v
                else if dir == -1
                    sellVol += v
                
                if dir != 0
                    lastDir := dir
                prevClose := c
    
    [buyVol, sellVol, intrabarCount]

[rawBuyVol, rawSellVol, intrabarCount] = calcVolume()

// Compute delta and percentages (optimized: derive sellPct from buyPct)
float rawDelta = rawBuyVol - rawSellVol
float rawTotal = rawBuyVol + rawSellVol
float rawBuyPct = rawTotal > 0 ? (rawBuyVol / rawTotal) * 100.0 : 50.0
float rawSellPct = 100.0 - rawBuyPct  // Derived, not recalculated

// Pre-compute smoothing type flag for performance
bool _useEma = smoothingType == "EMA"

// Apply smoothing for display stability
float smoothedBuyPct = _useEma ? ta.ema(rawBuyPct, smoothingLen) : ta.sma(rawBuyPct, smoothingLen)
float smoothedSellPct = 100.0 - smoothedBuyPct  // Derived from smoothed buy

// Compute raw power percentage (how dominant is the winning side)
float rawPowerPct = rawTotal > 0 ? 100.0 * math.abs(rawDelta) / rawTotal : na
float smoothedPowerPct = _useEma ? ta.ema(rawPowerPct, smoothingLen) : ta.sma(rawPowerPct, smoothingLen)

float avgTotal = ta.sma(rawTotal, avgVolumePeriod)
float avgBuyVol = ta.sma(rawBuyVol, avgVolumePeriod)
float avgSellVol = ta.sma(rawSellVol, avgVolumePeriod)

// Volume vs Average ratio for intrabar
float intrabarVsAvg = avgTotal > 0 ? rawTotal / avgTotal : 1.0

// Determine RAW side from delta (before stability filters)
int rawPowerSide = rawDelta > 0 ? 1 : (rawDelta < 0 ? -1 : 0)  // 1=BUY, -1=SELL, 0=NEUTRAL

// === STABILITY FILTERS ===
// 1) Neutral band: if powerPct is in the neutral zone, force NEUTRAL
bool inNeutralZone = na(smoothedPowerPct) or smoothedPowerPct < neutralBandPct

// 2) Flip confirmation: require N consecutive bars supporting new side before switching
var int confirmedPowerSide = 0  // Persisted displayed side
var int flipConfirmCount = 0    // Counter for confirmation

// Get the candidate side (after neutral zone filter)
int candidateSide = inNeutralZone ? 0 : rawPowerSide

// Signal timing: only update stateful counters when appropriate
bool shouldUpdatePowerState = signalTiming == "Realtime (intrabar)" or barstate.isconfirmed

// Apply flip confirmation logic (respects signal timing)
if shouldUpdatePowerState
    if candidateSide == confirmedPowerSide
        // Same side - reset confirmation counter
        flipConfirmCount := 0
    else if candidateSide == 0
        // Moving to NEUTRAL - confirm immediately (no delay for de-escalation)
        confirmedPowerSide := 0
        flipConfirmCount := 0
    else
        // Different non-neutral side - require confirmation
        flipConfirmCount += 1
        if flipConfirmCount >= flipConfirmBars
            confirmedPowerSide := candidateSide
            flipConfirmCount := 0

// Final displayed side (uses confirmed side for stability)
int powerSide = confirmedPowerSide

// Low confidence check
bool powerLowConf = intrabarCount < minIntrabars or rawTotal == 0 or na(rawPowerPct)

// === DISPLAY VALUES ===
// Pre-compute timing flag for performance
bool _confirmedMode = signalTiming == "Confirmed (bar close)"

// Latched values for confirmed mode (persist between ticks)
var float latchedBuyPct = 50.0
var float latchedSellPct = 50.0
var float latchedBuyVol = 0.0
var float latchedSellVol = 0.0
var float latchedNetFlow = 0.0
var float latchedVsAvg = 1.0
var bool latchedLowConf = true
var int latchedPowerSide = 0

// Update latched values only when appropriate
bool _shouldLatch = not _confirmedMode or barstate.isconfirmed
if _shouldLatch
    latchedBuyPct := smoothedBuyPct
    latchedSellPct := smoothedSellPct
    latchedBuyVol := rawBuyVol
    latchedSellVol := rawSellVol
    latchedNetFlow := rawDelta
    latchedVsAvg := intrabarVsAvg
    latchedLowConf := powerLowConf or na(smoothedPowerPct)
    latchedPowerSide := powerSide

// Select display values (use latched in confirmed mode, live in realtime)
int displaySide = _confirmedMode ? latchedPowerSide : powerSide
float displayBuyPct = _confirmedMode ? latchedBuyPct : smoothedBuyPct
float displaySellPct = _confirmedMode ? latchedSellPct : smoothedSellPct
float displayBuyVol = _confirmedMode ? latchedBuyVol : rawBuyVol
float displaySellVol = _confirmedMode ? latchedSellVol : rawSellVol
float displayNetFlow = _confirmedMode ? latchedNetFlow : rawDelta
float displayVsAvg = _confirmedMode ? latchedVsAvg : intrabarVsAvg
bool displayLowConf = _confirmedMode ? latchedLowConf : (powerLowConf or na(smoothedPowerPct))

// === UNIFIED WIDGET TABLE ===
var table widget = na
var string lastWidgetLocation = na
var string lastTableSize = na

if barstate.islast and showVolumeTable
    // Count rows needed
    int priceRow = 1  // Live price row at top
    int tfCount = showMtfSection ? ((showTf1 ? 1 : 0) + (showTf2 ? 1 : 0) + (showTf3 ? 1 : 0) + (showTf4 ? 1 : 0)) : 0
    int mtfHeaderRows = showMtfSection ? 1 : 0
    int separatorRows = (showMtfSection and showCurrentVolSection) ? 1 : 0
    int intrabarHeaderRows = showCurrentVolSection ? 1 : 0  // Header row for intrabar section
    int currentVolRows = showCurrentVolSection ? 2 : 0  // Buy, Sell rows
    int netFlowRows = (showCurrentVolSection and showNetFlow) ? 1 : 0
    int avgHeaderRows = (showCurrentVolSection and showAvgSection) ? 1 : 0  // AVG header
    int avgRows = (showCurrentVolSection and showAvgSection) ? 2 : 0  // Avg Buy, Avg Sell
    
    int totalRows = priceRow + intrabarHeaderRows + currentVolRows + netFlowRows + avgHeaderRows + avgRows + separatorRows + mtfHeaderRows + tfCount
    
    // Check if settings changed
    bool settingsChanged = (not na(lastWidgetLocation) and widgetPosition != lastWidgetLocation) or
                           (not na(lastTableSize) and tableSize != lastTableSize)
    
    if settingsChanged
        if not na(widget)
            table.delete(widget)
            widget := na
    
    if na(widget)
        widget := table.new(getWidgetPosition(widgetPosition), 4, totalRows + 1, 
             bgcolor=color.new(#000000, tableTransparency),
             border_color=color.new(color.white, 70), 
             border_width=1)
        lastWidgetLocation := widgetPosition
        lastTableSize := tableSize
    
    table.clear(widget, 0, 0, 3, totalRows)
    
    // Text size
    txtSize = getTextSize(tableSize)
    // Larger size for price row
    priceTxtSize = switch tableSize
        "tiny" => size.small
        "small" => size.normal
        "normal" => size.large
        "large" => size.huge
        => size.large
    
    int row = 0
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LIVE PRICE ROW - AT VERY TOP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    string symbolDisplay = getShortSymbol(effectiveSymbol)
    string priceDisplay = formatPrice(livePrice)
    string priceArrow = priceUp ? " â–²" : " â–¼"
    table.cell(widget, 0, row, padText("â‚¿ " + symbolDisplay), text_color=textColor, text_size=priceTxtSize, text_font_family=font.family_monospace)
    table.merge_cells(widget, 1, row, 3, row)
    table.cell(widget, 1, row, padText(priceDisplay + priceArrow), text_color=priceColor, text_size=priceTxtSize, text_font_family=font.family_monospace)
    row += 1
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INTRABAR SECTION (Buy/Sell Analysis)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if showCurrentVolSection
        // Header row for Intrabar section
        table.cell(widget, 0, row, padText("Type"), text_color=dimTextColor, text_size=txtSize)
        table.cell(widget, 1, row, padText("Volume"), text_color=dimTextColor, text_size=txtSize)
        table.cell(widget, 2, row, padText("%"), text_color=dimTextColor, text_size=txtSize)
        table.cell(widget, 3, row, padText("Power"), text_color=dimTextColor, text_size=txtSize)
        row += 1
        
        // Determine display values
        string sideText = displaySide == 1 ? "BUY" : (displaySide == -1 ? "SELL" : "â€”")
        color sideCol = displaySide == 1 ? bullishColor : (displaySide == -1 ? bearishColor : dimTextColor)
        
        // Format vs Avg with color coding (highlight unusual volume)
        string vsAvgText = displayLowConf ? "â€”" : formatVsAvg(displayVsAvg)
        color vsAvgCol = displayVsAvg >= 1.5 ? bullishColor : (displayVsAvg <= 0.5 ? bearishColor : dimTextColor)
        
        // Buy row
        string buyVolText = displayLowConf ? "â€”" : formatVolume(displayBuyVol)
        string buyPctText = displayLowConf ? "â€”" : str.tostring(round2(displayBuyPct)) + "%"
        table.cell(widget, 0, row, padText("Buy"), text_color=bullishColor, text_size=txtSize)
        table.cell(widget, 1, row, padText(buyVolText), text_color=bullishColor, text_size=txtSize)
        table.cell(widget, 2, row, padText(buyPctText), text_color=bullishColor, text_size=txtSize)
        table.cell(widget, 3, row, padText(sideText), text_color=sideCol, text_size=txtSize)
        row += 1
        
        // Sell row - show vs Avg ratio instead of bars count
        string sellVolText = displayLowConf ? "â€”" : formatVolume(displaySellVol)
        string sellPctText = displayLowConf ? "â€”" : str.tostring(round2(displaySellPct)) + "%"
        table.cell(widget, 0, row, padText("Sell"), text_color=bearishColor, text_size=txtSize)
        table.cell(widget, 1, row, padText(sellVolText), text_color=bearishColor, text_size=txtSize)
        table.cell(widget, 2, row, padText(sellPctText), text_color=bearishColor, text_size=txtSize)
        table.cell(widget, 3, row, padText(vsAvgText), text_color=displayLowConf ? color.orange : vsAvgCol, text_size=txtSize)
        row += 1
        
        // Net Flow
        if showNetFlow
            color netCol = displayNetFlow > 0 ? bullishColor : (displayNetFlow < 0 ? bearishColor : dimTextColor)
            string netPrefix = displayNetFlow > 0 ? "+" : (displayNetFlow < 0 ? "-" : "")
            string netDisplay = displayLowConf ? "â€”" : netPrefix + formatVolume(math.abs(displayNetFlow))
            table.cell(widget, 0, row, padText("Net Flow"), text_color=dimTextColor, text_size=txtSize)
            table.cell(widget, 1, row, padText(netDisplay), text_color=netCol, text_size=txtSize)
            table.cell(widget, 2, row, "", text_size=txtSize)
            table.cell(widget, 3, row, "", text_size=txtSize)
            row += 1
        
        // Average Section
        if showAvgSection
            // AVG Header
            table.cell(widget, 0, row, padText("Average"), text_color=dimTextColor, text_size=txtSize)
            table.cell(widget, 1, row, padText("Volume"), text_color=dimTextColor, text_size=txtSize)
            table.cell(widget, 2, row, "", text_size=txtSize)
            table.cell(widget, 3, row, "", text_size=txtSize)
            row += 1
            
            table.cell(widget, 0, row, padText("Buy"), text_color=bullishColor, text_size=txtSize)
            table.cell(widget, 1, row, padText(formatVolume(avgBuyVol)), text_color=bullishColor, text_size=txtSize)
            table.cell(widget, 2, row, "", text_size=txtSize)
            table.cell(widget, 3, row, "", text_size=txtSize)
            row += 1
            
            table.cell(widget, 0, row, padText("Sell"), text_color=bearishColor, text_size=txtSize)
            table.cell(widget, 1, row, padText(formatVolume(avgSellVol)), text_color=bearishColor, text_size=txtSize)
            table.cell(widget, 2, row, "", text_size=txtSize)
            table.cell(widget, 3, row, "", text_size=txtSize)
            row += 1
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SEPARATOR (if both sections enabled)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if showMtfSection and showCurrentVolSection
        table.merge_cells(widget, 0, row, 3, row)
        table.cell(widget, 0, row, "â”€â”€â”€ MTF â”€â”€â”€", text_color=dimTextColor, text_size=txtSize)
        row += 1
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MTF SECTION - AT BOTTOM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if showMtfSection
        // Header row
        table.cell(widget, 0, row, padText("TF"), text_color=dimTextColor, text_size=txtSize)
        table.cell(widget, 1, row, padText("Vol"), text_color=dimTextColor, text_size=txtSize)
        table.cell(widget, 2, row, padText("vs Avg"), text_color=dimTextColor, text_size=txtSize)
        table.cell(widget, 3, row, padText("Sentiment"), text_color=dimTextColor, text_size=txtSize)
        row += 1
        
        // TF1 row
        if showTf1
            color sentimentCol = tf1Bullish ? bullishColor : bearishColor
            string sentiment = tf1Bullish ? "Bullish â–²" : "Bearish â–¼"
            color vsAvgCol = tf1VsAvg >= 1.5 ? bullishColor : (tf1VsAvg <= 0.5 ? bearishColor : textColor)
            table.cell(widget, 0, row, padText(formatTf(tf1)), text_color=textColor, text_size=txtSize)
            table.cell(widget, 1, row, padText(formatVolume(tf1Vol)), text_color=textColor, text_size=txtSize)
            table.cell(widget, 2, row, padText(formatVsAvg(tf1VsAvg)), text_color=vsAvgCol, text_size=txtSize)
            table.cell(widget, 3, row, padText(sentiment), text_color=sentimentCol, text_size=txtSize)
            row += 1
        
        // TF2 row
        if showTf2
            color sentimentCol = tf2Bullish ? bullishColor : bearishColor
            string sentiment = tf2Bullish ? "Bullish â–²" : "Bearish â–¼"
            color vsAvgCol = tf2VsAvg >= 1.5 ? bullishColor : (tf2VsAvg <= 0.5 ? bearishColor : textColor)
            table.cell(widget, 0, row, padText(formatTf(tf2)), text_color=textColor, text_size=txtSize)
            table.cell(widget, 1, row, padText(formatVolume(tf2Vol)), text_color=textColor, text_size=txtSize)
            table.cell(widget, 2, row, padText(formatVsAvg(tf2VsAvg)), text_color=vsAvgCol, text_size=txtSize)
            table.cell(widget, 3, row, padText(sentiment), text_color=sentimentCol, text_size=txtSize)
            row += 1
        
        // TF3 row
        if showTf3
            color sentimentCol = tf3Bullish ? bullishColor : bearishColor
            string sentiment = tf3Bullish ? "Bullish â–²" : "Bearish â–¼"
            color vsAvgCol = tf3VsAvg >= 1.5 ? bullishColor : (tf3VsAvg <= 0.5 ? bearishColor : textColor)
            table.cell(widget, 0, row, padText(formatTf(tf3)), text_color=textColor, text_size=txtSize)
            table.cell(widget, 1, row, padText(formatVolume(tf3Vol)), text_color=textColor, text_size=txtSize)
            table.cell(widget, 2, row, padText(formatVsAvg(tf3VsAvg)), text_color=vsAvgCol, text_size=txtSize)
            table.cell(widget, 3, row, padText(sentiment), text_color=sentimentCol, text_size=txtSize)
            row += 1
        
        // TF4 row
        if showTf4
            color sentimentCol = tf4Bullish ? bullishColor : bearishColor
            string sentiment = tf4Bullish ? "Bullish â–²" : "Bearish â–¼"
            color vsAvgCol = tf4VsAvg >= 1.5 ? bullishColor : (tf4VsAvg <= 0.5 ? bearishColor : textColor)
            table.cell(widget, 0, row, padText(formatTf(tf4)), text_color=textColor, text_size=txtSize)
            table.cell(widget, 1, row, padText(formatVolume(tf4Vol)), text_color=textColor, text_size=txtSize)
            table.cell(widget, 2, row, padText(formatVsAvg(tf4VsAvg)), text_color=vsAvgCol, text_size=txtSize)
            table.cell(widget, 3, row, padText(sentiment), text_color=sentimentCol, text_size=txtSize)
            row += 1

// === PLOT INVISIBLE (required for overlay indicator) ===
plot(na, display=display.none)
