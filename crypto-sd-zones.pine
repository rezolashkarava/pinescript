// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Ultimate Crypto S&D Zones

//@version=6
indicator("Crypto S&D Zones", overlay=true, max_boxes_count=500)

// ══════════════════════════════════════════════════════════════════════════════
// INPUT GROUPS
// ══════════════════════════════════════════════════════════════════════════════
GRP_DETECT  = "═══ Zone Detection ═══"
GRP_CRYPTO  = "═══ Crypto Filters ═══"
GRP_COLORS  = "═══ Colors ═══"
GRP_ALERTS  = "═══ Alerts ═══"

// ══════════════════════════════════════════════════════════════════════════════
// ZONE DETECTION INPUTS
// ══════════════════════════════════════════════════════════════════════════════
pivot_len       = input.int(5, "Pivot Length", minval=2, maxval=20, group=GRP_DETECT,
                  tooltip="Number of bars to look back for pivot detection")
zone_atr_mult   = input.float(0.5, "Zone Height (ATR)", minval=0.1, maxval=2.0, step=0.1, group=GRP_DETECT,
                  tooltip="Zone height as a multiplier of ATR")
impulse_mult    = input.float(1.5, "Impulse Strength", minval=1.0, maxval=4.0, step=0.1, group=GRP_DETECT,
                  tooltip="Minimum move away from zone (ATR multiplier) to validate")
max_zones       = input.int(10, "Max Zones Per Side", minval=5, maxval=30, group=GRP_DETECT,
                  tooltip="Maximum number of demand/supply zones to display")
min_score       = input.int(60, "Min Score to Display", minval=0, maxval=90, group=GRP_DETECT,
                  tooltip="Zones below this score won't be rendered")

// ══════════════════════════════════════════════════════════════════════════════
// CRYPTO FILTER INPUTS
// ══════════════════════════════════════════════════════════════════════════════
use_btc_filter  = input.bool(true, "BTC Dominance Filter", group=GRP_CRYPTO,
                  tooltip="Boost demand zones during alt season, supply zones during BTC dominance")
use_btc_corr    = input.bool(true, "BTC Correlation", group=GRP_CRYPTO,
                  tooltip="Boost zones that align with BTC trend direction")
use_oi_filter   = input.bool(true, "Open Interest Filter", group=GRP_CRYPTO,
                  tooltip="Boost zones confirmed by Open Interest buildup")
use_weekend     = input.bool(true, "Weekend Penalty", group=GRP_CRYPTO,
                  tooltip="Reduce score for zones formed on weekends (low liquidity)")

// ══════════════════════════════════════════════════════════════════════════════
// COLOR INPUTS
// ══════════════════════════════════════════════════════════════════════════════
c_demand        = input.color(#00E676, "Demand Zone", group=GRP_COLORS)
c_supply        = input.color(#FF5252, "Supply Zone", group=GRP_COLORS)

// ══════════════════════════════════════════════════════════════════════════════
// ALERT INPUTS
// ══════════════════════════════════════════════════════════════════════════════
alert_proximity = input.float(0.5, "Alert When Price Within %", minval=0.1, maxval=5.0, step=0.1, group=GRP_ALERTS,
                  tooltip="Alert when price is within this percentage of a zone")
alert_on_break  = input.bool(true, "Alert on Zone Break", group=GRP_ALERTS)

// ══════════════════════════════════════════════════════════════════════════════
// ZONE DATA STRUCTURE
// ══════════════════════════════════════════════════════════════════════════════
type Zone
    float   top
    float   bottom
    int     start_bar
    bool    is_supply
    bool    active
    int     score
    int     touches
    box     viz_box

// Zone arrays
var Zone[] demand_zones = array.new<Zone>()
var Zone[] supply_zones = array.new<Zone>()

// ══════════════════════════════════════════════════════════════════════════════
// MARKET REGIME ENGINE
// ══════════════════════════════════════════════════════════════════════════════

// --- BTC Dominance ---
is_btc_chart = str.contains(str.lower(syminfo.ticker), "btc")
btc_dom = use_btc_filter ? request.security("BTC.D", timeframe.period, close, ignore_invalid_symbol=true) : na
btc_dom_sma = use_btc_filter and not na(btc_dom) ? ta.sma(btc_dom, 30) : na

// BTC.D Regime: 1 = alt season, -1 = BTC dominance, 0 = neutral
btc_regime = 0
if use_btc_filter and not na(btc_dom) and not na(btc_dom_sma)
    if btc_dom > 60 and btc_dom > btc_dom_sma
        btc_regime := -1  // BTC dominance rising - avoid alt longs
    else if btc_dom < 55 and btc_dom < btc_dom_sma
        btc_regime := 1   // Alt season - favorable for alts

// --- BTC Correlation ---
btc_close = is_btc_chart ? close : request.security("BTCUSDT", timeframe.period, close, ignore_invalid_symbol=true)
btc_sma = not na(btc_close) ? ta.sma(btc_close, 50) : na
btc_trend = not na(btc_close) and not na(btc_sma) ? (btc_close > btc_sma ? 1 : -1) : 0

// --- Open Interest ---
oi_ticker = syminfo.ticker + "_OI"
oi_data = use_oi_filter ? request.security(oi_ticker, timeframe.period, close, ignore_invalid_symbol=true) : na
oi_change = not na(oi_data) ? ta.change(oi_data) : na

// OI signals
oi_bullish = not na(oi_change) and oi_change > 0 and close > close[1]  // Long build-up
oi_bearish = not na(oi_change) and oi_change > 0 and close < close[1]  // Short build-up

// --- Session Filter ---
is_weekend = dayofweek == dayofweek.saturday or dayofweek == dayofweek.sunday

// ══════════════════════════════════════════════════════════════════════════════
// ZONE DETECTION ENGINE
// ══════════════════════════════════════════════════════════════════════════════

// ATR for zone calculations
atr_val = ta.atr(14)
atr_sma = ta.sma(atr_val, 50)
volatility_ratio = atr_sma > 0 ? atr_val / atr_sma : 1.0

// Dynamic zone height (expands in high volatility)
zone_height = atr_val * zone_atr_mult * math.max(volatility_ratio, 0.8)
zone_height := math.min(zone_height, atr_val * 2.0)  // Cap at 2 ATR

// Pivot detection
ph = ta.pivothigh(high, pivot_len, pivot_len)
pl = ta.pivotlow(low, pivot_len, pivot_len)

// Volume validation
vol_sma = ta.sma(volume, 20)
rel_volume = vol_sma > 0 ? volume / vol_sma : 1.0
high_volume = rel_volume > 1.5

// ══════════════════════════════════════════════════════════════════════════════
// ZONE SCORING ENGINE (8 Factors)
// ══════════════════════════════════════════════════════════════════════════════
calculate_zone_score(bool is_supply, int pivot_bar, float max_move) =>
    int score = 50  // Base score

    // 1. Volume Spike (+15)
    if high_volume[pivot_bar]
        score += 15

    // 2. Impulse Strength (+15)
    if max_move > atr_val[pivot_bar] * impulse_mult * 1.5
        score += 15
    else if max_move > atr_val[pivot_bar] * impulse_mult * 1.2
        score += 8

    // 3. BTC Alignment (+10) - for altcoins only
    if use_btc_corr and not is_btc_chart and btc_trend != 0
        if (not is_supply and btc_trend == 1) or (is_supply and btc_trend == -1)
            score += 10

    // 4. BTC.D Regime (+10)
    if use_btc_filter and btc_regime != 0
        if (not is_supply and btc_regime >= 0) or (is_supply and btc_regime <= 0)
            score += 10

    // 5. OI Confirmation (+10)
    if use_oi_filter and not na(oi_data)
        if (not is_supply and oi_bullish[pivot_bar]) or (is_supply and oi_bearish[pivot_bar])
            score += 10

    // 6. Session Quality (-10 penalty for weekend)
    if use_weekend and is_weekend[pivot_bar]
        score -= 10

    // 7. Clean Base (+5) - smaller wick ratio = cleaner rejection
    float body = math.abs(close[pivot_bar] - open[pivot_bar])
    float range_val = high[pivot_bar] - low[pivot_bar]
    float wick_ratio = body > 0 ? range_val / body : 10.0
    if wick_ratio < 2.5
        score += 5

    // Cap score
    math.min(math.max(score, 0), 100)

// ══════════════════════════════════════════════════════════════════════════════
// VISUAL RENDERING ENGINE
// ══════════════════════════════════════════════════════════════════════════════

// Score to transparency mapping (higher score = more visible)
get_transparency(int score) =>
    // Score 50 = 85% transparent (very faint)
    // Score 100 = 20% transparent (very bold)
    int transp = int(85 - (score - 50) * 1.3)
    math.min(math.max(transp, 15), 90)

// ══════════════════════════════════════════════════════════════════════════════
// ZONE CREATION
// ══════════════════════════════════════════════════════════════════════════════

// Demand zone detection
if not na(pl)
    // Calculate impulse (move away from zone)
    float max_move_d = 0.0
    for i = 1 to math.min(pivot_len, 5)
        int idx = pivot_len - i
        if idx >= 0
            max_move_d := math.max(max_move_d, close[idx] - pl)

    // Validate impulse
    if max_move_d > atr_val[pivot_len] * impulse_mult
        // Define zone boundaries
        float z_bottom = pl
        float z_top = pl + zone_height[pivot_len]

        // Calculate score
        int z_score = calculate_zone_score(false, pivot_len, max_move_d)

        // Only create if above min_score threshold
        if z_score >= min_score
            // Create visual
            int transp = get_transparency(z_score)
            box viz = box.new(
                bar_index[pivot_len], z_top, bar_index, z_bottom,
                border_color=color.new(c_demand, transp),
                bgcolor=color.new(c_demand, transp + 10),
                border_width=1
            )

            // Create zone object
            Zone new_zone = Zone.new(z_top, z_bottom, bar_index[pivot_len], false, true, z_score, 0, viz)
            demand_zones.push(new_zone)

// Supply zone detection
if not na(ph)
    // Calculate impulse (move away from zone)
    float max_move_s = 0.0
    for i = 1 to math.min(pivot_len, 5)
        int idx = pivot_len - i
        if idx >= 0
            max_move_s := math.max(max_move_s, ph - close[idx])

    // Validate impulse
    if max_move_s > atr_val[pivot_len] * impulse_mult
        // Define zone boundaries
        float z_top = ph
        float z_bottom = ph - zone_height[pivot_len]

        // Calculate score
        int z_score = calculate_zone_score(true, pivot_len, max_move_s)

        // Only create if above min_score threshold
        if z_score >= min_score
            // Create visual
            int transp = get_transparency(z_score)
            box viz = box.new(
                bar_index[pivot_len], z_top, bar_index, z_bottom,
                border_color=color.new(c_supply, transp),
                bgcolor=color.new(c_supply, transp + 10),
                border_width=1
            )

            // Create zone object
            Zone new_zone = Zone.new(z_top, z_bottom, bar_index[pivot_len], true, true, z_score, 0, viz)
            supply_zones.push(new_zone)

// ══════════════════════════════════════════════════════════════════════════════
// ZONE LIFECYCLE MANAGEMENT
// ══════════════════════════════════════════════════════════════════════════════

// Alert flags
bool zone_approach_demand = false
bool zone_approach_supply = false
bool zone_break_demand = false
bool zone_break_supply = false

// Manage demand zones - FIFO removal if over limit
while demand_zones.size() > max_zones
    box.delete(demand_zones.shift().viz_box)

// Update active demand zones
if demand_zones.size() > 0
    for i = demand_zones.size() - 1 to 0
        float d_top = demand_zones.get(i).top
        float d_bottom = demand_zones.get(i).bottom
        bool d_active = demand_zones.get(i).active
        box d_box = demand_zones.get(i).viz_box

        if d_active
            // Extend zone to current bar
            d_box.set_right(bar_index)

            // Check for zone break (close below zone bottom)
            if close < d_bottom
                // DELETE immediately
                d_box.delete()
                demand_zones.remove(i)
                zone_break_demand := true
            else
                // Check for zone approach
                float zone_dist_d = (d_bottom - close) / close * 100
                if zone_dist_d > 0 and zone_dist_d < alert_proximity
                    zone_approach_demand := true

// Manage supply zones - FIFO removal if over limit
while supply_zones.size() > max_zones
    box.delete(supply_zones.shift().viz_box)

// Update active supply zones
if supply_zones.size() > 0
    for i = supply_zones.size() - 1 to 0
        float s_top = supply_zones.get(i).top
        float s_bottom = supply_zones.get(i).bottom
        bool s_active = supply_zones.get(i).active
        box s_box = supply_zones.get(i).viz_box

        if s_active
            // Extend zone to current bar
            s_box.set_right(bar_index)

            // Check for zone break (close above zone top)
            if close > s_top
                // DELETE immediately
                s_box.delete()
                supply_zones.remove(i)
                zone_break_supply := true
            else
                // Check for zone approach
                float zone_dist_s = (close - s_top) / close * 100
                if zone_dist_s > 0 and zone_dist_s < alert_proximity
                    zone_approach_supply := true

// ══════════════════════════════════════════════════════════════════════════════
// ALERTS
// ══════════════════════════════════════════════════════════════════════════════

alertcondition(zone_approach_demand, "Demand Zone Approach", "Price approaching demand zone")
alertcondition(zone_approach_supply, "Supply Zone Approach", "Price approaching supply zone")
alertcondition(zone_break_demand and alert_on_break, "Demand Zone Break", "Demand zone broken - bearish")
alertcondition(zone_break_supply and alert_on_break, "Supply Zone Break", "Supply zone broken - bullish")
alertcondition(btc_regime == 1 and btc_regime[1] != 1, "Alt Season Signal", "BTC.D falling - favorable for altcoins")
alertcondition(btc_regime == -1 and btc_regime[1] != -1, "BTC Dominance Signal", "BTC.D rising - risk-off for altcoins")
